"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from autumn_sdk import errors, models, utils
from autumn_sdk._hooks import HookContext
from autumn_sdk.types import OptionalNullable, UNSET
from autumn_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class Billing(BaseSDK):
    def attach(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingAttachFeatureQuantity],
                List[models.BillingAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.BillingAttachFreeTrial, models.BillingAttachFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.BillingAttachCustomize, models.BillingAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingAttachInvoiceMode,
                models.BillingAttachInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.BillingAttachBillingBehavior] = None,
        discounts: Optional[
            Union[
                List[models.BillingAttachDiscountUnion],
                List[models.BillingAttachDiscountUnionTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.BillingAttachPlanSchedule] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingAttachResponse:
        r"""Attaches a plan to a customer. Handles new subscriptions, upgrades and downgrades.

        Use this endpoint to subscribe a customer to a plan, upgrade/downgrade between plans, or add an add-on product.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingAttachFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.BillingAttachFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingAttachInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.BillingAttachDiscountUnion]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def attach_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingAttachFeatureQuantity],
                List[models.BillingAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.BillingAttachFreeTrial, models.BillingAttachFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.BillingAttachCustomize, models.BillingAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingAttachInvoiceMode,
                models.BillingAttachInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.BillingAttachBillingBehavior] = None,
        discounts: Optional[
            Union[
                List[models.BillingAttachDiscountUnion],
                List[models.BillingAttachDiscountUnionTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.BillingAttachPlanSchedule] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingAttachResponse:
        r"""Attaches a plan to a customer. Handles new subscriptions, upgrades and downgrades.

        Use this endpoint to subscribe a customer to a plan, upgrade/downgrade between plans, or add an add-on product.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingAttachFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.BillingAttachFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingAttachInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.BillingAttachDiscountUnion]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def preview_attach(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewAttachFeatureQuantity],
                List[models.PreviewAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.PreviewAttachFreeTrial, models.PreviewAttachFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.PreviewAttachCustomize, models.PreviewAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewAttachInvoiceMode,
                models.PreviewAttachInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.PreviewAttachBillingBehavior] = None,
        discounts: Optional[
            Union[
                List[models.PreviewAttachDiscountUnion],
                List[models.PreviewAttachDiscountUnionTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.PreviewAttachPlanSchedule] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewAttachResponse:
        r"""Previews the billing changes that would occur when attaching a plan, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a subscription change.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewAttachFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewAttachFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewAttachInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewAttachDiscountUnion]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.preview_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def preview_attach_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewAttachFeatureQuantity],
                List[models.PreviewAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.PreviewAttachFreeTrial, models.PreviewAttachFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.PreviewAttachCustomize, models.PreviewAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewAttachInvoiceMode,
                models.PreviewAttachInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.PreviewAttachBillingBehavior] = None,
        discounts: Optional[
            Union[
                List[models.PreviewAttachDiscountUnion],
                List[models.PreviewAttachDiscountUnionTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.PreviewAttachPlanSchedule] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewAttachResponse:
        r"""Previews the billing changes that would occur when attaching a plan, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a subscription change.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewAttachFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewAttachFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewAttachInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewAttachDiscountUnion]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.preview_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingUpdateFeatureQuantity],
                List[models.BillingUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.BillingUpdateFreeTrial, models.BillingUpdateFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.BillingUpdateCustomize, models.BillingUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingUpdateInvoiceMode,
                models.BillingUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.BillingUpdateBillingBehavior] = None,
        cancel_action: Optional[models.BillingUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingUpdateResponse:
        r"""Updates an existing subscription. Use to modify feature quantities, cancel, or change plan configuration.

        Use this endpoint to update prepaid quantities, cancel a subscription (immediately or at end of cycle), or modify subscription settings.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateSubscriptionParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingUpdateFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.BillingUpdateFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingUpdateInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateSubscriptionParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingUpdateFeatureQuantity],
                List[models.BillingUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.BillingUpdateFreeTrial, models.BillingUpdateFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.BillingUpdateCustomize, models.BillingUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingUpdateInvoiceMode,
                models.BillingUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.BillingUpdateBillingBehavior] = None,
        cancel_action: Optional[models.BillingUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingUpdateResponse:
        r"""Updates an existing subscription. Use to modify feature quantities, cancel, or change plan configuration.

        Use this endpoint to update prepaid quantities, cancel a subscription (immediately or at end of cycle), or modify subscription settings.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateSubscriptionParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingUpdateFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.BillingUpdateFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingUpdateInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateSubscriptionParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def preview_update(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewUpdateFeatureQuantity],
                List[models.PreviewUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.PreviewUpdateFreeTrial, models.PreviewUpdateFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.PreviewUpdateCustomize, models.PreviewUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewUpdateInvoiceMode,
                models.PreviewUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.PreviewUpdateBillingBehavior] = None,
        cancel_action: Optional[models.PreviewUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUpdateResponse:
        r"""Previews the billing changes that would occur when updating a subscription, without actually making any changes.

        Use this endpoint to show customers prorated charges or refunds before confirming subscription modifications.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewUpdateParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewUpdateFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewUpdateFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewUpdateInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.preview_update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewUpdateParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def preview_update_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewUpdateFeatureQuantity],
                List[models.PreviewUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        free_trial: OptionalNullable[
            Union[models.PreviewUpdateFreeTrial, models.PreviewUpdateFreeTrialTypedDict]
        ] = UNSET,
        customize: Optional[
            Union[models.PreviewUpdateCustomize, models.PreviewUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewUpdateInvoiceMode,
                models.PreviewUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        billing_behavior: Optional[models.PreviewUpdateBillingBehavior] = None,
        cancel_action: Optional[models.PreviewUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUpdateResponse:
        r"""Previews the billing changes that would occur when updating a subscription, without actually making any changes.

        Use this endpoint to show customers prorated charges or refunds before confirming subscription modifications.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param free_trial: Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
        :param customize: Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param billing_behavior: How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewUpdateParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewUpdateFeatureQuantity]]
            ),
            version=version,
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewUpdateFreeTrial]
            ),
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewUpdateInvoiceMode]
            ),
            billing_behavior=billing_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.preview_update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewUpdateParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def open_customer_portal(
        self,
        *,
        customer_id: str,
        configuration_id: Optional[str] = None,
        return_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OpenCustomerPortalResponse:
        r"""Create a billing portal session for a customer to manage their subscription.

        :param customer_id: The ID of the customer to open the billing portal for.
        :param configuration_id: Stripe billing portal configuration ID. Create configurations in your Stripe dashboard.
        :param return_url: URL to redirect to when back button is clicked in the billing portal
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OpenCustomerPortalParams(
            customer_id=customer_id,
            configuration_id=configuration_id,
            return_url=return_url,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.open_customer_portal",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.OpenCustomerPortalGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OpenCustomerPortalParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="openCustomerPortal",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.OpenCustomerPortalResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def open_customer_portal_async(
        self,
        *,
        customer_id: str,
        configuration_id: Optional[str] = None,
        return_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OpenCustomerPortalResponse:
        r"""Create a billing portal session for a customer to manage their subscription.

        :param customer_id: The ID of the customer to open the billing portal for.
        :param configuration_id: Stripe billing portal configuration ID. Create configurations in your Stripe dashboard.
        :param return_url: URL to redirect to when back button is clicked in the billing portal
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OpenCustomerPortalParams(
            customer_id=customer_id,
            configuration_id=configuration_id,
            return_url=return_url,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.open_customer_portal",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.OpenCustomerPortalGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OpenCustomerPortalParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="openCustomerPortal",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.OpenCustomerPortalResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)
