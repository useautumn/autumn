"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from autumn_sdk import errors, models, utils
from autumn_sdk._hooks import HookContext
from autumn_sdk.types import OptionalNullable, UNSET
from autumn_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union


class Billing(BaseSDK):
    def attach(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.AttachFeatureQuantity],
                List[models.AttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.AttachCustomize, models.AttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[models.AttachInvoiceMode, models.AttachInvoiceModeTypedDict]
        ] = None,
        proration_behavior: Optional[models.AttachProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.AttachAttachDiscount],
                List[models.AttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.AttachPlanSchedule] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AttachResponse:
        r"""Attaches a plan to a customer. Handles new subscriptions, upgrades and downgrades.

        Use this endpoint to subscribe a customer to a plan, upgrade/downgrade between plans, or add an add-on product.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.AttachFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.AttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.AttachInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.AttachAttachDiscount]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.AttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="attach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def attach_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.AttachFeatureQuantity],
                List[models.AttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.AttachCustomize, models.AttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[models.AttachInvoiceMode, models.AttachInvoiceModeTypedDict]
        ] = None,
        proration_behavior: Optional[models.AttachProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.AttachAttachDiscount],
                List[models.AttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.AttachPlanSchedule] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AttachResponse:
        r"""Attaches a plan to a customer. Handles new subscriptions, upgrades and downgrades.

        Use this endpoint to subscribe a customer to a plan, upgrade/downgrade between plans, or add an add-on product.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.AttachFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.AttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.AttachInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.AttachAttachDiscount]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.AttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.AttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="attach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def multi_attach(
        self,
        *,
        customer_id: str,
        plans: Union[
            List[models.MultiAttachPlan], List[models.MultiAttachPlanTypedDict]
        ],
        entity_id: Optional[str] = None,
        free_trial: OptionalNullable[
            Union[
                models.MultiAttachFreeTrialParams,
                models.MultiAttachFreeTrialParamsTypedDict,
            ]
        ] = UNSET,
        invoice_mode: Optional[
            Union[models.MultiAttachInvoiceMode, models.MultiAttachInvoiceModeTypedDict]
        ] = None,
        discounts: Optional[
            Union[
                List[models.MultiAttachAttachDiscount],
                List[models.MultiAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        redirect_mode: Optional[models.MultiAttachRedirectMode] = "if_required",
        new_billing_subscription: Optional[bool] = None,
        customer_data: Optional[
            Union[models.CustomerData, models.CustomerDataTypedDict]
        ] = None,
        entity_data: Optional[
            Union[models.MultiAttachEntityData, models.MultiAttachEntityDataTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.MultiAttachResponse:
        r"""Attaches multiple plans to a customer in a single request. Creates a single Stripe subscription with all plans consolidated.

        Use this endpoint when you need to subscribe a customer to multiple plans at once, such as a base plan plus add-ons, or to create a bundle of products.

        :param customer_id: The ID of the customer to attach the plans to.
        :param plans: The list of plans to attach to the customer.
        :param entity_id: The ID of the entity to attach the plans to.
        :param free_trial: Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param redirect_mode: Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param customer_data: Customer details to set when creating a customer
        :param entity_data:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MultiAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plans=utils.get_pydantic_model(plans, List[models.MultiAttachPlan]),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.MultiAttachFreeTrialParams]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.MultiAttachInvoiceMode]
            ),
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.MultiAttachAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
            redirect_mode=redirect_mode,
            new_billing_subscription=new_billing_subscription,
            customer_data=utils.get_pydantic_model(
                customer_data, Optional[models.CustomerData]
            ),
            entity_data=utils.get_pydantic_model(
                entity_data, Optional[models.MultiAttachEntityData]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.multi_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.MultiAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.MultiAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="multiAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.MultiAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def multi_attach_async(
        self,
        *,
        customer_id: str,
        plans: Union[
            List[models.MultiAttachPlan], List[models.MultiAttachPlanTypedDict]
        ],
        entity_id: Optional[str] = None,
        free_trial: OptionalNullable[
            Union[
                models.MultiAttachFreeTrialParams,
                models.MultiAttachFreeTrialParamsTypedDict,
            ]
        ] = UNSET,
        invoice_mode: Optional[
            Union[models.MultiAttachInvoiceMode, models.MultiAttachInvoiceModeTypedDict]
        ] = None,
        discounts: Optional[
            Union[
                List[models.MultiAttachAttachDiscount],
                List[models.MultiAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        redirect_mode: Optional[models.MultiAttachRedirectMode] = "if_required",
        new_billing_subscription: Optional[bool] = None,
        customer_data: Optional[
            Union[models.CustomerData, models.CustomerDataTypedDict]
        ] = None,
        entity_data: Optional[
            Union[models.MultiAttachEntityData, models.MultiAttachEntityDataTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.MultiAttachResponse:
        r"""Attaches multiple plans to a customer in a single request. Creates a single Stripe subscription with all plans consolidated.

        Use this endpoint when you need to subscribe a customer to multiple plans at once, such as a base plan plus add-ons, or to create a bundle of products.

        :param customer_id: The ID of the customer to attach the plans to.
        :param plans: The list of plans to attach to the customer.
        :param entity_id: The ID of the entity to attach the plans to.
        :param free_trial: Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param redirect_mode: Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param customer_data: Customer details to set when creating a customer
        :param entity_data:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MultiAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plans=utils.get_pydantic_model(plans, List[models.MultiAttachPlan]),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.MultiAttachFreeTrialParams]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.MultiAttachInvoiceMode]
            ),
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.MultiAttachAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
            redirect_mode=redirect_mode,
            new_billing_subscription=new_billing_subscription,
            customer_data=utils.get_pydantic_model(
                customer_data, Optional[models.CustomerData]
            ),
            entity_data=utils.get_pydantic_model(
                entity_data, Optional[models.MultiAttachEntityData]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.multi_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.MultiAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.MultiAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="multiAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.MultiAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def preview_attach(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewAttachFeatureQuantity],
                List[models.PreviewAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.PreviewAttachCustomize, models.PreviewAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewAttachInvoiceMode,
                models.PreviewAttachInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.PreviewAttachProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.PreviewAttachAttachDiscount],
                List[models.PreviewAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.PreviewAttachPlanSchedule] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewAttachResponse:
        r"""Previews the billing changes that would occur when attaching a plan, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a subscription change.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewAttachFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewAttachInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewAttachAttachDiscount]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.preview_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def preview_attach_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewAttachFeatureQuantity],
                List[models.PreviewAttachFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.PreviewAttachCustomize, models.PreviewAttachCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewAttachInvoiceMode,
                models.PreviewAttachInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.PreviewAttachProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.PreviewAttachAttachDiscount],
                List[models.PreviewAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        new_billing_subscription: Optional[bool] = None,
        plan_schedule: Optional[models.PreviewAttachPlanSchedule] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewAttachResponse:
        r"""Previews the billing changes that would occur when attaching a plan, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a subscription change.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param plan_schedule: When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewAttachFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewAttachCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewAttachInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewAttachAttachDiscount]]
            ),
            success_url=success_url,
            new_billing_subscription=new_billing_subscription,
            plan_schedule=plan_schedule,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.preview_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def preview_multi_attach(
        self,
        *,
        customer_id: str,
        plans: Union[
            List[models.PreviewMultiAttachPlan],
            List[models.PreviewMultiAttachPlanTypedDict],
        ],
        entity_id: Optional[str] = None,
        free_trial: OptionalNullable[
            Union[
                models.PreviewMultiAttachFreeTrialParams,
                models.PreviewMultiAttachFreeTrialParamsTypedDict,
            ]
        ] = UNSET,
        invoice_mode: Optional[
            Union[
                models.PreviewMultiAttachInvoiceMode,
                models.PreviewMultiAttachInvoiceModeTypedDict,
            ]
        ] = None,
        discounts: Optional[
            Union[
                List[models.PreviewMultiAttachAttachDiscount],
                List[models.PreviewMultiAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        redirect_mode: Optional[models.PreviewMultiAttachRedirectMode] = "if_required",
        new_billing_subscription: Optional[bool] = None,
        customer_data: Optional[
            Union[models.CustomerData, models.CustomerDataTypedDict]
        ] = None,
        entity_data: Optional[
            Union[
                models.PreviewMultiAttachEntityData,
                models.PreviewMultiAttachEntityDataTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewMultiAttachResponse:
        r"""Previews the billing changes that would occur when attaching multiple plans, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a multi-plan subscription.

        :param customer_id: The ID of the customer to attach the plans to.
        :param plans: The list of plans to attach to the customer.
        :param entity_id: The ID of the entity to attach the plans to.
        :param free_trial: Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param redirect_mode: Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param customer_data: Customer details to set when creating a customer
        :param entity_data:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewMultiAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plans=utils.get_pydantic_model(plans, List[models.PreviewMultiAttachPlan]),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewMultiAttachFreeTrialParams]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewMultiAttachInvoiceMode]
            ),
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewMultiAttachAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
            redirect_mode=redirect_mode,
            new_billing_subscription=new_billing_subscription,
            customer_data=utils.get_pydantic_model(
                customer_data, Optional[models.CustomerData]
            ),
            entity_data=utils.get_pydantic_model(
                entity_data, Optional[models.PreviewMultiAttachEntityData]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.preview_multi_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewMultiAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewMultiAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewMultiAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewMultiAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def preview_multi_attach_async(
        self,
        *,
        customer_id: str,
        plans: Union[
            List[models.PreviewMultiAttachPlan],
            List[models.PreviewMultiAttachPlanTypedDict],
        ],
        entity_id: Optional[str] = None,
        free_trial: OptionalNullable[
            Union[
                models.PreviewMultiAttachFreeTrialParams,
                models.PreviewMultiAttachFreeTrialParamsTypedDict,
            ]
        ] = UNSET,
        invoice_mode: Optional[
            Union[
                models.PreviewMultiAttachInvoiceMode,
                models.PreviewMultiAttachInvoiceModeTypedDict,
            ]
        ] = None,
        discounts: Optional[
            Union[
                List[models.PreviewMultiAttachAttachDiscount],
                List[models.PreviewMultiAttachAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        redirect_mode: Optional[models.PreviewMultiAttachRedirectMode] = "if_required",
        new_billing_subscription: Optional[bool] = None,
        customer_data: Optional[
            Union[models.CustomerData, models.CustomerDataTypedDict]
        ] = None,
        entity_data: Optional[
            Union[
                models.PreviewMultiAttachEntityData,
                models.PreviewMultiAttachEntityDataTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewMultiAttachResponse:
        r"""Previews the billing changes that would occur when attaching multiple plans, without actually making any changes.

        Use this endpoint to show customers what they will be charged before confirming a multi-plan subscription.

        :param customer_id: The ID of the customer to attach the plans to.
        :param plans: The list of plans to attach to the customer.
        :param entity_id: The ID of the entity to attach the plans to.
        :param free_trial: Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param redirect_mode: Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
        :param new_billing_subscription: Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
        :param customer_data: Customer details to set when creating a customer
        :param entity_data:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewMultiAttachParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plans=utils.get_pydantic_model(plans, List[models.PreviewMultiAttachPlan]),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.PreviewMultiAttachFreeTrialParams]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewMultiAttachInvoiceMode]
            ),
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.PreviewMultiAttachAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
            redirect_mode=redirect_mode,
            new_billing_subscription=new_billing_subscription,
            customer_data=utils.get_pydantic_model(
                customer_data, Optional[models.CustomerData]
            ),
            entity_data=utils.get_pydantic_model(
                entity_data, Optional[models.PreviewMultiAttachEntityData]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.preview_multi_attach",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewMultiAttachGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewMultiAttachParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewMultiAttach",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewMultiAttachResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingUpdateFeatureQuantity],
                List[models.BillingUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.BillingUpdateCustomize, models.BillingUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingUpdateInvoiceMode,
                models.BillingUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.BillingUpdateProrationBehavior] = None,
        cancel_action: Optional[models.BillingUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingUpdateResponse:
        r"""Updates an existing subscription. Use to modify feature quantities, cancel, or change plan configuration.

        Use this endpoint to update prepaid quantities, cancel a subscription (immediately or at end of cycle), or modify subscription settings.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateSubscriptionParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingUpdateFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingUpdateInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateSubscriptionParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.BillingUpdateFeatureQuantity],
                List[models.BillingUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.BillingUpdateCustomize, models.BillingUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.BillingUpdateInvoiceMode,
                models.BillingUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.BillingUpdateProrationBehavior] = None,
        cancel_action: Optional[models.BillingUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingUpdateResponse:
        r"""Updates an existing subscription. Use to modify feature quantities, cancel, or change plan configuration.

        Use this endpoint to update prepaid quantities, cancel a subscription (immediately or at end of cycle), or modify subscription settings.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateSubscriptionParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.BillingUpdateFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.BillingUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.BillingUpdateInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.BillingUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateSubscriptionParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="billingUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def preview_update(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewUpdateFeatureQuantity],
                List[models.PreviewUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.PreviewUpdateCustomize, models.PreviewUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewUpdateInvoiceMode,
                models.PreviewUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.PreviewUpdateProrationBehavior] = None,
        cancel_action: Optional[models.PreviewUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUpdateResponse:
        r"""Previews the billing changes that would occur when updating a subscription, without actually making any changes.

        Use this endpoint to show customers prorated charges or refunds before confirming subscription modifications.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewUpdateParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewUpdateFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewUpdateInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.preview_update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewUpdateParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def preview_update_async(
        self,
        *,
        customer_id: str,
        plan_id: str,
        entity_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.PreviewUpdateFeatureQuantity],
                List[models.PreviewUpdateFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.PreviewUpdateCustomize, models.PreviewUpdateCustomizeTypedDict]
        ] = None,
        invoice_mode: Optional[
            Union[
                models.PreviewUpdateInvoiceMode,
                models.PreviewUpdateInvoiceModeTypedDict,
            ]
        ] = None,
        proration_behavior: Optional[models.PreviewUpdateProrationBehavior] = None,
        cancel_action: Optional[models.PreviewUpdateCancelAction] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUpdateResponse:
        r"""Previews the billing changes that would occur when updating a subscription, without actually making any changes.

        Use this endpoint to show customers prorated charges or refunds before confirming subscription modifications.

        :param customer_id: The ID of the customer to attach the plan to.
        :param plan_id: The ID of the plan.
        :param entity_id: The ID of the entity to attach the plan to.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param invoice_mode: Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param cancel_action: Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewUpdateParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.PreviewUpdateFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.PreviewUpdateCustomize]
            ),
            invoice_mode=utils.get_pydantic_model(
                invoice_mode, Optional[models.PreviewUpdateInvoiceMode]
            ),
            proration_behavior=proration_behavior,
            cancel_action=cancel_action,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.preview_update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.PreviewUpdateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PreviewUpdateParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="previewUpdate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PreviewUpdateResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def open_customer_portal(
        self,
        *,
        customer_id: str,
        configuration_id: Optional[str] = None,
        return_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OpenCustomerPortalResponse:
        r"""Create a billing portal session for a customer to manage their subscription.

        :param customer_id: The ID of the customer to open the billing portal for.
        :param configuration_id: Stripe billing portal configuration ID. Create configurations in your Stripe dashboard.
        :param return_url: URL to redirect to when back button is clicked in the billing portal
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OpenCustomerPortalParams(
            customer_id=customer_id,
            configuration_id=configuration_id,
            return_url=return_url,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.open_customer_portal",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.OpenCustomerPortalGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OpenCustomerPortalParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="openCustomerPortal",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.OpenCustomerPortalResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def open_customer_portal_async(
        self,
        *,
        customer_id: str,
        configuration_id: Optional[str] = None,
        return_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OpenCustomerPortalResponse:
        r"""Create a billing portal session for a customer to manage their subscription.

        :param customer_id: The ID of the customer to open the billing portal for.
        :param configuration_id: Stripe billing portal configuration ID. Create configurations in your Stripe dashboard.
        :param return_url: URL to redirect to when back button is clicked in the billing portal
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OpenCustomerPortalParams(
            customer_id=customer_id,
            configuration_id=configuration_id,
            return_url=return_url,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.open_customer_portal",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.OpenCustomerPortalGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OpenCustomerPortalParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="openCustomerPortal",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.OpenCustomerPortalResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def setup_payment(
        self,
        *,
        customer_id: str,
        entity_id: Optional[str] = None,
        plan_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.SetupPaymentFeatureQuantity],
                List[models.SetupPaymentFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.SetupPaymentCustomize, models.SetupPaymentCustomizeTypedDict]
        ] = None,
        proration_behavior: Optional[models.SetupPaymentProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.SetupPaymentAttachDiscount],
                List[models.SetupPaymentAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SetupPaymentResponse:
        r"""Create a payment setup session for a customer to add or update their payment method.

        :param customer_id: The ID of the customer to attach the plan to.
        :param entity_id: The ID of the entity to attach the plan to.
        :param plan_id: If specified, the plan will be attached to the customer after setup.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SetupPaymentParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.SetupPaymentFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.SetupPaymentCustomize]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.SetupPaymentAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request(
            method="POST",
            path="/v1/billing.setup_payment",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.SetupPaymentGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SetupPaymentParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="setupPayment",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SetupPaymentResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def setup_payment_async(
        self,
        *,
        customer_id: str,
        entity_id: Optional[str] = None,
        plan_id: Optional[str] = None,
        feature_quantities: Optional[
            Union[
                List[models.SetupPaymentFeatureQuantity],
                List[models.SetupPaymentFeatureQuantityTypedDict],
            ]
        ] = None,
        version: Optional[float] = None,
        customize: Optional[
            Union[models.SetupPaymentCustomize, models.SetupPaymentCustomizeTypedDict]
        ] = None,
        proration_behavior: Optional[models.SetupPaymentProrationBehavior] = None,
        discounts: Optional[
            Union[
                List[models.SetupPaymentAttachDiscount],
                List[models.SetupPaymentAttachDiscountTypedDict],
            ]
        ] = None,
        success_url: Optional[str] = None,
        checkout_session_params: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SetupPaymentResponse:
        r"""Create a payment setup session for a customer to add or update their payment method.

        :param customer_id: The ID of the customer to attach the plan to.
        :param entity_id: The ID of the entity to attach the plan to.
        :param plan_id: If specified, the plan will be attached to the customer after setup.
        :param feature_quantities: If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
        :param version: The version of the plan to attach.
        :param customize: Customize the plan to attach. Can override the price, items, free trial, or a combination.
        :param proration_behavior: How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
        :param discounts: List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
        :param success_url: URL to redirect to after successful checkout.
        :param checkout_session_params: Additional parameters to pass into the creation of the Stripe checkout session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SetupPaymentParams(
            customer_id=customer_id,
            entity_id=entity_id,
            plan_id=plan_id,
            feature_quantities=utils.get_pydantic_model(
                feature_quantities, Optional[List[models.SetupPaymentFeatureQuantity]]
            ),
            version=version,
            customize=utils.get_pydantic_model(
                customize, Optional[models.SetupPaymentCustomize]
            ),
            proration_behavior=proration_behavior,
            discounts=utils.get_pydantic_model(
                discounts, Optional[List[models.SetupPaymentAttachDiscount]]
            ),
            success_url=success_url,
            checkout_session_params=checkout_session_params,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/billing.setup_payment",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.SetupPaymentGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SetupPaymentParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="setupPayment",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SetupPaymentResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)
