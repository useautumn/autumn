"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .plan import Plan, PlanTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ListCustomersGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class ListCustomersGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListCustomersPlanTypedDict(TypedDict):
    id: str
    versions: NotRequired[List[float]]


class ListCustomersPlan(BaseModel):
    id: str

    versions: Optional[List[float]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["versions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SubscriptionStatus = Literal[
    "active",
    "scheduled",
]
r"""Filter by customer product status. Defaults to active and scheduled"""


class ListCustomersParamsTypedDict(TypedDict):
    offset: NotRequired[int]
    r"""Number of items to skip"""
    limit: NotRequired[int]
    r"""Number of items to return. Default 10, max 1000."""
    plans: NotRequired[List[ListCustomersPlanTypedDict]]
    r"""Filter by plan ID and version. Returns customers with active subscriptions to this plan."""
    subscription_status: NotRequired[SubscriptionStatus]
    r"""Filter by customer product status. Defaults to active and scheduled"""
    search: NotRequired[str]
    r"""Search customers by id, name, or email"""


class ListCustomersParams(BaseModel):
    offset: Optional[int] = 0
    r"""Number of items to skip"""

    limit: Optional[int] = 10
    r"""Number of items to return. Default 10, max 1000."""

    plans: Optional[List[ListCustomersPlan]] = None
    r"""Filter by plan ID and version. Returns customers with active subscriptions to this plan."""

    subscription_status: Optional[SubscriptionStatus] = None
    r"""Filter by customer product status. Defaults to active and scheduled"""

    search: Optional[str] = None
    r"""Search customers by id, name, or email"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["offset", "limit", "plans", "subscription_status", "search"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListCustomersEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment this customer was created in."""


ListCustomersStatus = Union[
    Literal[
        "active",
        "scheduled",
    ],
    UnrecognizedStr,
]
r"""Current status of the subscription."""


class ListCustomersSubscriptionTypedDict(TypedDict):
    plan_id: str
    r"""The unique identifier of the subscribed plan."""
    auto_enable: bool
    r"""Whether the plan was automatically enabled for the customer."""
    add_on: bool
    r"""Whether this is an add-on plan rather than a base subscription."""
    status: ListCustomersStatus
    r"""Current status of the subscription."""
    past_due: bool
    r"""Whether the subscription has overdue payments."""
    canceled_at: Nullable[float]
    r"""Timestamp when the subscription was canceled, or null if not canceled."""
    expires_at: Nullable[float]
    r"""Timestamp when the subscription will expire, or null if no expiry set."""
    trial_ends_at: Nullable[float]
    r"""Timestamp when the trial period ends, or null if not on trial."""
    started_at: float
    r"""Timestamp when the subscription started."""
    current_period_start: Nullable[float]
    r"""Start timestamp of the current billing period."""
    current_period_end: Nullable[float]
    r"""End timestamp of the current billing period."""
    quantity: float
    r"""Number of units of this subscription (for per-seat plans)."""
    plan: NotRequired[PlanTypedDict]


class ListCustomersSubscription(BaseModel):
    plan_id: str
    r"""The unique identifier of the subscribed plan."""

    auto_enable: bool
    r"""Whether the plan was automatically enabled for the customer."""

    add_on: bool
    r"""Whether this is an add-on plan rather than a base subscription."""

    status: ListCustomersStatus
    r"""Current status of the subscription."""

    past_due: bool
    r"""Whether the subscription has overdue payments."""

    canceled_at: Nullable[float]
    r"""Timestamp when the subscription was canceled, or null if not canceled."""

    expires_at: Nullable[float]
    r"""Timestamp when the subscription will expire, or null if no expiry set."""

    trial_ends_at: Nullable[float]
    r"""Timestamp when the trial period ends, or null if not on trial."""

    started_at: float
    r"""Timestamp when the subscription started."""

    current_period_start: Nullable[float]
    r"""Start timestamp of the current billing period."""

    current_period_end: Nullable[float]
    r"""End timestamp of the current billing period."""

    quantity: float
    r"""Number of units of this subscription (for per-seat plans)."""

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(
            [
                "canceled_at",
                "expires_at",
                "trial_ends_at",
                "current_period_start",
                "current_period_end",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersPurchaseTypedDict(TypedDict):
    plan_id: str
    r"""The unique identifier of the purchased plan."""
    expires_at: Nullable[float]
    r"""Timestamp when the purchase expires, or null for lifetime access."""
    started_at: float
    r"""Timestamp when the purchase was made."""
    quantity: float
    r"""Number of units purchased."""
    plan: NotRequired[PlanTypedDict]


class ListCustomersPurchase(BaseModel):
    plan_id: str
    r"""The unique identifier of the purchased plan."""

    expires_at: Nullable[float]
    r"""Timestamp when the purchase expires, or null for lifetime access."""

    started_at: float
    r"""Timestamp when the purchase was made."""

    quantity: float
    r"""Number of units purchased."""

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(["expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListCustomersType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class ListCustomersCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class ListCustomersCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class ListCustomersDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class ListCustomersDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    name: str
    type: ListCustomersType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[ListCustomersCreditSchemaTypedDict]]
    display: NotRequired[ListCustomersDisplayTypedDict]


class ListCustomersFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str

    name: str

    type: ListCustomersType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[ListCustomersCreditSchema]] = None

    display: Optional[ListCustomersDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListCustomersIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


ListCustomersIntervalUnionTypedDict = TypeAliasType(
    "ListCustomersIntervalUnionTypedDict", Union[ListCustomersIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


ListCustomersIntervalUnion = TypeAliasType(
    "ListCustomersIntervalUnion", Union[ListCustomersIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


class ListCustomersResetTypedDict(TypedDict):
    interval: ListCustomersIntervalUnionTypedDict
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""
    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""


class ListCustomersReset(BaseModel):
    interval: ListCustomersIntervalUnion
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""

    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersTierTypedDict(TypedDict):
    amount: float
    to: NotRequired[Any]


class ListCustomersTier(BaseModel):
    amount: float

    to: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["to"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListCustomersBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""Whether usage is prepaid or billed pay-per-use."""


class ListCustomersPriceTypedDict(TypedDict):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""
    billing_method: ListCustomersBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""
    amount: NotRequired[float]
    r"""The per-unit price amount."""
    tiers: NotRequired[List[ListCustomersTierTypedDict]]
    r"""Tiered pricing configuration if applicable."""


class ListCustomersPrice(BaseModel):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""

    billing_method: ListCustomersBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""

    amount: Optional[float] = None
    r"""The per-unit price amount."""

    tiers: Optional[List[ListCustomersTier]] = None
    r"""Tiered pricing configuration if applicable."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""
    included_grant: float
    r"""Amount granted from the plan's included usage."""
    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Amount consumed in the current period."""
    unlimited: bool
    r"""Whether this balance has unlimited usage."""
    reset: Nullable[ListCustomersResetTypedDict]
    r"""Reset configuration for this balance, or null if no reset."""
    price: Nullable[ListCustomersPriceTypedDict]
    r"""Pricing configuration if this balance has usage-based pricing."""
    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""
    id: NotRequired[str]
    r"""The unique identifier for this balance breakdown."""


class ListCustomersBreakdown(BaseModel):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""

    included_grant: float
    r"""Amount granted from the plan's included usage."""

    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Amount consumed in the current period."""

    unlimited: bool
    r"""Whether this balance has unlimited usage."""

    reset: Nullable[ListCustomersReset]
    r"""Reset configuration for this balance, or null if no reset."""

    price: Nullable[ListCustomersPrice]
    r"""Pricing configuration if this balance has usage-based pricing."""

    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""

    id: Optional[str] = ""
    r"""The unique identifier for this balance breakdown."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersRolloverTypedDict(TypedDict):
    balance: float
    r"""Amount of balance rolled over from a previous period."""
    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class ListCustomersRollover(BaseModel):
    balance: float
    r"""Amount of balance rolled over from a previous period."""

    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class ListCustomersBalancesTypedDict(TypedDict):
    feature_id: str
    r"""The feature ID this balance is for."""
    granted: float
    r"""Total balance granted (included + prepaid)."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Total usage consumed in the current period."""
    unlimited: bool
    r"""Whether this feature has unlimited usage."""
    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""
    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""
    feature: NotRequired[ListCustomersFeatureTypedDict]
    r"""The full feature object if expanded."""
    breakdown: NotRequired[List[ListCustomersBreakdownTypedDict]]
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""
    rollovers: NotRequired[List[ListCustomersRolloverTypedDict]]
    r"""Rollover balances carried over from previous periods."""


class ListCustomersBalances(BaseModel):
    feature_id: str
    r"""The feature ID this balance is for."""

    granted: float
    r"""Total balance granted (included + prepaid)."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Total usage consumed in the current period."""

    unlimited: bool
    r"""Whether this feature has unlimited usage."""

    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""

    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""

    feature: Optional[ListCustomersFeature] = None
    r"""The full feature object if expanded."""

    breakdown: Optional[List[ListCustomersBreakdown]] = None
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""

    rollovers: Optional[List[ListCustomersRollover]] = None
    r"""Rollover balances carried over from previous periods."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListCustomersListTypedDict(TypedDict):
    id: Nullable[str]
    r"""Your unique identifier for the customer."""
    name: Nullable[str]
    r"""The name of the customer."""
    email: Nullable[str]
    r"""The email address of the customer."""
    created_at: float
    r"""Timestamp of customer creation in milliseconds since epoch."""
    fingerprint: Nullable[str]
    r"""A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID."""
    stripe_id: Nullable[str]
    r"""Stripe customer ID."""
    env: ListCustomersEnv
    r"""The environment this customer was created in."""
    metadata: Dict[str, Any]
    r"""The metadata for the customer."""
    send_email_receipts: bool
    r"""Whether to send email receipts to the customer."""
    subscriptions: List[ListCustomersSubscriptionTypedDict]
    r"""Active and scheduled recurring plans that this customer has attached."""
    purchases: List[ListCustomersPurchaseTypedDict]
    r"""One-time purchases made by the customer."""
    balances: Dict[str, ListCustomersBalancesTypedDict]
    r"""Feature balances keyed by feature ID, showing usage limits and remaining amounts."""


class ListCustomersList(BaseModel):
    id: Nullable[str]
    r"""Your unique identifier for the customer."""

    name: Nullable[str]
    r"""The name of the customer."""

    email: Nullable[str]
    r"""The email address of the customer."""

    created_at: float
    r"""Timestamp of customer creation in milliseconds since epoch."""

    fingerprint: Nullable[str]
    r"""A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID."""

    stripe_id: Nullable[str]
    r"""Stripe customer ID."""

    env: ListCustomersEnv
    r"""The environment this customer was created in."""

    metadata: Dict[str, Any]
    r"""The metadata for the customer."""

    send_email_receipts: bool
    r"""Whether to send email receipts to the customer."""

    subscriptions: List[ListCustomersSubscription]
    r"""Active and scheduled recurring plans that this customer has attached."""

    purchases: List[ListCustomersPurchase]
    r"""One-time purchases made by the customer."""

    balances: Dict[str, ListCustomersBalances]
    r"""Feature balances keyed by feature ID, showing usage limits and remaining amounts."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class ListCustomersResponseTypedDict(TypedDict):
    r"""OK"""

    list: List[ListCustomersListTypedDict]
    r"""Array of items for current page"""
    has_more: bool
    r"""Whether more results exist after this page"""
    offset: float
    r"""Current offset position"""
    limit: float
    r"""Limit passed in the request"""
    total: float
    r"""Total number of items returned in the current page"""


class ListCustomersResponse(BaseModel):
    r"""OK"""

    list: List[ListCustomersList]
    r"""Array of items for current page"""

    has_more: bool
    r"""Whether more results exist after this page"""

    offset: float
    r"""Current offset position"""

    limit: float
    r"""Limit passed in the request"""

    total: float
    r"""Total number of items returned in the current page"""
