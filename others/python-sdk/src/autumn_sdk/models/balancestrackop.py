"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata, validate_const
import pydantic
from pydantic import model_serializer
from pydantic.functional_validators import AfterValidator
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BalancesTrackGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BalancesTrackGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BalancesTrackRequestTypedDict(TypedDict):
    customer_id: str
    r"""ID which you provided when creating the customer"""
    feature_id: NotRequired[str]
    r"""ID of the feature to track usage for. Required if event_name is not provided. Use this for direct feature tracking."""
    event_name: NotRequired[str]
    r"""An [event name](/features/tracking-usage#using-event-names) can be used in place of feature_id. This can be used if multiple features are tracked in the same event."""
    value: NotRequired[float]
    r"""The amount of usage to record. Defaults to 1. Can be negative to increase the balance (e.g., when removing a seat)."""
    properties: NotRequired[Dict[str, Any]]
    r"""Additional properties to attach to this usage event."""
    idempotency_key: NotRequired[str]
    r"""Unique key to prevent duplicate event recording. Use this to safely retry requests without creating duplicate usage records."""
    entity_id: NotRequired[str]
    r"""If using [entity balances](/features/feature-entities) (eg, seats), the entity ID to track usage for."""


class BalancesTrackRequest(BaseModel):
    customer_id: str
    r"""ID which you provided when creating the customer"""

    feature_id: Optional[str] = None
    r"""ID of the feature to track usage for. Required if event_name is not provided. Use this for direct feature tracking."""

    event_name: Optional[str] = None
    r"""An [event name](/features/tracking-usage#using-event-names) can be used in place of feature_id. This can be used if multiple features are tracked in the same event."""

    value: Optional[float] = None
    r"""The amount of usage to record. Defaults to 1. Can be negative to increase the balance (e.g., when removing a seat)."""

    properties: Optional[Dict[str, Any]] = None
    r"""Additional properties to attach to this usage event."""

    idempotency_key: Optional[str] = None
    r"""Unique key to prevent duplicate event recording. Use this to safely retry requests without creating duplicate usage records."""

    entity_id: Optional[str] = None
    r"""If using [entity balances](/features/feature-entities) (eg, seats), the entity ID to track usage for."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "feature_id",
                "event_name",
                "value",
                "properties",
                "idempotency_key",
                "entity_id",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BalancesTrackBalanceType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class BalancesTrackBalanceCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class BalancesTrackBalanceCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class BalancesTrackBalanceDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class BalancesTrackBalanceDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackBalanceFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: BalancesTrackBalanceType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[BalancesTrackBalanceCreditSchemaTypedDict]]
    display: NotRequired[BalancesTrackBalanceDisplayTypedDict]


class BalancesTrackBalanceFeature(BaseModel):
    id: str

    name: str

    type: BalancesTrackBalanceType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[BalancesTrackBalanceCreditSchema]] = None

    display: Optional[BalancesTrackBalanceDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BalancesTrackBalanceIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


BalancesTrackBalanceIntervalUnionTypedDict = TypeAliasType(
    "BalancesTrackBalanceIntervalUnionTypedDict",
    Union[BalancesTrackBalanceIntervalEnum, str],
)


BalancesTrackBalanceIntervalUnion = TypeAliasType(
    "BalancesTrackBalanceIntervalUnion", Union[BalancesTrackBalanceIntervalEnum, str]
)


class BalancesTrackBalanceResetTypedDict(TypedDict):
    interval: BalancesTrackBalanceIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class BalancesTrackBalanceReset(BaseModel):
    interval: BalancesTrackBalanceIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesTrackBalanceToTypedDict = TypeAliasType(
    "BalancesTrackBalanceToTypedDict", Union[float, str]
)


BalancesTrackBalanceTo = TypeAliasType("BalancesTrackBalanceTo", Union[float, str])


class BalancesTrackBalanceTierTypedDict(TypedDict):
    to: BalancesTrackBalanceToTypedDict
    amount: float


class BalancesTrackBalanceTier(BaseModel):
    to: BalancesTrackBalanceTo

    amount: float


BalancesTrackBalanceBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class BalancesTrackBalancePriceTypedDict(TypedDict):
    billing_units: float
    billing_method: BalancesTrackBalanceBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[BalancesTrackBalanceTierTypedDict]]


class BalancesTrackBalancePrice(BaseModel):
    billing_units: float

    billing_method: BalancesTrackBalanceBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[BalancesTrackBalanceTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackBalanceBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[BalancesTrackBalanceResetTypedDict]
    price: Nullable[BalancesTrackBalancePriceTypedDict]
    expires_at: Nullable[float]
    object: Literal["balance_breakdown"]
    id: NotRequired[str]


class BalancesTrackBalanceBreakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[BalancesTrackBalanceReset]

    price: Nullable[BalancesTrackBalancePrice]

    expires_at: Nullable[float]

    object: Annotated[
        Annotated[
            Literal["balance_breakdown"],
            AfterValidator(validate_const("balance_breakdown")),
        ],
        pydantic.Field(alias="object"),
    ] = "balance_breakdown"

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackBalanceRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class BalancesTrackBalanceRollover(BaseModel):
    balance: float

    expires_at: float


class BalancesTrackBalanceTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    object: Literal["balance"]
    feature: NotRequired[BalancesTrackBalanceFeatureTypedDict]
    breakdown: NotRequired[List[BalancesTrackBalanceBreakdownTypedDict]]
    rollovers: NotRequired[List[BalancesTrackBalanceRolloverTypedDict]]


class BalancesTrackBalance(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    object: Annotated[
        Annotated[Literal["balance"], AfterValidator(validate_const("balance"))],
        pydantic.Field(alias="object"),
    ] = "balance"

    feature: Optional[BalancesTrackBalanceFeature] = None

    breakdown: Optional[List[BalancesTrackBalanceBreakdown]] = None

    rollovers: Optional[List[BalancesTrackBalanceRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesTrackType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class BalancesTrackCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class BalancesTrackCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class BalancesTrackDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class BalancesTrackDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: BalancesTrackType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[BalancesTrackCreditSchemaTypedDict]]
    display: NotRequired[BalancesTrackDisplayTypedDict]


class BalancesTrackFeature(BaseModel):
    id: str

    name: str

    type: BalancesTrackType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[BalancesTrackCreditSchema]] = None

    display: Optional[BalancesTrackDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BalancesTrackIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


BalancesTrackIntervalUnionTypedDict = TypeAliasType(
    "BalancesTrackIntervalUnionTypedDict", Union[BalancesTrackIntervalEnum, str]
)


BalancesTrackIntervalUnion = TypeAliasType(
    "BalancesTrackIntervalUnion", Union[BalancesTrackIntervalEnum, str]
)


class BalancesTrackResetTypedDict(TypedDict):
    interval: BalancesTrackIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class BalancesTrackReset(BaseModel):
    interval: BalancesTrackIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesTrackToTypedDict = TypeAliasType("BalancesTrackToTypedDict", Union[float, str])


BalancesTrackTo = TypeAliasType("BalancesTrackTo", Union[float, str])


class BalancesTrackTierTypedDict(TypedDict):
    to: BalancesTrackToTypedDict
    amount: float


class BalancesTrackTier(BaseModel):
    to: BalancesTrackTo

    amount: float


BalancesTrackBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class BalancesTrackPriceTypedDict(TypedDict):
    billing_units: float
    billing_method: BalancesTrackBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[BalancesTrackTierTypedDict]]


class BalancesTrackPrice(BaseModel):
    billing_units: float

    billing_method: BalancesTrackBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[BalancesTrackTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[BalancesTrackResetTypedDict]
    price: Nullable[BalancesTrackPriceTypedDict]
    expires_at: Nullable[float]
    object: Literal["balance_breakdown"]
    id: NotRequired[str]


class BalancesTrackBreakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[BalancesTrackReset]

    price: Nullable[BalancesTrackPrice]

    expires_at: Nullable[float]

    object: Annotated[
        Annotated[
            Literal["balance_breakdown"],
            AfterValidator(validate_const("balance_breakdown")),
        ],
        pydantic.Field(alias="object"),
    ] = "balance_breakdown"

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class BalancesTrackRollover(BaseModel):
    balance: float

    expires_at: float


class BalancesTrackBalancesTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    object: Literal["balance"]
    feature: NotRequired[BalancesTrackFeatureTypedDict]
    breakdown: NotRequired[List[BalancesTrackBreakdownTypedDict]]
    rollovers: NotRequired[List[BalancesTrackRolloverTypedDict]]


class BalancesTrackBalances(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    object: Annotated[
        Annotated[Literal["balance"], AfterValidator(validate_const("balance"))],
        pydantic.Field(alias="object"),
    ] = "balance"

    feature: Optional[BalancesTrackFeature] = None

    breakdown: Optional[List[BalancesTrackBreakdown]] = None

    rollovers: Optional[List[BalancesTrackRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesTrackResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer"""
    value: float
    balance: Nullable[BalancesTrackBalanceTypedDict]
    entity_id: NotRequired[str]
    r"""The ID of the entity (if provided)"""
    event_name: NotRequired[str]
    r"""The name of the event"""
    balances: NotRequired[Dict[str, BalancesTrackBalancesTypedDict]]


class BalancesTrackResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer"""

    value: float

    balance: Nullable[BalancesTrackBalance]

    entity_id: Optional[str] = None
    r"""The ID of the entity (if provided)"""

    event_name: Optional[str] = None
    r"""The name of the event"""

    balances: Optional[Dict[str, BalancesTrackBalances]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "event_name", "balances"])
        nullable_fields = set(["balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    BalancesTrackBalanceBreakdown.model_rebuild()
except NameError:
    pass
try:
    BalancesTrackBalance.model_rebuild()
except NameError:
    pass
try:
    BalancesTrackBreakdown.model_rebuild()
except NameError:
    pass
try:
    BalancesTrackBalances.model_rebuild()
except NameError:
    pass
