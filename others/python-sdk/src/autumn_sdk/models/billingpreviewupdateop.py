"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingPreviewUpdateGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingPreviewUpdateGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateFeatureQuantitiesTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingPreviewUpdateFeatureQuantities(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdateDurationType = Literal[
    "day",
    "month",
    "year",
]


class BillingPreviewUpdateFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[BillingPreviewUpdateDurationType]
    card_required: NotRequired[bool]


class BillingPreviewUpdateFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[BillingPreviewUpdateDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdatePriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingPreviewUpdatePriceTypedDict(TypedDict):
    amount: float
    interval: BillingPreviewUpdatePriceInterval
    interval_count: NotRequired[float]


class BillingPreviewUpdatePrice(BaseModel):
    amount: float

    interval: BillingPreviewUpdatePriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdateResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingPreviewUpdateResetTypedDict(TypedDict):
    interval: BillingPreviewUpdateResetInterval
    interval_count: NotRequired[float]


class BillingPreviewUpdateReset(BaseModel):
    interval: BillingPreviewUpdateResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdateToTypedDict = TypeAliasType(
    "BillingPreviewUpdateToTypedDict", Union[float, str]
)


BillingPreviewUpdateTo = TypeAliasType("BillingPreviewUpdateTo", Union[float, str])


class BillingPreviewUpdateTierTypedDict(TypedDict):
    to: BillingPreviewUpdateToTypedDict
    amount: float


class BillingPreviewUpdateTier(BaseModel):
    to: BillingPreviewUpdateTo

    amount: float


BillingPreviewUpdateItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


BillingPreviewUpdateBillingMethod = Literal[
    "prepaid",
    "usage_based",
]


class BillingPreviewUpdateItemPriceTypedDict(TypedDict):
    interval: BillingPreviewUpdateItemPriceInterval
    billing_method: BillingPreviewUpdateBillingMethod
    amount: NotRequired[float]
    tiers: NotRequired[List[BillingPreviewUpdateTierTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class BillingPreviewUpdateItemPrice(BaseModel):
    interval: BillingPreviewUpdateItemPriceInterval

    billing_method: BillingPreviewUpdateBillingMethod

    amount: Optional[float] = None

    tiers: Optional[List[BillingPreviewUpdateTier]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdateOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


BillingPreviewUpdateOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class BillingPreviewUpdateProrationTypedDict(TypedDict):
    on_increase: BillingPreviewUpdateOnIncrease
    on_decrease: BillingPreviewUpdateOnDecrease


class BillingPreviewUpdateProration(BaseModel):
    on_increase: BillingPreviewUpdateOnIncrease

    on_decrease: BillingPreviewUpdateOnDecrease


BillingPreviewUpdateExpiryDurationType = Literal[
    "month",
    "forever",
]


class BillingPreviewUpdateRolloverTypedDict(TypedDict):
    expiry_duration_type: BillingPreviewUpdateExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class BillingPreviewUpdateRollover(BaseModel):
    expiry_duration_type: BillingPreviewUpdateExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[BillingPreviewUpdateResetTypedDict]
    price: NotRequired[BillingPreviewUpdateItemPriceTypedDict]
    proration: NotRequired[BillingPreviewUpdateProrationTypedDict]
    rollover: NotRequired[BillingPreviewUpdateRolloverTypedDict]


class BillingPreviewUpdateItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[BillingPreviewUpdateReset] = None

    price: Optional[BillingPreviewUpdateItemPrice] = None

    proration: Optional[BillingPreviewUpdateProration] = None

    rollover: Optional[BillingPreviewUpdateRollover] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: NotRequired[Nullable[BillingPreviewUpdatePriceTypedDict]]
    items: NotRequired[List[BillingPreviewUpdateItemTypedDict]]


class BillingPreviewUpdateCustomize(BaseModel):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: OptionalNullable[BillingPreviewUpdatePrice] = UNSET

    items: Optional[List[BillingPreviewUpdateItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingPreviewUpdateInvoiceModeTypedDict(TypedDict):
    enabled: bool
    enable_plan_immediately: NotRequired[bool]
    finalize: NotRequired[bool]


class BillingPreviewUpdateInvoiceMode(BaseModel):
    enabled: bool

    enable_plan_immediately: Optional[bool] = False

    finalize: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewUpdateCancelAction = Literal[
    "cancel_immediately",
    "cancel_end_of_cycle",
    "uncancel",
]


BillingPreviewUpdateBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]


class BillingPreviewUpdateRequestTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[
        Nullable[List[BillingPreviewUpdateFeatureQuantitiesTypedDict]]
    ]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    free_trial: NotRequired[Nullable[BillingPreviewUpdateFreeTrialTypedDict]]
    customize: NotRequired[BillingPreviewUpdateCustomizeTypedDict]
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""
    plan_id: NotRequired[str]
    invoice_mode: NotRequired[BillingPreviewUpdateInvoiceModeTypedDict]
    cancel_action: NotRequired[BillingPreviewUpdateCancelAction]
    billing_behavior: NotRequired[BillingPreviewUpdateBillingBehavior]


class BillingPreviewUpdateRequest(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: OptionalNullable[
        List[BillingPreviewUpdateFeatureQuantities]
    ] = UNSET
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    free_trial: OptionalNullable[BillingPreviewUpdateFreeTrial] = UNSET

    customize: Optional[BillingPreviewUpdateCustomize] = None
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    plan_id: Optional[str] = None

    invoice_mode: Optional[BillingPreviewUpdateInvoiceMode] = None

    cancel_action: Optional[BillingPreviewUpdateCancelAction] = None

    billing_behavior: Optional[BillingPreviewUpdateBillingBehavior] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "plan_id",
                "invoice_mode",
                "cancel_action",
                "billing_behavior",
            ]
        )
        nullable_fields = set(["entity_id", "feature_quantities", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingPreviewUpdateDiscountTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class BillingPreviewUpdateDiscount(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateEffectivePeriodTypedDict(TypedDict):
    start: float
    end: float


class BillingPreviewUpdateEffectivePeriod(BaseModel):
    start: float

    end: float


class BillingPreviewUpdateLineItemTypedDict(TypedDict):
    title: str
    description: str
    amount: float
    plan_id: str
    total_quantity: float
    paid_quantity: float
    discounts: NotRequired[List[BillingPreviewUpdateDiscountTypedDict]]
    deferred_for_trial: NotRequired[bool]
    effective_period: NotRequired[BillingPreviewUpdateEffectivePeriodTypedDict]
    is_base: NotRequired[bool]


class BillingPreviewUpdateLineItem(BaseModel):
    title: str

    description: str

    amount: float

    plan_id: str

    total_quantity: float

    paid_quantity: float

    discounts: Optional[List[BillingPreviewUpdateDiscount]] = None

    deferred_for_trial: Optional[bool] = None

    effective_period: Optional[BillingPreviewUpdateEffectivePeriod] = None

    is_base: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discounts", "deferred_for_trial", "effective_period", "is_base"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateNextCycleDiscountTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class BillingPreviewUpdateNextCycleDiscount(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateNextCycleEffectivePeriodTypedDict(TypedDict):
    start: float
    end: float


class BillingPreviewUpdateNextCycleEffectivePeriod(BaseModel):
    start: float

    end: float


class BillingPreviewUpdateNextCycleLineItemTypedDict(TypedDict):
    title: str
    description: str
    amount: float
    plan_id: str
    total_quantity: float
    paid_quantity: float
    discounts: NotRequired[List[BillingPreviewUpdateNextCycleDiscountTypedDict]]
    deferred_for_trial: NotRequired[bool]
    effective_period: NotRequired[BillingPreviewUpdateNextCycleEffectivePeriodTypedDict]
    is_base: NotRequired[bool]


class BillingPreviewUpdateNextCycleLineItem(BaseModel):
    title: str

    description: str

    amount: float

    plan_id: str

    total_quantity: float

    paid_quantity: float

    discounts: Optional[List[BillingPreviewUpdateNextCycleDiscount]] = None

    deferred_for_trial: Optional[bool] = None

    effective_period: Optional[BillingPreviewUpdateNextCycleEffectivePeriod] = None

    is_base: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discounts", "deferred_for_trial", "effective_period", "is_base"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewUpdateNextCycleTypedDict(TypedDict):
    starts_at: float
    total: float
    line_items: List[BillingPreviewUpdateNextCycleLineItemTypedDict]


class BillingPreviewUpdateNextCycle(BaseModel):
    starts_at: float

    total: float

    line_items: List[BillingPreviewUpdateNextCycleLineItem]


class BillingPreviewUpdateResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    line_items: List[BillingPreviewUpdateLineItemTypedDict]
    total: float
    currency: str
    period_start: NotRequired[float]
    period_end: NotRequired[float]
    next_cycle: NotRequired[BillingPreviewUpdateNextCycleTypedDict]


class BillingPreviewUpdateResponse(BaseModel):
    r"""OK"""

    customer_id: str

    line_items: List[BillingPreviewUpdateLineItem]

    total: float

    currency: str

    period_start: Optional[float] = None

    period_end: Optional[float] = None

    next_cycle: Optional[BillingPreviewUpdateNextCycle] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["period_start", "period_end", "next_cycle"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    BillingPreviewUpdateDiscount.model_rebuild()
except NameError:
    pass
try:
    BillingPreviewUpdateNextCycleDiscount.model_rebuild()
except NameError:
    pass
