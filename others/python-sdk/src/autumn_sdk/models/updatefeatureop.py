"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


class UpdateFeatureGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class UpdateFeatureGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateFeatureTypeRequest = Literal[
    "boolean",
    "metered",
    "credit_system",
]
r"""The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system."""


class UpdateFeatureDisplayRequestTypedDict(TypedDict):
    r"""Singular and plural display names for the feature in your user interface."""

    singular: str
    plural: str


class UpdateFeatureDisplayRequest(BaseModel):
    r"""Singular and plural display names for the feature in your user interface."""

    singular: str

    plural: str


class UpdateFeatureCreditSchemaRequestTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class UpdateFeatureCreditSchemaRequest(BaseModel):
    metered_feature_id: str

    credit_cost: float


class UpdateFeatureParamsTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature to update."""
    name: NotRequired[str]
    r"""The name of the feature."""
    type: NotRequired[UpdateFeatureTypeRequest]
    r"""The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system."""
    consumable: NotRequired[bool]
    r"""Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features."""
    display: NotRequired[UpdateFeatureDisplayRequestTypedDict]
    r"""Singular and plural display names for the feature in your user interface."""
    credit_schema: NotRequired[List[UpdateFeatureCreditSchemaRequestTypedDict]]
    r"""A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features."""
    event_names: NotRequired[List[str]]
    archived: NotRequired[bool]
    r"""Whether the feature is archived. Archived features are hidden from the dashboard."""
    new_feature_id: NotRequired[str]
    r"""The new ID of the feature. Feature ID can only be updated if it's not being used by any customers."""


class UpdateFeatureParams(BaseModel):
    feature_id: str
    r"""The ID of the feature to update."""

    name: Optional[str] = None
    r"""The name of the feature."""

    type: Optional[UpdateFeatureTypeRequest] = None
    r"""The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system."""

    consumable: Optional[bool] = None
    r"""Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features."""

    display: Optional[UpdateFeatureDisplayRequest] = None
    r"""Singular and plural display names for the feature in your user interface."""

    credit_schema: Optional[List[UpdateFeatureCreditSchemaRequest]] = None
    r"""A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features."""

    event_names: Optional[List[str]] = None

    archived: Optional[bool] = None
    r"""Whether the feature is archived. Archived features are hidden from the dashboard."""

    new_feature_id: Optional[str] = None
    r"""The new ID of the feature. Feature ID can only be updated if it's not being used by any customers."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "name",
                "type",
                "consumable",
                "display",
                "credit_schema",
                "event_names",
                "archived",
                "new_feature_id",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateFeatureTypeResponse = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]
r"""Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools."""


class UpdateFeatureCreditSchemaResponseTypedDict(TypedDict):
    metered_feature_id: str
    r"""ID of the metered feature that draws from this credit system."""
    credit_cost: float
    r"""Credits consumed per unit of the metered feature."""


class UpdateFeatureCreditSchemaResponse(BaseModel):
    metered_feature_id: str
    r"""ID of the metered feature that draws from this credit system."""

    credit_cost: float
    r"""Credits consumed per unit of the metered feature."""


class UpdateFeatureDisplayResponseTypedDict(TypedDict):
    r"""Display names for the feature in billing UI and customer-facing components."""

    singular: NotRequired[Nullable[str]]
    r"""Singular form for UI display (e.g., 'API call', 'seat')."""
    plural: NotRequired[Nullable[str]]
    r"""Plural form for UI display (e.g., 'API calls', 'seats')."""


class UpdateFeatureDisplayResponse(BaseModel):
    r"""Display names for the feature in billing UI and customer-facing components."""

    singular: OptionalNullable[str] = UNSET
    r"""Singular form for UI display (e.g., 'API call', 'seat')."""

    plural: OptionalNullable[str] = UNSET
    r"""Plural form for UI display (e.g., 'API calls', 'seats')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class UpdateFeatureResponseTypedDict(TypedDict):
    r"""OK"""

    id: str
    r"""The unique identifier for this feature, used in /check and /track calls."""
    name: str
    r"""Human-readable name displayed in the dashboard and billing UI."""
    type: UpdateFeatureTypeResponse
    r"""Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools."""
    consumable: bool
    r"""For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage)."""
    archived: bool
    r"""Whether the feature is archived and hidden from the dashboard."""
    event_names: NotRequired[List[str]]
    r"""Event names that trigger this feature's balance. Allows multiple features to respond to a single event."""
    credit_schema: NotRequired[List[UpdateFeatureCreditSchemaResponseTypedDict]]
    r"""For credit_system features: maps metered features to their credit costs."""
    display: NotRequired[UpdateFeatureDisplayResponseTypedDict]
    r"""Display names for the feature in billing UI and customer-facing components."""


class UpdateFeatureResponse(BaseModel):
    r"""OK"""

    id: str
    r"""The unique identifier for this feature, used in /check and /track calls."""

    name: str
    r"""Human-readable name displayed in the dashboard and billing UI."""

    type: UpdateFeatureTypeResponse
    r"""Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools."""

    consumable: bool
    r"""For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage)."""

    archived: bool
    r"""Whether the feature is archived and hidden from the dashboard."""

    event_names: Optional[List[str]] = None
    r"""Event names that trigger this feature's balance. Allows multiple features to respond to a single event."""

    credit_schema: Optional[List[UpdateFeatureCreditSchemaResponse]] = None
    r"""For credit_system features: maps metered features to their credit costs."""

    display: Optional[UpdateFeatureDisplayResponse] = None
    r"""Display names for the feature in billing UI and customer-facing components."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
