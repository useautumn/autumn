"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .customerdata import CustomerData, CustomerDataTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class PreviewMultiAttachGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class PreviewMultiAttachGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval (e.g. 'month', 'year')."""


class PreviewMultiAttachBasePriceTypedDict(TypedDict):
    r"""Base price configuration for a plan."""

    amount: float
    r"""Base price amount for the plan."""
    interval: PreviewMultiAttachPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class PreviewMultiAttachBasePrice(BaseModel):
    r"""Base price configuration for a plan."""

    amount: float
    r"""Base price amount for the plan."""

    interval: PreviewMultiAttachPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""


class PreviewMultiAttachResetTypedDict(TypedDict):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: PreviewMultiAttachResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class PreviewMultiAttachReset(BaseModel):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: PreviewMultiAttachResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachToTypedDict = TypeAliasType(
    "PreviewMultiAttachToTypedDict", Union[float, str]
)


PreviewMultiAttachTo = TypeAliasType("PreviewMultiAttachTo", Union[float, str])


class PreviewMultiAttachTierTypedDict(TypedDict):
    to: PreviewMultiAttachToTypedDict
    amount: float
    flat_amount: NotRequired[Nullable[float]]


class PreviewMultiAttachTier(BaseModel):
    to: PreviewMultiAttachTo

    amount: float

    flat_amount: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["flat_amount"])
        nullable_fields = set(["flat_amount"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


PreviewMultiAttachTierBehavior = Literal[
    "graduated",
    "volume",
]


PreviewMultiAttachItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval. For consumable features, should match reset.interval."""


PreviewMultiAttachBillingMethod = Literal[
    "prepaid",
    "usage_based",
]
r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""


class PreviewMultiAttachPriceTypedDict(TypedDict):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: PreviewMultiAttachItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""
    billing_method: PreviewMultiAttachBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""
    tiers: NotRequired[List[PreviewMultiAttachTierTypedDict]]
    r"""Tiered pricing.  Either 'amount' or 'tiers' is required."""
    tier_behavior: NotRequired[PreviewMultiAttachTierBehavior]
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    billing_units: NotRequired[float]
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""
    max_purchase: NotRequired[float]
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""


class PreviewMultiAttachPrice(BaseModel):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: PreviewMultiAttachItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""

    billing_method: PreviewMultiAttachBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""

    tiers: Optional[List[PreviewMultiAttachTier]] = None
    r"""Tiered pricing.  Either 'amount' or 'tiers' is required."""

    tier_behavior: Optional[PreviewMultiAttachTierBehavior] = None

    interval_count: Optional[float] = 1
    r"""Number of intervals per billing cycle. Defaults to 1."""

    billing_units: Optional[float] = 1
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""

    max_purchase: Optional[float] = None
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "amount",
                "tiers",
                "tier_behavior",
                "interval_count",
                "billing_units",
                "max_purchase",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]
r"""Billing behavior when quantity increases mid-cycle."""


PreviewMultiAttachOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]
r"""Credit behavior when quantity decreases mid-cycle."""


class PreviewMultiAttachProrationTypedDict(TypedDict):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: PreviewMultiAttachOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""
    on_decrease: PreviewMultiAttachOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


class PreviewMultiAttachProration(BaseModel):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: PreviewMultiAttachOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""

    on_decrease: PreviewMultiAttachOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


PreviewMultiAttachExpiryDurationType = Literal[
    "month",
    "forever",
]
r"""When rolled over units expire."""


class PreviewMultiAttachRolloverTypedDict(TypedDict):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: PreviewMultiAttachExpiryDurationType
    r"""When rolled over units expire."""
    max: NotRequired[float]
    r"""Max rollover units. Omit for unlimited rollover."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class PreviewMultiAttachRollover(BaseModel):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: PreviewMultiAttachExpiryDurationType
    r"""When rolled over units expire."""

    max: Optional[float] = None
    r"""Max rollover units. Omit for unlimited rollover."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachPlanItemTypedDict(TypedDict):
    r"""Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings."""

    feature_id: str
    r"""The ID of the feature to configure."""
    included: NotRequired[float]
    r"""Number of free units included. Balance resets to this each interval for consumable features."""
    unlimited: NotRequired[bool]
    r"""If true, customer has unlimited access to this feature."""
    reset: NotRequired[PreviewMultiAttachResetTypedDict]
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""
    price: NotRequired[PreviewMultiAttachPriceTypedDict]
    r"""Pricing for usage beyond included units. Omit for free features."""
    proration: NotRequired[PreviewMultiAttachProrationTypedDict]
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""
    rollover: NotRequired[PreviewMultiAttachRolloverTypedDict]
    r"""Rollover config for unused units. If set, unused included units carry over."""


class PreviewMultiAttachPlanItem(BaseModel):
    r"""Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings."""

    feature_id: str
    r"""The ID of the feature to configure."""

    included: Optional[float] = None
    r"""Number of free units included. Balance resets to this each interval for consumable features."""

    unlimited: Optional[bool] = None
    r"""If true, customer has unlimited access to this feature."""

    reset: Optional[PreviewMultiAttachReset] = None
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    price: Optional[PreviewMultiAttachPrice] = None
    r"""Pricing for usage beyond included units. Omit for free features."""

    proration: Optional[PreviewMultiAttachProration] = None
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    rollover: Optional[PreviewMultiAttachRollover] = None
    r"""Rollover config for unused units. If set, unused included units carry over."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can override the price or items."""

    price: NotRequired[Nullable[PreviewMultiAttachBasePriceTypedDict]]
    r"""Override the base price of the plan. Pass null to remove the base price."""
    items: NotRequired[List[PreviewMultiAttachPlanItemTypedDict]]
    r"""Override the items in the plan."""


class PreviewMultiAttachCustomize(BaseModel):
    r"""Customize the plan to attach. Can override the price or items."""

    price: OptionalNullable[PreviewMultiAttachBasePrice] = UNSET
    r"""Override the base price of the plan. Pass null to remove the base price."""

    items: Optional[List[PreviewMultiAttachPlanItem]] = None
    r"""Override the items in the plan."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewMultiAttachFeatureQuantityTypedDict(TypedDict):
    r"""Quantity configuration for a prepaid feature."""

    feature_id: str
    r"""The ID of the feature to set quantity for."""
    quantity: NotRequired[float]
    r"""The quantity of the feature."""
    adjustable: NotRequired[bool]
    r"""Whether the customer can adjust the quantity."""


class PreviewMultiAttachFeatureQuantity(BaseModel):
    r"""Quantity configuration for a prepaid feature."""

    feature_id: str
    r"""The ID of the feature to set quantity for."""

    quantity: Optional[float] = None
    r"""The quantity of the feature."""

    adjustable: Optional[bool] = None
    r"""Whether the customer can adjust the quantity."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachPlanTypedDict(TypedDict):
    plan_id: str
    r"""The ID of the plan to attach."""
    customize: NotRequired[PreviewMultiAttachCustomizeTypedDict]
    r"""Customize the plan to attach. Can override the price or items."""
    feature_quantities: NotRequired[List[PreviewMultiAttachFeatureQuantityTypedDict]]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""


class PreviewMultiAttachPlan(BaseModel):
    plan_id: str
    r"""The ID of the plan to attach."""

    customize: Optional[PreviewMultiAttachCustomize] = None
    r"""Customize the plan to attach. Can override the price or items."""

    feature_quantities: Optional[List[PreviewMultiAttachFeatureQuantity]] = None
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["customize", "feature_quantities", "version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachDurationType = Literal[
    "day",
    "month",
    "year",
]
r"""Unit of time for the trial ('day', 'month', 'year')."""


class PreviewMultiAttachFreeTrialParamsTypedDict(TypedDict):
    r"""Free trial configuration for a plan."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: NotRequired[PreviewMultiAttachDurationType]
    r"""Unit of time for the trial ('day', 'month', 'year')."""
    card_required: NotRequired[bool]
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""


class PreviewMultiAttachFreeTrialParams(BaseModel):
    r"""Free trial configuration for a plan."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: Optional[PreviewMultiAttachDurationType] = "month"
    r"""Unit of time for the trial ('day', 'month', 'year')."""

    card_required: Optional[bool] = True
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachInvoiceModeTypedDict(TypedDict):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""
    enable_plan_immediately: NotRequired[bool]
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""
    finalize: NotRequired[bool]
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""


class PreviewMultiAttachInvoiceMode(BaseModel):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""

    enable_plan_immediately: Optional[bool] = False
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""

    finalize: Optional[bool] = True
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachAttachDiscountTypedDict(TypedDict):
    r"""A discount to apply. Can be either a reward ID or a promotion code."""

    reward_id: NotRequired[str]
    r"""The ID of the reward to apply as a discount."""
    promotion_code: NotRequired[str]
    r"""The promotion code to apply as a discount."""


class PreviewMultiAttachAttachDiscount(BaseModel):
    r"""A discount to apply. Can be either a reward ID or a promotion code."""

    reward_id: Optional[str] = None
    r"""The ID of the reward to apply as a discount."""

    promotion_code: Optional[str] = None
    r"""The promotion code to apply as a discount."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["reward_id", "promotion_code"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewMultiAttachRedirectMode = Literal[
    "always",
    "if_required",
    "never",
]
r"""Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects."""


class PreviewMultiAttachEntityDataTypedDict(TypedDict):
    feature_id: str
    r"""The feature ID that this entity is associated with"""
    name: NotRequired[str]
    r"""Name of the entity"""


class PreviewMultiAttachEntityData(BaseModel):
    feature_id: str
    r"""The feature ID that this entity is associated with"""

    name: Optional[str] = None
    r"""Name of the entity"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plans to."""
    plans: List[PreviewMultiAttachPlanTypedDict]
    r"""The list of plans to attach to the customer."""
    entity_id: NotRequired[str]
    r"""The ID of the entity to attach the plans to."""
    free_trial: NotRequired[Nullable[PreviewMultiAttachFreeTrialParamsTypedDict]]
    r"""Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial."""
    invoice_mode: NotRequired[PreviewMultiAttachInvoiceModeTypedDict]
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately."""
    discounts: NotRequired[List[PreviewMultiAttachAttachDiscountTypedDict]]
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""
    success_url: NotRequired[str]
    r"""URL to redirect to after successful checkout."""
    checkout_session_params: NotRequired[Dict[str, Any]]
    r"""Additional parameters to pass into the creation of the Stripe checkout session."""
    redirect_mode: NotRequired[PreviewMultiAttachRedirectMode]
    r"""Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects."""
    new_billing_subscription: NotRequired[bool]
    r"""Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one."""
    customer_data: NotRequired[CustomerDataTypedDict]
    r"""Customer details to set when creating a customer"""
    entity_data: NotRequired[PreviewMultiAttachEntityDataTypedDict]


class PreviewMultiAttachParams(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plans to."""

    plans: List[PreviewMultiAttachPlan]
    r"""The list of plans to attach to the customer."""

    entity_id: Optional[str] = None
    r"""The ID of the entity to attach the plans to."""

    free_trial: OptionalNullable[PreviewMultiAttachFreeTrialParams] = UNSET
    r"""Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial."""

    invoice_mode: Optional[PreviewMultiAttachInvoiceMode] = None
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately."""

    discounts: Optional[List[PreviewMultiAttachAttachDiscount]] = None
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""

    success_url: Optional[str] = None
    r"""URL to redirect to after successful checkout."""

    checkout_session_params: Optional[Dict[str, Any]] = None
    r"""Additional parameters to pass into the creation of the Stripe checkout session."""

    redirect_mode: Optional[PreviewMultiAttachRedirectMode] = "if_required"
    r"""Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects."""

    new_billing_subscription: Optional[bool] = None
    r"""Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one."""

    customer_data: Optional[CustomerData] = None
    r"""Customer details to set when creating a customer"""

    entity_data: Optional[PreviewMultiAttachEntityData] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "free_trial",
                "invoice_mode",
                "discounts",
                "success_url",
                "checkout_session_params",
                "redirect_mode",
                "new_billing_subscription",
                "customer_data",
                "entity_data",
            ]
        )
        nullable_fields = set(["free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewMultiAttachDiscountTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class PreviewMultiAttachDiscount(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachLineItemTypedDict(TypedDict):
    title: str
    r"""The title of the line item."""
    description: str
    r"""A detailed description of the line item."""
    amount: float
    r"""The amount in cents for this line item."""
    discounts: NotRequired[List[PreviewMultiAttachDiscountTypedDict]]
    r"""List of discounts applied to this line item."""


class PreviewMultiAttachLineItem(BaseModel):
    title: str
    r"""The title of the line item."""

    description: str
    r"""A detailed description of the line item."""

    amount: float
    r"""The amount in cents for this line item."""

    discounts: Optional[List[PreviewMultiAttachDiscount]] = None
    r"""List of discounts applied to this line item."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discounts"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewMultiAttachNextCycleTypedDict(TypedDict):
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    starts_at: float
    r"""Unix timestamp (milliseconds) when the next billing cycle starts."""
    total: float
    r"""The total amount in cents for the next cycle."""


class PreviewMultiAttachNextCycle(BaseModel):
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    starts_at: float
    r"""Unix timestamp (milliseconds) when the next billing cycle starts."""

    total: float
    r"""The total amount in cents for the next cycle."""


class PreviewMultiAttachResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""
    line_items: List[PreviewMultiAttachLineItemTypedDict]
    r"""List of line items for the current billing period."""
    total: float
    r"""The total amount in cents for the current billing period."""
    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""
    next_cycle: NotRequired[PreviewMultiAttachNextCycleTypedDict]
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""


class PreviewMultiAttachResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""

    line_items: List[PreviewMultiAttachLineItem]
    r"""List of line items for the current billing period."""

    total: float
    r"""The total amount in cents for the current billing period."""

    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""

    next_cycle: Optional[PreviewMultiAttachNextCycle] = None
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["next_cycle"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    PreviewMultiAttachDiscount.model_rebuild()
except NameError:
    pass
