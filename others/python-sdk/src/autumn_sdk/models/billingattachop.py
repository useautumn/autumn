"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingAttachGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingAttachGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachFeatureQuantityTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingAttachFeatureQuantity(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachDurationType = Literal[
    "day",
    "month",
    "year",
]


class BillingAttachFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[BillingAttachDurationType]
    card_required: NotRequired[bool]


class BillingAttachFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[BillingAttachDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingAttachPriceTypedDict(TypedDict):
    amount: float
    interval: BillingAttachPriceInterval
    interval_count: NotRequired[float]


class BillingAttachPrice(BaseModel):
    amount: float

    interval: BillingAttachPriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingAttachResetTypedDict(TypedDict):
    interval: BillingAttachResetInterval
    interval_count: NotRequired[float]


class BillingAttachReset(BaseModel):
    interval: BillingAttachResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachToTypedDict = TypeAliasType("BillingAttachToTypedDict", Union[float, str])


BillingAttachTo = TypeAliasType("BillingAttachTo", Union[float, str])


class BillingAttachTierTypedDict(TypedDict):
    to: BillingAttachToTypedDict
    amount: float


class BillingAttachTier(BaseModel):
    to: BillingAttachTo

    amount: float


BillingAttachItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


BillingAttachBillingMethod = Literal[
    "prepaid",
    "usage_based",
]


class BillingAttachItemPriceTypedDict(TypedDict):
    interval: BillingAttachItemPriceInterval
    billing_method: BillingAttachBillingMethod
    amount: NotRequired[float]
    tiers: NotRequired[List[BillingAttachTierTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class BillingAttachItemPrice(BaseModel):
    interval: BillingAttachItemPriceInterval

    billing_method: BillingAttachBillingMethod

    amount: Optional[float] = None

    tiers: Optional[List[BillingAttachTier]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


BillingAttachOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class BillingAttachProrationTypedDict(TypedDict):
    on_increase: BillingAttachOnIncrease
    on_decrease: BillingAttachOnDecrease


class BillingAttachProration(BaseModel):
    on_increase: BillingAttachOnIncrease

    on_decrease: BillingAttachOnDecrease


BillingAttachExpiryDurationType = Literal[
    "month",
    "forever",
]


class BillingAttachRolloverTypedDict(TypedDict):
    expiry_duration_type: BillingAttachExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class BillingAttachRollover(BaseModel):
    expiry_duration_type: BillingAttachExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[BillingAttachResetTypedDict]
    price: NotRequired[BillingAttachItemPriceTypedDict]
    proration: NotRequired[BillingAttachProrationTypedDict]
    rollover: NotRequired[BillingAttachRolloverTypedDict]


class BillingAttachItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[BillingAttachReset] = None

    price: Optional[BillingAttachItemPrice] = None

    proration: Optional[BillingAttachProration] = None

    rollover: Optional[BillingAttachRollover] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: NotRequired[Nullable[BillingAttachPriceTypedDict]]
    items: NotRequired[List[BillingAttachItemTypedDict]]


class BillingAttachCustomize(BaseModel):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: OptionalNullable[BillingAttachPrice] = UNSET

    items: Optional[List[BillingAttachItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingAttachInvoiceModeTypedDict(TypedDict):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""
    enable_plan_immediately: NotRequired[bool]
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""
    finalize: NotRequired[bool]
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""


class BillingAttachInvoiceMode(BaseModel):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""

    enable_plan_immediately: Optional[bool] = False
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""

    finalize: Optional[bool] = True
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]
r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""


class BillingAttachDiscount2TypedDict(TypedDict):
    promotion_code: str
    r"""The promotion code to apply as a discount."""


class BillingAttachDiscount2(BaseModel):
    promotion_code: str
    r"""The promotion code to apply as a discount."""


class BillingAttachDiscount1TypedDict(TypedDict):
    reward_id: str
    r"""The ID of the reward to apply as a discount."""


class BillingAttachDiscount1(BaseModel):
    reward_id: str
    r"""The ID of the reward to apply as a discount."""


BillingAttachDiscountUnionTypedDict = TypeAliasType(
    "BillingAttachDiscountUnionTypedDict",
    Union[BillingAttachDiscount1TypedDict, BillingAttachDiscount2TypedDict],
)
r"""A discount to apply. Can be either a reward ID or a promotion code."""


BillingAttachDiscountUnion = TypeAliasType(
    "BillingAttachDiscountUnion", Union[BillingAttachDiscount1, BillingAttachDiscount2]
)
r"""A discount to apply. Can be either a reward ID or a promotion code."""


BillingAttachPlanSchedule = Literal[
    "immediate",
    "end_of_cycle",
]
r"""When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled."""


class AttachParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    plan_id: str
    r"""The ID of the plan."""
    entity_id: NotRequired[str]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[List[BillingAttachFeatureQuantityTypedDict]]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    free_trial: NotRequired[Nullable[BillingAttachFreeTrialTypedDict]]
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""
    customize: NotRequired[BillingAttachCustomizeTypedDict]
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""
    invoice_mode: NotRequired[BillingAttachInvoiceModeTypedDict]
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""
    billing_behavior: NotRequired[BillingAttachBillingBehavior]
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""
    discounts: NotRequired[List[BillingAttachDiscountUnionTypedDict]]
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""
    success_url: NotRequired[str]
    r"""URL to redirect to after successful checkout."""
    new_billing_subscription: NotRequired[bool]
    r"""Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one."""
    plan_schedule: NotRequired[BillingAttachPlanSchedule]
    r"""When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled."""


class AttachParams(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    plan_id: str
    r"""The ID of the plan."""

    entity_id: Optional[str] = None
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: Optional[List[BillingAttachFeatureQuantity]] = None
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    free_trial: OptionalNullable[BillingAttachFreeTrial] = UNSET
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""

    customize: Optional[BillingAttachCustomize] = None
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    invoice_mode: Optional[BillingAttachInvoiceMode] = None
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    billing_behavior: Optional[BillingAttachBillingBehavior] = None
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""

    discounts: Optional[List[BillingAttachDiscountUnion]] = None
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""

    success_url: Optional[str] = None
    r"""URL to redirect to after successful checkout."""

    new_billing_subscription: Optional[bool] = None
    r"""Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one."""

    plan_schedule: Optional[BillingAttachPlanSchedule] = None
    r"""When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "invoice_mode",
                "billing_behavior",
                "discounts",
                "success_url",
                "new_billing_subscription",
                "plan_schedule",
            ]
        )
        nullable_fields = set(["free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingAttachInvoiceTypedDict(TypedDict):
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    status: Nullable[str]
    r"""The status of the invoice (e.g., 'paid', 'open', 'draft')."""
    stripe_id: str
    r"""The Stripe invoice ID."""
    total: float
    r"""The total amount of the invoice in cents."""
    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""
    hosted_invoice_url: Nullable[str]
    r"""URL to the hosted invoice page where the customer can view and pay the invoice."""


class BillingAttachInvoice(BaseModel):
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    status: Nullable[str]
    r"""The status of the invoice (e.g., 'paid', 'open', 'draft')."""

    stripe_id: str
    r"""The Stripe invoice ID."""

    total: float
    r"""The total amount of the invoice in cents."""

    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""

    hosted_invoice_url: Nullable[str]
    r"""URL to the hosted invoice page where the customer can view and pay the invoice."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


BillingAttachCode = Union[
    Literal[
        "3ds_required",
        "payment_method_required",
        "payment_failed",
    ],
    UnrecognizedStr,
]
r"""The type of action required to complete the payment."""


class BillingAttachRequiredActionTypedDict(TypedDict):
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    code: BillingAttachCode
    r"""The type of action required to complete the payment."""
    reason: str
    r"""A human-readable explanation of why this action is required."""


class BillingAttachRequiredAction(BaseModel):
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    code: BillingAttachCode
    r"""The type of action required to complete the payment."""

    reason: str
    r"""A human-readable explanation of why this action is required."""


class BillingAttachResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""
    payment_url: Nullable[str]
    r"""URL to redirect the customer to complete payment. Null if no payment action is required."""
    entity_id: NotRequired[str]
    r"""The ID of the entity, if the plan was attached to an entity."""
    invoice: NotRequired[BillingAttachInvoiceTypedDict]
    r"""Invoice details if an invoice was created. Only present when a charge was made."""
    required_action: NotRequired[BillingAttachRequiredActionTypedDict]
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""


class BillingAttachResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""

    payment_url: Nullable[str]
    r"""URL to redirect the customer to complete payment. Null if no payment action is required."""

    entity_id: Optional[str] = None
    r"""The ID of the entity, if the plan was attached to an entity."""

    invoice: Optional[BillingAttachInvoice] = None
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    required_action: Optional[BillingAttachRequiredAction] = None
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "invoice", "required_action"])
        nullable_fields = set(["payment_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
