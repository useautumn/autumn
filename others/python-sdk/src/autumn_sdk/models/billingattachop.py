"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingAttachGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingAttachGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachFeatureQuantitiesTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingAttachFeatureQuantities(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachDurationType = Literal[
    "day",
    "month",
    "year",
]


class BillingAttachFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[BillingAttachDurationType]
    card_required: NotRequired[bool]


class BillingAttachFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[BillingAttachDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingAttachPriceTypedDict(TypedDict):
    amount: float
    interval: BillingAttachPriceInterval
    interval_count: NotRequired[float]


class BillingAttachPrice(BaseModel):
    amount: float

    interval: BillingAttachPriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingAttachResetTypedDict(TypedDict):
    interval: BillingAttachResetInterval
    interval_count: NotRequired[float]


class BillingAttachReset(BaseModel):
    interval: BillingAttachResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachToTypedDict = TypeAliasType("BillingAttachToTypedDict", Union[float, str])


BillingAttachTo = TypeAliasType("BillingAttachTo", Union[float, str])


class BillingAttachTierTypedDict(TypedDict):
    to: BillingAttachToTypedDict
    amount: float


class BillingAttachTier(BaseModel):
    to: BillingAttachTo

    amount: float


BillingAttachItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


BillingAttachBillingMethod = Literal[
    "prepaid",
    "usage_based",
]


class BillingAttachItemPriceTypedDict(TypedDict):
    interval: BillingAttachItemPriceInterval
    billing_method: BillingAttachBillingMethod
    amount: NotRequired[float]
    tiers: NotRequired[List[BillingAttachTierTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class BillingAttachItemPrice(BaseModel):
    interval: BillingAttachItemPriceInterval

    billing_method: BillingAttachBillingMethod

    amount: Optional[float] = None

    tiers: Optional[List[BillingAttachTier]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingAttachOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


BillingAttachOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class BillingAttachProrationTypedDict(TypedDict):
    on_increase: BillingAttachOnIncrease
    on_decrease: BillingAttachOnDecrease


class BillingAttachProration(BaseModel):
    on_increase: BillingAttachOnIncrease

    on_decrease: BillingAttachOnDecrease


BillingAttachExpiryDurationType = Literal[
    "month",
    "forever",
]


class BillingAttachRolloverTypedDict(TypedDict):
    expiry_duration_type: BillingAttachExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class BillingAttachRollover(BaseModel):
    expiry_duration_type: BillingAttachExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[BillingAttachResetTypedDict]
    price: NotRequired[BillingAttachItemPriceTypedDict]
    proration: NotRequired[BillingAttachProrationTypedDict]
    rollover: NotRequired[BillingAttachRolloverTypedDict]


class BillingAttachItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[BillingAttachReset] = None

    price: Optional[BillingAttachItemPrice] = None

    proration: Optional[BillingAttachProration] = None

    rollover: Optional[BillingAttachRollover] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachCustomizeTypedDict(TypedDict):
    price: NotRequired[Nullable[BillingAttachPriceTypedDict]]
    items: NotRequired[List[BillingAttachItemTypedDict]]


class BillingAttachCustomize(BaseModel):
    price: OptionalNullable[BillingAttachPrice] = UNSET

    items: Optional[List[BillingAttachItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingAttachInvoiceModeTypedDict(TypedDict):
    enabled: bool
    enable_product_immediately: NotRequired[bool]
    finalize_invoice: NotRequired[bool]


class BillingAttachInvoiceMode(BaseModel):
    enabled: bool

    enable_product_immediately: Optional[bool] = False

    finalize_invoice: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_product_immediately", "finalize_invoice"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingAttachDiscount2TypedDict(TypedDict):
    promotion_code: str


class BillingAttachDiscount2(BaseModel):
    promotion_code: str


class BillingAttachDiscount1TypedDict(TypedDict):
    reward_id: str


class BillingAttachDiscount1(BaseModel):
    reward_id: str


BillingAttachDiscountUnionTypedDict = TypeAliasType(
    "BillingAttachDiscountUnionTypedDict",
    Union[BillingAttachDiscount1TypedDict, BillingAttachDiscount2TypedDict],
)


BillingAttachDiscountUnion = TypeAliasType(
    "BillingAttachDiscountUnion", Union[BillingAttachDiscount1, BillingAttachDiscount2]
)


BillingAttachRedirectMode = Literal[
    "always",
    "if_required",
    "never",
]


BillingAttachPlanSchedule = Literal[
    "immediate",
    "end_of_cycle",
]


BillingAttachBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]


class BillingAttachRequestTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    plan_id: str
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[
        Nullable[List[BillingAttachFeatureQuantitiesTypedDict]]
    ]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    free_trial: NotRequired[Nullable[BillingAttachFreeTrialTypedDict]]
    customize: NotRequired[BillingAttachCustomizeTypedDict]
    invoice_mode: NotRequired[BillingAttachInvoiceModeTypedDict]
    discounts: NotRequired[List[BillingAttachDiscountUnionTypedDict]]
    redirect_mode: NotRequired[BillingAttachRedirectMode]
    success_url: NotRequired[str]
    new_billing_subscription: NotRequired[bool]
    plan_schedule: NotRequired[BillingAttachPlanSchedule]
    billing_behavior: NotRequired[BillingAttachBillingBehavior]


class BillingAttachRequest(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    plan_id: str

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: OptionalNullable[List[BillingAttachFeatureQuantities]] = UNSET
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None

    free_trial: OptionalNullable[BillingAttachFreeTrial] = UNSET

    customize: Optional[BillingAttachCustomize] = None

    invoice_mode: Optional[BillingAttachInvoiceMode] = None

    discounts: Optional[List[BillingAttachDiscountUnion]] = None

    redirect_mode: Optional[BillingAttachRedirectMode] = "always"

    success_url: Optional[str] = None

    new_billing_subscription: Optional[bool] = None

    plan_schedule: Optional[BillingAttachPlanSchedule] = None

    billing_behavior: Optional[BillingAttachBillingBehavior] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "invoice_mode",
                "discounts",
                "redirect_mode",
                "success_url",
                "new_billing_subscription",
                "plan_schedule",
                "billing_behavior",
            ]
        )
        nullable_fields = set(["entity_id", "feature_quantities", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingAttachInvoiceTypedDict(TypedDict):
    status: Nullable[str]
    stripe_id: str
    total: float
    currency: str
    hosted_invoice_url: Nullable[str]


class BillingAttachInvoice(BaseModel):
    status: Nullable[str]

    stripe_id: str

    total: float

    currency: str

    hosted_invoice_url: Nullable[str]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


BillingAttachCode = Union[
    Literal[
        "3ds_required",
        "payment_method_required",
        "payment_failed",
    ],
    UnrecognizedStr,
]


class BillingAttachRequiredActionTypedDict(TypedDict):
    code: BillingAttachCode
    reason: str


class BillingAttachRequiredAction(BaseModel):
    code: BillingAttachCode

    reason: str


class BillingAttachResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    payment_url: Nullable[str]
    entity_id: NotRequired[str]
    invoice: NotRequired[BillingAttachInvoiceTypedDict]
    required_action: NotRequired[BillingAttachRequiredActionTypedDict]


class BillingAttachResponse(BaseModel):
    r"""OK"""

    customer_id: str

    payment_url: Nullable[str]

    entity_id: Optional[str] = None

    invoice: Optional[BillingAttachInvoice] = None

    required_action: Optional[BillingAttachRequiredAction] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "invoice", "required_action"])
        nullable_fields = set(["payment_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
