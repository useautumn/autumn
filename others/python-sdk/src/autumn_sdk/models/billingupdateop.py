"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingUpdateGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingUpdateGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateFeatureQuantitiesTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingUpdateFeatureQuantities(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateDurationType = Literal[
    "day",
    "month",
    "year",
]


class BillingUpdateFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[BillingUpdateDurationType]
    card_required: NotRequired[bool]


class BillingUpdateFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[BillingUpdateDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdatePriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingUpdatePriceTypedDict(TypedDict):
    amount: float
    interval: BillingUpdatePriceInterval
    interval_count: NotRequired[float]


class BillingUpdatePrice(BaseModel):
    amount: float

    interval: BillingUpdatePriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingUpdateResetTypedDict(TypedDict):
    interval: BillingUpdateResetInterval
    interval_count: NotRequired[float]


class BillingUpdateReset(BaseModel):
    interval: BillingUpdateResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateToTypedDict = TypeAliasType("BillingUpdateToTypedDict", Union[float, str])


BillingUpdateTo = TypeAliasType("BillingUpdateTo", Union[float, str])


class BillingUpdateTierTypedDict(TypedDict):
    to: BillingUpdateToTypedDict
    amount: float


class BillingUpdateTier(BaseModel):
    to: BillingUpdateTo

    amount: float


BillingUpdateItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


BillingUpdateBillingMethod = Literal[
    "prepaid",
    "usage_based",
]


class BillingUpdateItemPriceTypedDict(TypedDict):
    interval: BillingUpdateItemPriceInterval
    billing_method: BillingUpdateBillingMethod
    amount: NotRequired[float]
    tiers: NotRequired[List[BillingUpdateTierTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class BillingUpdateItemPrice(BaseModel):
    interval: BillingUpdateItemPriceInterval

    billing_method: BillingUpdateBillingMethod

    amount: Optional[float] = None

    tiers: Optional[List[BillingUpdateTier]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


BillingUpdateOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class BillingUpdateProrationTypedDict(TypedDict):
    on_increase: BillingUpdateOnIncrease
    on_decrease: BillingUpdateOnDecrease


class BillingUpdateProration(BaseModel):
    on_increase: BillingUpdateOnIncrease

    on_decrease: BillingUpdateOnDecrease


BillingUpdateExpiryDurationType = Literal[
    "month",
    "forever",
]


class BillingUpdateRolloverTypedDict(TypedDict):
    expiry_duration_type: BillingUpdateExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class BillingUpdateRollover(BaseModel):
    expiry_duration_type: BillingUpdateExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[BillingUpdateResetTypedDict]
    price: NotRequired[BillingUpdateItemPriceTypedDict]
    proration: NotRequired[BillingUpdateProrationTypedDict]
    rollover: NotRequired[BillingUpdateRolloverTypedDict]


class BillingUpdateItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[BillingUpdateReset] = None

    price: Optional[BillingUpdateItemPrice] = None

    proration: Optional[BillingUpdateProration] = None

    rollover: Optional[BillingUpdateRollover] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: NotRequired[Nullable[BillingUpdatePriceTypedDict]]
    items: NotRequired[List[BillingUpdateItemTypedDict]]


class BillingUpdateCustomize(BaseModel):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: OptionalNullable[BillingUpdatePrice] = UNSET

    items: Optional[List[BillingUpdateItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingUpdateInvoiceModeTypedDict(TypedDict):
    enabled: bool
    enable_plan_immediately: NotRequired[bool]
    finalize: NotRequired[bool]


class BillingUpdateInvoiceMode(BaseModel):
    enabled: bool

    enable_plan_immediately: Optional[bool] = False

    finalize: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateCancelAction = Literal[
    "cancel_immediately",
    "cancel_end_of_cycle",
    "uncancel",
]


BillingUpdateBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]


class BillingUpdateRequestTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[
        Nullable[List[BillingUpdateFeatureQuantitiesTypedDict]]
    ]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    free_trial: NotRequired[Nullable[BillingUpdateFreeTrialTypedDict]]
    customize: NotRequired[BillingUpdateCustomizeTypedDict]
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""
    plan_id: NotRequired[str]
    invoice_mode: NotRequired[BillingUpdateInvoiceModeTypedDict]
    cancel_action: NotRequired[BillingUpdateCancelAction]
    billing_behavior: NotRequired[BillingUpdateBillingBehavior]


class BillingUpdateRequest(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: OptionalNullable[List[BillingUpdateFeatureQuantities]] = UNSET
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    free_trial: OptionalNullable[BillingUpdateFreeTrial] = UNSET

    customize: Optional[BillingUpdateCustomize] = None
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    plan_id: Optional[str] = None

    invoice_mode: Optional[BillingUpdateInvoiceMode] = None

    cancel_action: Optional[BillingUpdateCancelAction] = None

    billing_behavior: Optional[BillingUpdateBillingBehavior] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "plan_id",
                "invoice_mode",
                "cancel_action",
                "billing_behavior",
            ]
        )
        nullable_fields = set(["entity_id", "feature_quantities", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingUpdateInvoiceTypedDict(TypedDict):
    status: Nullable[str]
    stripe_id: str
    total: float
    currency: str
    hosted_invoice_url: Nullable[str]


class BillingUpdateInvoice(BaseModel):
    status: Nullable[str]

    stripe_id: str

    total: float

    currency: str

    hosted_invoice_url: Nullable[str]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


BillingUpdateCode = Union[
    Literal[
        "3ds_required",
        "payment_method_required",
        "payment_failed",
    ],
    UnrecognizedStr,
]


class BillingUpdateRequiredActionTypedDict(TypedDict):
    code: BillingUpdateCode
    reason: str


class BillingUpdateRequiredAction(BaseModel):
    code: BillingUpdateCode

    reason: str


class BillingUpdateResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    payment_url: Nullable[str]
    entity_id: NotRequired[str]
    invoice: NotRequired[BillingUpdateInvoiceTypedDict]
    required_action: NotRequired[BillingUpdateRequiredActionTypedDict]


class BillingUpdateResponse(BaseModel):
    r"""OK"""

    customer_id: str

    payment_url: Nullable[str]

    entity_id: Optional[str] = None

    invoice: Optional[BillingUpdateInvoice] = None

    required_action: Optional[BillingUpdateRequiredAction] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "invoice", "required_action"])
        nullable_fields = set(["payment_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
