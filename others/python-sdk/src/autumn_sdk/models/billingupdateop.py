"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingUpdateGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingUpdateGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateFeatureQuantityTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingUpdateFeatureQuantity(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateDurationType = Literal[
    "day",
    "month",
    "year",
]
r"""Unit of time for the trial ('day', 'month', 'year')."""


class BillingUpdateFreeTrialTypedDict(TypedDict):
    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: NotRequired[BillingUpdateDurationType]
    r"""Unit of time for the trial ('day', 'month', 'year')."""
    card_required: NotRequired[bool]
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""


class BillingUpdateFreeTrial(BaseModel):
    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: Optional[BillingUpdateDurationType] = "month"
    r"""Unit of time for the trial ('day', 'month', 'year')."""

    card_required: Optional[bool] = True
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdatePriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval (e.g. 'month', 'year')."""


class BillingUpdatePriceTypedDict(TypedDict):
    amount: float
    r"""Base price amount for the plan."""
    interval: BillingUpdatePriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class BillingUpdatePrice(BaseModel):
    amount: float
    r"""Base price amount for the plan."""

    interval: BillingUpdatePriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""


class BillingUpdateResetTypedDict(TypedDict):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: BillingUpdateResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class BillingUpdateReset(BaseModel):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: BillingUpdateResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateToTypedDict = TypeAliasType("BillingUpdateToTypedDict", Union[float, str])


BillingUpdateTo = TypeAliasType("BillingUpdateTo", Union[float, str])


class BillingUpdateTierTypedDict(TypedDict):
    to: BillingUpdateToTypedDict
    amount: float


class BillingUpdateTier(BaseModel):
    to: BillingUpdateTo

    amount: float


BillingUpdateItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval. For consumable features, should match reset.interval."""


BillingUpdateBillingMethod = Literal[
    "prepaid",
    "usage_based",
]
r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""


class BillingUpdateItemPriceTypedDict(TypedDict):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: BillingUpdateItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""
    billing_method: BillingUpdateBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""
    tiers: NotRequired[List[BillingUpdateTierTypedDict]]
    r"""Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    billing_units: NotRequired[float]
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""
    max_purchase: NotRequired[float]
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""


class BillingUpdateItemPrice(BaseModel):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: BillingUpdateItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""

    billing_method: BillingUpdateBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""

    tiers: Optional[List[BillingUpdateTier]] = None
    r"""Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required."""

    interval_count: Optional[float] = 1
    r"""Number of intervals per billing cycle. Defaults to 1."""

    billing_units: Optional[float] = 1
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""

    max_purchase: Optional[float] = None
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]
r"""Billing behavior when quantity increases mid-cycle."""


BillingUpdateOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]
r"""Credit behavior when quantity decreases mid-cycle."""


class BillingUpdateProrationTypedDict(TypedDict):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: BillingUpdateOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""
    on_decrease: BillingUpdateOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


class BillingUpdateProration(BaseModel):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: BillingUpdateOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""

    on_decrease: BillingUpdateOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


BillingUpdateExpiryDurationType = Literal[
    "month",
    "forever",
]
r"""When rolled over units expire."""


class BillingUpdateRolloverTypedDict(TypedDict):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: BillingUpdateExpiryDurationType
    r"""When rolled over units expire."""
    max: NotRequired[float]
    r"""Max rollover units. Omit for unlimited rollover."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class BillingUpdateRollover(BaseModel):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: BillingUpdateExpiryDurationType
    r"""When rolled over units expire."""

    max: Optional[float] = None
    r"""Max rollover units. Omit for unlimited rollover."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateItemTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature to configure."""
    included: NotRequired[float]
    r"""Number of free units included. Balance resets to this each interval for consumable features."""
    unlimited: NotRequired[bool]
    r"""If true, customer has unlimited access to this feature."""
    reset: NotRequired[BillingUpdateResetTypedDict]
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""
    price: NotRequired[BillingUpdateItemPriceTypedDict]
    r"""Pricing for usage beyond included units. Omit for free features."""
    proration: NotRequired[BillingUpdateProrationTypedDict]
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""
    rollover: NotRequired[BillingUpdateRolloverTypedDict]
    r"""Rollover config for unused units. If set, unused included units carry over."""


class BillingUpdateItem(BaseModel):
    feature_id: str
    r"""The ID of the feature to configure."""

    included: Optional[float] = None
    r"""Number of free units included. Balance resets to this each interval for consumable features."""

    unlimited: Optional[bool] = None
    r"""If true, customer has unlimited access to this feature."""

    reset: Optional[BillingUpdateReset] = None
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    price: Optional[BillingUpdateItemPrice] = None
    r"""Pricing for usage beyond included units. Omit for free features."""

    proration: Optional[BillingUpdateProration] = None
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    rollover: Optional[BillingUpdateRollover] = None
    r"""Rollover config for unused units. If set, unused included units carry over."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingUpdateCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: NotRequired[Nullable[BillingUpdatePriceTypedDict]]
    items: NotRequired[List[BillingUpdateItemTypedDict]]


class BillingUpdateCustomize(BaseModel):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: OptionalNullable[BillingUpdatePrice] = UNSET

    items: Optional[List[BillingUpdateItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingUpdateInvoiceModeTypedDict(TypedDict):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""
    enable_plan_immediately: NotRequired[bool]
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""
    finalize: NotRequired[bool]
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""


class BillingUpdateInvoiceMode(BaseModel):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""

    enable_plan_immediately: Optional[bool] = False
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""

    finalize: Optional[bool] = True
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingUpdateBillingBehavior = Literal[
    "prorate_immediately",
    "none",
]
r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""


BillingUpdateCancelAction = Literal[
    "cancel_immediately",
    "cancel_end_of_cycle",
    "uncancel",
]
r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""


class UpdateSubscriptionParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    plan_id: str
    r"""The ID of the plan."""
    entity_id: NotRequired[str]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[List[BillingUpdateFeatureQuantityTypedDict]]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    free_trial: NotRequired[Nullable[BillingUpdateFreeTrialTypedDict]]
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""
    customize: NotRequired[BillingUpdateCustomizeTypedDict]
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""
    invoice_mode: NotRequired[BillingUpdateInvoiceModeTypedDict]
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""
    billing_behavior: NotRequired[BillingUpdateBillingBehavior]
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""
    cancel_action: NotRequired[BillingUpdateCancelAction]
    r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""


class UpdateSubscriptionParams(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    plan_id: str
    r"""The ID of the plan."""

    entity_id: Optional[str] = None
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: Optional[List[BillingUpdateFeatureQuantity]] = None
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    free_trial: OptionalNullable[BillingUpdateFreeTrial] = UNSET
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""

    customize: Optional[BillingUpdateCustomize] = None
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    invoice_mode: Optional[BillingUpdateInvoiceMode] = None
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    billing_behavior: Optional[BillingUpdateBillingBehavior] = None
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""

    cancel_action: Optional[BillingUpdateCancelAction] = None
    r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "invoice_mode",
                "billing_behavior",
                "cancel_action",
            ]
        )
        nullable_fields = set(["free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingUpdateInvoiceTypedDict(TypedDict):
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    status: Nullable[str]
    r"""The status of the invoice (e.g., 'paid', 'open', 'draft')."""
    stripe_id: str
    r"""The Stripe invoice ID."""
    total: float
    r"""The total amount of the invoice in cents."""
    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""
    hosted_invoice_url: Nullable[str]
    r"""URL to the hosted invoice page where the customer can view and pay the invoice."""


class BillingUpdateInvoice(BaseModel):
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    status: Nullable[str]
    r"""The status of the invoice (e.g., 'paid', 'open', 'draft')."""

    stripe_id: str
    r"""The Stripe invoice ID."""

    total: float
    r"""The total amount of the invoice in cents."""

    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""

    hosted_invoice_url: Nullable[str]
    r"""URL to the hosted invoice page where the customer can view and pay the invoice."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


BillingUpdateCode = Union[
    Literal[
        "3ds_required",
        "payment_method_required",
        "payment_failed",
    ],
    UnrecognizedStr,
]
r"""The type of action required to complete the payment."""


class BillingUpdateRequiredActionTypedDict(TypedDict):
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    code: BillingUpdateCode
    r"""The type of action required to complete the payment."""
    reason: str
    r"""A human-readable explanation of why this action is required."""


class BillingUpdateRequiredAction(BaseModel):
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    code: BillingUpdateCode
    r"""The type of action required to complete the payment."""

    reason: str
    r"""A human-readable explanation of why this action is required."""


class BillingUpdateResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""
    payment_url: Nullable[str]
    r"""URL to redirect the customer to complete payment. Null if no payment action is required."""
    entity_id: NotRequired[str]
    r"""The ID of the entity, if the plan was attached to an entity."""
    invoice: NotRequired[BillingUpdateInvoiceTypedDict]
    r"""Invoice details if an invoice was created. Only present when a charge was made."""
    required_action: NotRequired[BillingUpdateRequiredActionTypedDict]
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""


class BillingUpdateResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""

    payment_url: Nullable[str]
    r"""URL to redirect the customer to complete payment. Null if no payment action is required."""

    entity_id: Optional[str] = None
    r"""The ID of the entity, if the plan was attached to an entity."""

    invoice: Optional[BillingUpdateInvoice] = None
    r"""Invoice details if an invoice was created. Only present when a charge was made."""

    required_action: Optional[BillingUpdateRequiredAction] = None
    r"""Details about any action required to complete the payment. Present when the payment could not be processed automatically."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "invoice", "required_action"])
        nullable_fields = set(["payment_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
