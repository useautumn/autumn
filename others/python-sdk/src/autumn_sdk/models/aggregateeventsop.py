"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import BaseModel, UNSET_SENTINEL
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class AggregateEventsGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class AggregateEventsGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


AggregateEventsFeatureIDTypedDict = TypeAliasType(
    "AggregateEventsFeatureIDTypedDict", Union[str, List[str]]
)
r"""Feature ID(s) to aggregate events for"""


AggregateEventsFeatureID = TypeAliasType(
    "AggregateEventsFeatureID", Union[str, List[str]]
)
r"""Feature ID(s) to aggregate events for"""


Range = Literal[
    "24h",
    "7d",
    "30d",
    "90d",
    "last_cycle",
    "1bc",
    "3bc",
]
r"""Time range to aggregate events for. Either range or custom_range must be provided"""


BinSize = Literal[
    "day",
    "hour",
    "month",
]
r"""Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day"""


class AggregateEventsCustomRangeTypedDict(TypedDict):
    r"""Custom time range to aggregate events for. If provided, range must not be provided"""

    start: float
    end: float


class AggregateEventsCustomRange(BaseModel):
    r"""Custom time range to aggregate events for. If provided, range must not be provided"""

    start: float

    end: float


class EventsAggregateParamsTypedDict(TypedDict):
    customer_id: str
    r"""Customer ID to aggregate events for"""
    feature_id: AggregateEventsFeatureIDTypedDict
    r"""Feature ID(s) to aggregate events for"""
    group_by: NotRequired[str]
    r"""Property to group events by. If provided, each key in the response will be an object with distinct groups as the keys"""
    range: NotRequired[Range]
    r"""Time range to aggregate events for. Either range or custom_range must be provided"""
    bin_size: NotRequired[BinSize]
    r"""Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day"""
    custom_range: NotRequired[AggregateEventsCustomRangeTypedDict]
    r"""Custom time range to aggregate events for. If provided, range must not be provided"""


class EventsAggregateParams(BaseModel):
    customer_id: str
    r"""Customer ID to aggregate events for"""

    feature_id: AggregateEventsFeatureID
    r"""Feature ID(s) to aggregate events for"""

    group_by: Optional[str] = None
    r"""Property to group events by. If provided, each key in the response will be an object with distinct groups as the keys"""

    range: Optional[Range] = None
    r"""Time range to aggregate events for. Either range or custom_range must be provided"""

    bin_size: Optional[BinSize] = "day"
    r"""Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day"""

    custom_range: Optional[AggregateEventsCustomRange] = None
    r"""Custom time range to aggregate events for. If provided, range must not be provided"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["group_by", "range", "bin_size", "custom_range"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class AggregateEventsListTypedDict(TypedDict):
    period: float
    r"""Unix timestamp (epoch ms) for this time period"""
    values: Dict[str, float]
    r"""Aggregated values per feature: { [featureId]: number }"""
    grouped_values: NotRequired[Dict[str, Dict[str, float]]]
    r"""Values broken down by group (only present when group_by is used): { [featureId]: { [groupValue]: number } }"""


class AggregateEventsList(BaseModel):
    period: float
    r"""Unix timestamp (epoch ms) for this time period"""

    values: Dict[str, float]
    r"""Aggregated values per feature: { [featureId]: number }"""

    grouped_values: Optional[Dict[str, Dict[str, float]]] = None
    r"""Values broken down by group (only present when group_by is used): { [featureId]: { [groupValue]: number } }"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["grouped_values"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TotalTypedDict(TypedDict):
    count: float
    r"""Number of events for this feature"""
    sum: float
    r"""Sum of event values for this feature"""


class Total(BaseModel):
    count: float
    r"""Number of events for this feature"""

    sum: float
    r"""Sum of event values for this feature"""


class AggregateEventsResponseTypedDict(TypedDict):
    r"""OK"""

    list: List[AggregateEventsListTypedDict]
    r"""Array of time periods with aggregated values"""
    total: Dict[str, TotalTypedDict]
    r"""Total aggregations per feature. Keys are feature IDs, values contain count and sum."""


class AggregateEventsResponse(BaseModel):
    r"""OK"""

    list: List[AggregateEventsList]
    r"""Array of time periods with aggregated values"""

    total: Dict[str, Total]
    r"""Total aggregations per feature. Keys are feature IDs, values contain count and sum."""
