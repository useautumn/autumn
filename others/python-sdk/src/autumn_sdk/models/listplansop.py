"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ListPlansGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class ListPlansGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListPlansParamsTypedDict(TypedDict):
    customer_id: NotRequired[str]
    r"""Customer ID to include eligibility info (trial availability, attach scenario)."""
    entity_id: NotRequired[str]
    r"""Entity ID for entity-scoped plans."""
    include_archived: NotRequired[bool]
    r"""If true, includes archived plans in the response."""


class ListPlansParams(BaseModel):
    customer_id: Optional[str] = None
    r"""Customer ID to include eligibility info (trial availability, attach scenario)."""

    entity_id: Optional[str] = None
    r"""Entity ID for entity-scoped plans."""

    include_archived: Optional[bool] = None
    r"""If true, includes archived plans in the response."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["customer_id", "entity_id", "include_archived"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListPlansPriceInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval (e.g. 'month', 'year')."""


class ListPlansPriceDisplayTypedDict(TypedDict):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class ListPlansPriceDisplay(BaseModel):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListPlansPriceTypedDict(TypedDict):
    amount: float
    r"""Base price amount for the plan."""
    interval: ListPlansPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    display: NotRequired[ListPlansPriceDisplayTypedDict]
    r"""Display text for showing this price in pricing pages."""


class ListPlansPrice(BaseModel):
    amount: float
    r"""Base price amount for the plan."""

    interval: ListPlansPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    display: Optional[ListPlansPriceDisplay] = None
    r"""Display text for showing this price in pricing pages."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListPlansType = Union[
    Literal[
        "static",
        "boolean",
        "single_use",
        "continuous_use",
        "credit_system",
    ],
    UnrecognizedStr,
]
r"""The type of the feature"""


class ListPlansFeatureDisplayTypedDict(TypedDict):
    singular: str
    r"""The singular display name for the feature."""
    plural: str
    r"""The plural display name for the feature."""


class ListPlansFeatureDisplay(BaseModel):
    singular: str
    r"""The singular display name for the feature."""

    plural: str
    r"""The plural display name for the feature."""


class ListPlansCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""
    credit_cost: float
    r"""The credit cost of the metered feature."""


class ListPlansCreditSchema(BaseModel):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""

    credit_cost: float
    r"""The credit cost of the metered feature."""


class ListPlansFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""
    type: ListPlansType
    r"""The type of the feature"""
    name: NotRequired[Nullable[str]]
    r"""The name of the feature."""
    display: NotRequired[Nullable[ListPlansFeatureDisplayTypedDict]]
    r"""Singular and plural display names for the feature."""
    credit_schema: NotRequired[Nullable[List[ListPlansCreditSchemaTypedDict]]]
    r"""Credit cost schema for credit system features."""
    archived: NotRequired[Nullable[bool]]
    r"""Whether or not the feature is archived."""


class ListPlansFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""

    type: ListPlansType
    r"""The type of the feature"""

    name: OptionalNullable[str] = UNSET
    r"""The name of the feature."""

    display: OptionalNullable[ListPlansFeatureDisplay] = UNSET
    r"""Singular and plural display names for the feature."""

    credit_schema: OptionalNullable[List[ListPlansCreditSchema]] = UNSET
    r"""Credit cost schema for credit system features."""

    archived: OptionalNullable[bool] = UNSET
    r"""Whether or not the feature is archived."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "display", "credit_schema", "archived"])
        nullable_fields = set(["name", "display", "credit_schema", "archived"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListPlansResetInterval = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""


class ListPlansResetTypedDict(TypedDict):
    interval: ListPlansResetInterval
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class ListPlansReset(BaseModel):
    interval: ListPlansResetInterval
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListPlansToTypedDict = TypeAliasType("ListPlansToTypedDict", Union[float, str])


ListPlansTo = TypeAliasType("ListPlansTo", Union[float, str])


class ListPlansTierTypedDict(TypedDict):
    to: ListPlansToTypedDict
    amount: float
    flat_amount: NotRequired[Nullable[float]]


class ListPlansTier(BaseModel):
    to: ListPlansTo

    amount: float

    flat_amount: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["flat_amount"])
        nullable_fields = set(["flat_amount"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListPlansTierBehavior = Union[
    Literal[
        "graduated",
        "volume",
    ],
    UnrecognizedStr,
]


ListPlansPriceItemInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval for this price. For consumable features, should match reset.interval."""


ListPlansBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""


class ListPlansItemPriceTypedDict(TypedDict):
    interval: ListPlansPriceItemInterval
    r"""Billing interval for this price. For consumable features, should match reset.interval."""
    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""
    billing_method: ListPlansBillingMethod
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""
    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""
    tiers: NotRequired[List[ListPlansTierTypedDict]]
    r"""Tiered pricing configuration. Each tier's 'to' INCLUDES the included amount. Either 'tiers' or 'amount' is required."""
    tier_behavior: NotRequired[ListPlansTierBehavior]
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class ListPlansItemPrice(BaseModel):
    interval: ListPlansPriceItemInterval
    r"""Billing interval for this price. For consumable features, should match reset.interval."""

    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""

    billing_method: ListPlansBillingMethod
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""

    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""

    tiers: Optional[List[ListPlansTier]] = None
    r"""Tiered pricing configuration. Each tier's 'to' INCLUDES the included amount. Either 'tiers' or 'amount' is required."""

    tier_behavior: Optional[ListPlansTierBehavior] = None

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers", "tier_behavior", "interval_count"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListPlansItemDisplayTypedDict(TypedDict):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class ListPlansItemDisplay(BaseModel):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListPlansExpiryDurationType = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]
r"""When rolled over units expire."""


class ListPlansRolloverTypedDict(TypedDict):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""
    expiry_duration_type: ListPlansExpiryDurationType
    r"""When rolled over units expire."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class ListPlansRollover(BaseModel):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""

    expiry_duration_type: ListPlansExpiryDurationType
    r"""When rolled over units expire."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["expiry_duration_length"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListPlansItemTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature this item configures."""
    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""
    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""
    reset: Nullable[ListPlansResetTypedDict]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""
    price: Nullable[ListPlansItemPriceTypedDict]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""
    feature: NotRequired[ListPlansFeatureTypedDict]
    r"""The full feature object if expanded."""
    display: NotRequired[ListPlansItemDisplayTypedDict]
    r"""Display text for showing this item in pricing pages."""
    rollover: NotRequired[ListPlansRolloverTypedDict]
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""


class ListPlansItem(BaseModel):
    feature_id: str
    r"""The ID of the feature this item configures."""

    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""

    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""

    reset: Nullable[ListPlansReset]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""

    price: Nullable[ListPlansItemPrice]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""

    feature: Optional[ListPlansFeature] = None
    r"""The full feature object if expanded."""

    display: Optional[ListPlansItemDisplay] = None
    r"""Display text for showing this item in pricing pages."""

    rollover: Optional[ListPlansRollover] = None
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "display", "rollover"])
        nullable_fields = set(["reset", "price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListPlansDurationType = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""Unit of time for the trial duration ('day', 'month', 'year')."""


class ListPlansFreeTrialTypedDict(TypedDict):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: ListPlansDurationType
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""
    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


class ListPlansFreeTrial(BaseModel):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: ListPlansDurationType
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""

    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


ListPlansEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""Environment this plan belongs to ('sandbox' or 'live')."""


ListPlansScenario = Union[
    Literal[
        "scheduled",
        "active",
        "new",
        "renew",
        "upgrade",
        "downgrade",
        "cancel",
        "expired",
        "past_due",
    ],
    UnrecognizedStr,
]
r"""The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade)."""


class ListPlansCustomerEligibilityTypedDict(TypedDict):
    scenario: ListPlansScenario
    r"""The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade)."""
    trial_available: NotRequired[bool]
    r"""Whether a free trial is available for this customer."""


class ListPlansCustomerEligibility(BaseModel):
    scenario: ListPlansScenario
    r"""The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade)."""

    trial_available: Optional[bool] = None
    r"""Whether a free trial is available for this customer."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["trial_available"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListPlansListTypedDict(TypedDict):
    r"""A plan defines a set of features, pricing, and entitlements that can be attached to customers."""

    id: str
    r"""Unique identifier for the plan."""
    name: str
    r"""Display name of the plan."""
    description: Nullable[str]
    r"""Optional description of the plan."""
    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""
    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""
    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""
    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""
    price: Nullable[ListPlansPriceTypedDict]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""
    items: List[ListPlansItemTypedDict]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""
    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""
    env: ListPlansEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""
    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""
    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""
    free_trial: NotRequired[ListPlansFreeTrialTypedDict]
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""
    customer_eligibility: NotRequired[ListPlansCustomerEligibilityTypedDict]


class ListPlansList(BaseModel):
    r"""A plan defines a set of features, pricing, and entitlements that can be attached to customers."""

    id: str
    r"""Unique identifier for the plan."""

    name: str
    r"""Display name of the plan."""

    description: Nullable[str]
    r"""Optional description of the plan."""

    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""

    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""

    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""

    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""

    price: Nullable[ListPlansPrice]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""

    items: List[ListPlansItem]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""

    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""

    env: ListPlansEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""

    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""

    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""

    free_trial: Optional[ListPlansFreeTrial] = None
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    customer_eligibility: Optional[ListPlansCustomerEligibility] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["free_trial", "customer_eligibility"])
        nullable_fields = set(["description", "group", "price", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListPlansResponseTypedDict(TypedDict):
    r"""OK"""

    list: List[ListPlansListTypedDict]


class ListPlansResponse(BaseModel):
    r"""OK"""

    list: List[ListPlansList]
