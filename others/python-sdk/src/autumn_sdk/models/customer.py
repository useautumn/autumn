"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .plan import Plan, PlanTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import validate_const
import pydantic
from pydantic import model_serializer
from pydantic.functional_validators import AfterValidator
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CustomerEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment this customer was created in."""


Status = Union[
    Literal[
        "active",
        "scheduled",
        "expired",
    ],
    UnrecognizedStr,
]


class SubscriptionTypedDict(TypedDict):
    plan_id: str
    auto_enable: bool
    add_on: bool
    status: Status
    past_due: bool
    canceled_at: Nullable[float]
    expires_at: Nullable[float]
    trial_ends_at: Nullable[float]
    started_at: float
    current_period_start: Nullable[float]
    current_period_end: Nullable[float]
    quantity: float
    plan: NotRequired[PlanTypedDict]


class Subscription(BaseModel):
    plan_id: str

    auto_enable: bool

    add_on: bool

    status: Status

    past_due: bool

    canceled_at: Nullable[float]

    expires_at: Nullable[float]

    trial_ends_at: Nullable[float]

    started_at: float

    current_period_start: Nullable[float]

    current_period_end: Nullable[float]

    quantity: float

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(
            [
                "canceled_at",
                "expires_at",
                "trial_ends_at",
                "current_period_start",
                "current_period_end",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PurchaseTypedDict(TypedDict):
    plan_id: str
    expires_at: Nullable[float]
    started_at: float
    quantity: float
    plan: NotRequired[PlanTypedDict]


class Purchase(BaseModel):
    plan_id: str

    expires_at: Nullable[float]

    started_at: float

    quantity: float

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(["expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CustomerBalancesType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class CustomerCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class CustomerCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class CustomerDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class CustomerDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CustomerFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: CustomerBalancesType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[CustomerCreditSchemaTypedDict]]
    display: NotRequired[CustomerDisplayTypedDict]


class CustomerFeature(BaseModel):
    id: str

    name: str

    type: CustomerBalancesType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[CustomerCreditSchema]] = None

    display: Optional[CustomerDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CustomerIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


CustomerIntervalUnionTypedDict = TypeAliasType(
    "CustomerIntervalUnionTypedDict", Union[CustomerIntervalEnum, str]
)


CustomerIntervalUnion = TypeAliasType(
    "CustomerIntervalUnion", Union[CustomerIntervalEnum, str]
)


class CustomerResetTypedDict(TypedDict):
    interval: CustomerIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class CustomerReset(BaseModel):
    interval: CustomerIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CustomerToTypedDict = TypeAliasType("CustomerToTypedDict", Union[float, str])


CustomerTo = TypeAliasType("CustomerTo", Union[float, str])


class CustomerTierTypedDict(TypedDict):
    to: CustomerToTypedDict
    amount: float


class CustomerTier(BaseModel):
    to: CustomerTo

    amount: float


CustomerBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class CustomerPriceTypedDict(TypedDict):
    billing_units: float
    billing_method: CustomerBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[CustomerTierTypedDict]]


class CustomerPrice(BaseModel):
    billing_units: float

    billing_method: CustomerBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[CustomerTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[CustomerResetTypedDict]
    price: Nullable[CustomerPriceTypedDict]
    expires_at: Nullable[float]
    object: Literal["balance_breakdown"]
    id: NotRequired[str]


class Breakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[CustomerReset]

    price: Nullable[CustomerPrice]

    expires_at: Nullable[float]

    object: Annotated[
        Annotated[
            Literal["balance_breakdown"],
            AfterValidator(validate_const("balance_breakdown")),
        ],
        pydantic.Field(alias="object"),
    ] = "balance_breakdown"

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CustomerRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class CustomerRollover(BaseModel):
    balance: float

    expires_at: float


class BalancesTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    object: Literal["balance"]
    feature: NotRequired[CustomerFeatureTypedDict]
    breakdown: NotRequired[List[BreakdownTypedDict]]
    rollovers: NotRequired[List[CustomerRolloverTypedDict]]


class Balances(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    object: Annotated[
        Annotated[Literal["balance"], AfterValidator(validate_const("balance"))],
        pydantic.Field(alias="object"),
    ] = "balance"

    feature: Optional[CustomerFeature] = None

    breakdown: Optional[List[Breakdown]] = None

    rollovers: Optional[List[CustomerRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class InvoiceTypedDict(TypedDict):
    plan_ids: List[str]
    r"""Array of plan IDs included in this invoice"""
    stripe_id: str
    r"""The Stripe invoice ID"""
    status: str
    r"""The status of the invoice"""
    total: float
    r"""The total amount of the invoice"""
    currency: str
    r"""The currency code for the invoice"""
    created_at: float
    r"""Timestamp when the invoice was created"""
    hosted_invoice_url: NotRequired[Nullable[str]]
    r"""URL to the Stripe-hosted invoice page"""


class Invoice(BaseModel):
    plan_ids: List[str]
    r"""Array of plan IDs included in this invoice"""

    stripe_id: str
    r"""The Stripe invoice ID"""

    status: str
    r"""The status of the invoice"""

    total: float
    r"""The total amount of the invoice"""

    currency: str
    r"""The currency code for the invoice"""

    created_at: float
    r"""Timestamp when the invoice was created"""

    hosted_invoice_url: OptionalNullable[str] = UNSET
    r"""URL to the Stripe-hosted invoice page"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["hosted_invoice_url"])
        nullable_fields = set(["hosted_invoice_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


EntityEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment (sandbox/live)"""


class EntityTypedDict(TypedDict):
    id: Nullable[str]
    r"""The unique identifier of the entity"""
    name: Nullable[str]
    r"""The name of the entity"""
    created_at: float
    r"""Unix timestamp when the entity was created"""
    env: EntityEnv
    r"""The environment (sandbox/live)"""
    autumn_id: NotRequired[str]
    customer_id: NotRequired[Nullable[str]]
    r"""The customer ID this entity belongs to"""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID this entity belongs to"""


class Entity(BaseModel):
    id: Nullable[str]
    r"""The unique identifier of the entity"""

    name: Nullable[str]
    r"""The name of the entity"""

    created_at: float
    r"""Unix timestamp when the entity was created"""

    env: EntityEnv
    r"""The environment (sandbox/live)"""

    autumn_id: Optional[str] = None

    customer_id: OptionalNullable[str] = UNSET
    r"""The customer ID this entity belongs to"""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID this entity belongs to"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["autumn_id", "customer_id", "feature_id"])
        nullable_fields = set(["id", "name", "customer_id", "feature_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrialsUsedTypedDict(TypedDict):
    plan_id: str
    customer_id: str
    fingerprint: NotRequired[Nullable[str]]


class TrialsUsed(BaseModel):
    plan_id: str

    customer_id: str

    fingerprint: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["fingerprint"])
        nullable_fields = set(["fingerprint"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RewardsType = Union[
    Literal[
        "percentage_discount",
        "fixed_discount",
        "free_product",
        "invoice_credits",
    ],
    UnrecognizedStr,
]
r"""The type of reward"""


CustomerDurationType = Union[
    Literal[
        "one_off",
        "months",
        "forever",
    ],
    UnrecognizedStr,
]
r"""How long the discount lasts"""


class DiscountTypedDict(TypedDict):
    id: str
    r"""The unique identifier for this discount"""
    name: str
    r"""The name of the discount or coupon"""
    type: RewardsType
    r"""The type of reward"""
    discount_value: float
    r"""The discount value (percentage or fixed amount)"""
    duration_type: CustomerDurationType
    r"""How long the discount lasts"""
    duration_value: NotRequired[Nullable[float]]
    r"""Number of billing periods the discount applies for repeating durations"""
    currency: NotRequired[Nullable[str]]
    r"""The currency code for fixed amount discounts"""
    start: NotRequired[Nullable[float]]
    r"""Timestamp when the discount becomes active"""
    end: NotRequired[Nullable[float]]
    r"""Timestamp when the discount expires"""
    subscription_id: NotRequired[Nullable[str]]
    r"""The Stripe subscription ID this discount is applied to"""
    total_discount_amount: NotRequired[Nullable[float]]
    r"""Total amount saved from this discount"""


class Discount(BaseModel):
    id: str
    r"""The unique identifier for this discount"""

    name: str
    r"""The name of the discount or coupon"""

    type: RewardsType
    r"""The type of reward"""

    discount_value: float
    r"""The discount value (percentage or fixed amount)"""

    duration_type: CustomerDurationType
    r"""How long the discount lasts"""

    duration_value: OptionalNullable[float] = UNSET
    r"""Number of billing periods the discount applies for repeating durations"""

    currency: OptionalNullable[str] = UNSET
    r"""The currency code for fixed amount discounts"""

    start: OptionalNullable[float] = UNSET
    r"""Timestamp when the discount becomes active"""

    end: OptionalNullable[float] = UNSET
    r"""Timestamp when the discount expires"""

    subscription_id: OptionalNullable[str] = UNSET
    r"""The Stripe subscription ID this discount is applied to"""

    total_discount_amount: OptionalNullable[float] = UNSET
    r"""Total amount saved from this discount"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "duration_value",
                "currency",
                "start",
                "end",
                "subscription_id",
                "total_discount_amount",
            ]
        )
        nullable_fields = set(
            [
                "duration_value",
                "currency",
                "start",
                "end",
                "subscription_id",
                "total_discount_amount",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class RewardsTypedDict(TypedDict):
    discounts: List[DiscountTypedDict]
    r"""Array of active discounts applied to the customer"""


class Rewards(BaseModel):
    discounts: List[Discount]
    r"""Array of active discounts applied to the customer"""


class ReferralCustomerTypedDict(TypedDict):
    id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]


class ReferralCustomer(BaseModel):
    id: str

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "email"])
        nullable_fields = set(["name", "email"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ReferralTypedDict(TypedDict):
    program_id: str
    customer: ReferralCustomerTypedDict
    reward_applied: bool
    created_at: float


class Referral(BaseModel):
    program_id: str

    customer: ReferralCustomer

    reward_applied: bool

    created_at: float


class CustomerTypedDict(TypedDict):
    id: Nullable[str]
    r"""Your unique identifier for the customer."""
    name: Nullable[str]
    r"""The name of the customer."""
    email: Nullable[str]
    r"""The email address of the customer."""
    created_at: float
    r"""Timestamp of customer creation in milliseconds since epoch."""
    fingerprint: Nullable[str]
    r"""A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID."""
    stripe_id: Nullable[str]
    r"""Stripe customer ID."""
    env: CustomerEnv
    r"""The environment this customer was created in."""
    metadata: Dict[str, Any]
    r"""The metadata for the customer."""
    send_email_receipts: bool
    r"""Whether to send email receipts to the customer."""
    subscriptions: List[SubscriptionTypedDict]
    purchases: List[PurchaseTypedDict]
    balances: Dict[str, BalancesTypedDict]
    invoices: NotRequired[List[InvoiceTypedDict]]
    entities: NotRequired[List[EntityTypedDict]]
    trials_used: NotRequired[List[TrialsUsedTypedDict]]
    rewards: NotRequired[Nullable[RewardsTypedDict]]
    referrals: NotRequired[List[ReferralTypedDict]]
    payment_method: NotRequired[Nullable[Any]]


class Customer(BaseModel):
    id: Nullable[str]
    r"""Your unique identifier for the customer."""

    name: Nullable[str]
    r"""The name of the customer."""

    email: Nullable[str]
    r"""The email address of the customer."""

    created_at: float
    r"""Timestamp of customer creation in milliseconds since epoch."""

    fingerprint: Nullable[str]
    r"""A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID."""

    stripe_id: Nullable[str]
    r"""Stripe customer ID."""

    env: CustomerEnv
    r"""The environment this customer was created in."""

    metadata: Dict[str, Any]
    r"""The metadata for the customer."""

    send_email_receipts: bool
    r"""Whether to send email receipts to the customer."""

    subscriptions: List[Subscription]

    purchases: List[Purchase]

    balances: Dict[str, Balances]

    invoices: Optional[List[Invoice]] = None

    entities: Optional[List[Entity]] = None

    trials_used: Optional[List[TrialsUsed]] = None

    rewards: OptionalNullable[Rewards] = UNSET

    referrals: Optional[List[Referral]] = None

    payment_method: OptionalNullable[Any] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "invoices",
                "entities",
                "trials_used",
                "rewards",
                "referrals",
                "payment_method",
            ]
        )
        nullable_fields = set(
            [
                "id",
                "name",
                "email",
                "fingerprint",
                "stripe_id",
                "rewards",
                "payment_method",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    Breakdown.model_rebuild()
except NameError:
    pass
try:
    Balances.model_rebuild()
except NameError:
    pass
