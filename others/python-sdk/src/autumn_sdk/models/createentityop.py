"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .balance import Balance, BalanceTypedDict
from .customerdata import CustomerData, CustomerDataTypedDict
from .plan import Plan, PlanTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


class CreateEntityGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class CreateEntityGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEntityParamsTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature this entity is associated with"""
    customer_id: str
    r"""The ID of the customer to create the entity for."""
    entity_id: str
    r"""The ID of the entity."""
    name: NotRequired[Nullable[str]]
    r"""The name of the entity"""
    customer_data: NotRequired[CustomerDataTypedDict]
    r"""Customer details to set when creating a customer"""


class CreateEntityParams(BaseModel):
    feature_id: str
    r"""The ID of the feature this entity is associated with"""

    customer_id: str
    r"""The ID of the customer to create the entity for."""

    entity_id: str
    r"""The ID of the entity."""

    name: OptionalNullable[str] = UNSET
    r"""The name of the entity"""

    customer_data: Optional[CustomerData] = None
    r"""Customer details to set when creating a customer"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "customer_data"])
        nullable_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CreateEntityEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment (sandbox/live)"""


CreateEntityStatus = Union[
    Literal[
        "active",
        "scheduled",
    ],
    UnrecognizedStr,
]
r"""Current status of the subscription."""


class CreateEntitySubscriptionTypedDict(TypedDict):
    plan_id: str
    r"""The unique identifier of the subscribed plan."""
    auto_enable: bool
    r"""Whether the plan was automatically enabled for the customer."""
    add_on: bool
    r"""Whether this is an add-on plan rather than a base subscription."""
    status: CreateEntityStatus
    r"""Current status of the subscription."""
    past_due: bool
    r"""Whether the subscription has overdue payments."""
    canceled_at: Nullable[float]
    r"""Timestamp when the subscription was canceled, or null if not canceled."""
    expires_at: Nullable[float]
    r"""Timestamp when the subscription will expire, or null if no expiry set."""
    trial_ends_at: Nullable[float]
    r"""Timestamp when the trial period ends, or null if not on trial."""
    started_at: float
    r"""Timestamp when the subscription started."""
    current_period_start: Nullable[float]
    r"""Start timestamp of the current billing period."""
    current_period_end: Nullable[float]
    r"""End timestamp of the current billing period."""
    quantity: float
    r"""Number of units of this subscription (for per-seat plans)."""
    plan: NotRequired[PlanTypedDict]


class CreateEntitySubscription(BaseModel):
    plan_id: str
    r"""The unique identifier of the subscribed plan."""

    auto_enable: bool
    r"""Whether the plan was automatically enabled for the customer."""

    add_on: bool
    r"""Whether this is an add-on plan rather than a base subscription."""

    status: CreateEntityStatus
    r"""Current status of the subscription."""

    past_due: bool
    r"""Whether the subscription has overdue payments."""

    canceled_at: Nullable[float]
    r"""Timestamp when the subscription was canceled, or null if not canceled."""

    expires_at: Nullable[float]
    r"""Timestamp when the subscription will expire, or null if no expiry set."""

    trial_ends_at: Nullable[float]
    r"""Timestamp when the trial period ends, or null if not on trial."""

    started_at: float
    r"""Timestamp when the subscription started."""

    current_period_start: Nullable[float]
    r"""Start timestamp of the current billing period."""

    current_period_end: Nullable[float]
    r"""End timestamp of the current billing period."""

    quantity: float
    r"""Number of units of this subscription (for per-seat plans)."""

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(
            [
                "canceled_at",
                "expires_at",
                "trial_ends_at",
                "current_period_start",
                "current_period_end",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateEntityPurchaseTypedDict(TypedDict):
    plan_id: str
    r"""The unique identifier of the purchased plan."""
    expires_at: Nullable[float]
    r"""Timestamp when the purchase expires, or null for lifetime access."""
    started_at: float
    r"""Timestamp when the purchase was made."""
    quantity: float
    r"""Number of units purchased."""
    plan: NotRequired[PlanTypedDict]


class CreateEntityPurchase(BaseModel):
    plan_id: str
    r"""The unique identifier of the purchased plan."""

    expires_at: Nullable[float]
    r"""Timestamp when the purchase expires, or null for lifetime access."""

    started_at: float
    r"""Timestamp when the purchase was made."""

    quantity: float
    r"""Number of units purchased."""

    plan: Optional[Plan] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["plan"])
        nullable_fields = set(["expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateEntityInvoiceTypedDict(TypedDict):
    plan_ids: List[str]
    r"""Array of plan IDs included in this invoice"""
    stripe_id: str
    r"""The Stripe invoice ID"""
    status: str
    r"""The status of the invoice"""
    total: float
    r"""The total amount of the invoice"""
    currency: str
    r"""The currency code for the invoice"""
    created_at: float
    r"""Timestamp when the invoice was created"""
    hosted_invoice_url: NotRequired[Nullable[str]]
    r"""URL to the Stripe-hosted invoice page"""


class CreateEntityInvoice(BaseModel):
    plan_ids: List[str]
    r"""Array of plan IDs included in this invoice"""

    stripe_id: str
    r"""The Stripe invoice ID"""

    status: str
    r"""The status of the invoice"""

    total: float
    r"""The total amount of the invoice"""

    currency: str
    r"""The currency code for the invoice"""

    created_at: float
    r"""Timestamp when the invoice was created"""

    hosted_invoice_url: OptionalNullable[str] = UNSET
    r"""URL to the Stripe-hosted invoice page"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["hosted_invoice_url"])
        nullable_fields = set(["hosted_invoice_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateEntityResponseTypedDict(TypedDict):
    r"""OK"""

    id: Nullable[str]
    r"""The unique identifier of the entity"""
    name: Nullable[str]
    r"""The name of the entity"""
    created_at: float
    r"""Unix timestamp when the entity was created"""
    env: CreateEntityEnv
    r"""The environment (sandbox/live)"""
    subscriptions: List[CreateEntitySubscriptionTypedDict]
    purchases: List[CreateEntityPurchaseTypedDict]
    balances: Dict[str, BalanceTypedDict]
    autumn_id: NotRequired[str]
    customer_id: NotRequired[Nullable[str]]
    r"""The customer ID this entity belongs to"""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID this entity belongs to"""
    invoices: NotRequired[List[CreateEntityInvoiceTypedDict]]
    r"""Invoices for this entity (only included when expand=invoices)"""


class CreateEntityResponse(BaseModel):
    r"""OK"""

    id: Nullable[str]
    r"""The unique identifier of the entity"""

    name: Nullable[str]
    r"""The name of the entity"""

    created_at: float
    r"""Unix timestamp when the entity was created"""

    env: CreateEntityEnv
    r"""The environment (sandbox/live)"""

    subscriptions: List[CreateEntitySubscription]

    purchases: List[CreateEntityPurchase]

    balances: Dict[str, Balance]

    autumn_id: Optional[str] = None

    customer_id: OptionalNullable[str] = UNSET
    r"""The customer ID this entity belongs to"""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID this entity belongs to"""

    invoices: Optional[List[CreateEntityInvoice]] = None
    r"""Invoices for this entity (only included when expand=invoices)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["autumn_id", "customer_id", "feature_id", "invoices"])
        nullable_fields = set(["id", "name", "customer_id", "feature_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
