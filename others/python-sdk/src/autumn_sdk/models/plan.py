"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import BaseModel, Nullable, UNSET_SENTINEL, UnrecognizedStr
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import NotRequired, TypeAliasType, TypedDict


PriceInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


class PlanPriceTypedDict(TypedDict):
    amount: float
    interval: PriceInterval
    interval_count: NotRequired[float]


class PlanPrice(BaseModel):
    amount: float

    interval: PriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PlanResetInterval = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


class PlanResetTypedDict(TypedDict):
    interval: PlanResetInterval
    interval_count: NotRequired[float]


class PlanReset(BaseModel):
    interval: PlanResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PlanToTypedDict = TypeAliasType("PlanToTypedDict", Union[float, str])


PlanTo = TypeAliasType("PlanTo", Union[float, str])


class PlanTierTypedDict(TypedDict):
    to: PlanToTypedDict
    amount: float


class PlanTier(BaseModel):
    to: PlanTo

    amount: float


PriceItemInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


PlanBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class ItemPriceTypedDict(TypedDict):
    interval: PriceItemInterval
    billing_units: float
    billing_method: PlanBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[PlanTierTypedDict]]
    interval_count: NotRequired[float]


class ItemPrice(BaseModel):
    interval: PriceItemInterval

    billing_units: float

    billing_method: PlanBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[PlanTier]] = None

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers", "interval_count"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ExpiryDurationType = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]


class PlanRolloverTypedDict(TypedDict):
    max: Nullable[float]
    expiry_duration_type: ExpiryDurationType
    expiry_duration_length: NotRequired[float]


class PlanRollover(BaseModel):
    max: Nullable[float]

    expiry_duration_type: ExpiryDurationType

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["expiry_duration_length"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


OnIncrease = Union[
    Literal[
        "bill_immediately",
        "prorate_immediately",
        "prorate_next_cycle",
        "bill_next_cycle",
    ],
    UnrecognizedStr,
]


OnDecrease = Union[
    Literal[
        "prorate",
        "prorate_immediately",
        "prorate_next_cycle",
        "none",
        "no_prorations",
    ],
    UnrecognizedStr,
]


class ProrationTypedDict(TypedDict):
    on_increase: NotRequired[OnIncrease]
    on_decrease: NotRequired[OnDecrease]


class Proration(BaseModel):
    on_increase: Optional[OnIncrease] = None

    on_decrease: Optional[OnDecrease] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["on_increase", "on_decrease"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ItemTypedDict(TypedDict):
    feature_id: str
    included: float
    unlimited: bool
    reset: Nullable[PlanResetTypedDict]
    price: Nullable[ItemPriceTypedDict]
    rollover: NotRequired[PlanRolloverTypedDict]
    proration: NotRequired[ProrationTypedDict]


class Item(BaseModel):
    feature_id: str

    included: float

    unlimited: bool

    reset: Nullable[PlanReset]

    price: Nullable[ItemPrice]

    rollover: Optional[PlanRollover] = None

    proration: Optional[Proration] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rollover", "proration"])
        nullable_fields = set(["reset", "price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


PlanDurationType = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]


class FreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: PlanDurationType
    card_required: bool


class FreeTrial(BaseModel):
    duration_length: float

    duration_type: PlanDurationType

    card_required: bool


PlanEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]


Scenario = Union[
    Literal[
        "scheduled",
        "active",
        "new",
        "renew",
        "upgrade",
        "downgrade",
        "cancel",
        "expired",
        "past_due",
    ],
    UnrecognizedStr,
]


class CustomerEligibilityTypedDict(TypedDict):
    scenario: Scenario
    trial_available: NotRequired[bool]


class CustomerEligibility(BaseModel):
    scenario: Scenario

    trial_available: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["trial_available"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PlanTypedDict(TypedDict):
    name: str
    description: Nullable[str]
    group: Nullable[str]
    version: float
    add_on: bool
    auto_enable: bool
    price: Nullable[PlanPriceTypedDict]
    items: List[ItemTypedDict]
    env: PlanEnv
    archived: bool
    base_variant_id: Nullable[str]
    free_trial: NotRequired[FreeTrialTypedDict]
    customer_eligibility: NotRequired[CustomerEligibilityTypedDict]


class Plan(BaseModel):
    name: str

    description: Nullable[str]

    group: Nullable[str]

    version: float

    add_on: bool

    auto_enable: bool

    price: Nullable[PlanPrice]

    items: List[Item]

    env: PlanEnv

    archived: bool

    base_variant_id: Nullable[str]

    free_trial: Optional[FreeTrial] = None

    customer_eligibility: Optional[CustomerEligibility] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["free_trial", "customer_eligibility"])
        nullable_fields = set(["description", "group", "price", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
