"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import NotRequired, TypeAliasType, TypedDict


PlanPriceInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval (e.g. 'month', 'year')."""


class PlanPriceDisplayTypedDict(TypedDict):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class PlanPriceDisplay(BaseModel):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PlanPriceTypedDict(TypedDict):
    amount: float
    r"""Base price amount for the plan."""
    interval: PlanPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    display: NotRequired[PlanPriceDisplayTypedDict]
    r"""Display text for showing this price in pricing pages."""


class PlanPrice(BaseModel):
    amount: float
    r"""Base price amount for the plan."""

    interval: PlanPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    display: Optional[PlanPriceDisplay] = None
    r"""Display text for showing this price in pricing pages."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PlanType = Union[
    Literal[
        "static",
        "boolean",
        "single_use",
        "continuous_use",
        "credit_system",
    ],
    UnrecognizedStr,
]
r"""The type of the feature"""


class PlanFeatureDisplayTypedDict(TypedDict):
    singular: str
    r"""The singular display name for the feature."""
    plural: str
    r"""The plural display name for the feature."""


class PlanFeatureDisplay(BaseModel):
    singular: str
    r"""The singular display name for the feature."""

    plural: str
    r"""The plural display name for the feature."""


class PlanCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""
    credit_cost: float
    r"""The credit cost of the metered feature."""


class PlanCreditSchema(BaseModel):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""

    credit_cost: float
    r"""The credit cost of the metered feature."""


class PlanFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""
    type: PlanType
    r"""The type of the feature"""
    name: NotRequired[Nullable[str]]
    r"""The name of the feature."""
    display: NotRequired[Nullable[PlanFeatureDisplayTypedDict]]
    r"""Singular and plural display names for the feature."""
    credit_schema: NotRequired[Nullable[List[PlanCreditSchemaTypedDict]]]
    r"""Credit cost schema for credit system features."""
    archived: NotRequired[Nullable[bool]]
    r"""Whether or not the feature is archived."""


class PlanFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""

    type: PlanType
    r"""The type of the feature"""

    name: OptionalNullable[str] = UNSET
    r"""The name of the feature."""

    display: OptionalNullable[PlanFeatureDisplay] = UNSET
    r"""Singular and plural display names for the feature."""

    credit_schema: OptionalNullable[List[PlanCreditSchema]] = UNSET
    r"""Credit cost schema for credit system features."""

    archived: OptionalNullable[bool] = UNSET
    r"""Whether or not the feature is archived."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "display", "credit_schema", "archived"])
        nullable_fields = set(["name", "display", "credit_schema", "archived"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


PlanResetInterval = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""


class PlanResetTypedDict(TypedDict):
    interval: PlanResetInterval
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class PlanReset(BaseModel):
    interval: PlanResetInterval
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PlanToTypedDict = TypeAliasType("PlanToTypedDict", Union[float, str])


PlanTo = TypeAliasType("PlanTo", Union[float, str])


class PlanTierTypedDict(TypedDict):
    to: PlanToTypedDict
    amount: float


class PlanTier(BaseModel):
    to: PlanTo

    amount: float


PlanPriceItemInterval = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval for this price. For consumable features, should match reset.interval."""


PlanBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""


class PlanItemPriceTypedDict(TypedDict):
    interval: PlanPriceItemInterval
    r"""Billing interval for this price. For consumable features, should match reset.interval."""
    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""
    billing_method: PlanBillingMethod
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""
    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""
    tiers: NotRequired[List[PlanTierTypedDict]]
    r"""Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class PlanItemPrice(BaseModel):
    interval: PlanPriceItemInterval
    r"""Billing interval for this price. For consumable features, should match reset.interval."""

    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""

    billing_method: PlanBillingMethod
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""

    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""

    tiers: Optional[List[PlanTier]] = None
    r"""Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers", "interval_count"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PlanItemDisplayTypedDict(TypedDict):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class PlanItemDisplay(BaseModel):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ExpiryDurationType = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]
r"""When rolled over units expire."""


class PlanRolloverTypedDict(TypedDict):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""
    expiry_duration_type: ExpiryDurationType
    r"""When rolled over units expire."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class PlanRollover(BaseModel):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""

    expiry_duration_type: ExpiryDurationType
    r"""When rolled over units expire."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["expiry_duration_length"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ItemTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature this item configures."""
    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""
    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""
    reset: Nullable[PlanResetTypedDict]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""
    price: Nullable[PlanItemPriceTypedDict]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""
    feature: NotRequired[PlanFeatureTypedDict]
    r"""The full feature object if expanded."""
    display: NotRequired[PlanItemDisplayTypedDict]
    r"""Display text for showing this item in pricing pages."""
    rollover: NotRequired[PlanRolloverTypedDict]
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""


class Item(BaseModel):
    feature_id: str
    r"""The ID of the feature this item configures."""

    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""

    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""

    reset: Nullable[PlanReset]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""

    price: Nullable[PlanItemPrice]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""

    feature: Optional[PlanFeature] = None
    r"""The full feature object if expanded."""

    display: Optional[PlanItemDisplay] = None
    r"""Display text for showing this item in pricing pages."""

    rollover: Optional[PlanRollover] = None
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "display", "rollover"])
        nullable_fields = set(["reset", "price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


PlanDurationType = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""Unit of time for the trial duration ('day', 'month', 'year')."""


class FreeTrialTypedDict(TypedDict):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: PlanDurationType
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""
    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


class FreeTrial(BaseModel):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: PlanDurationType
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""

    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


PlanEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""Environment this plan belongs to ('sandbox' or 'live')."""


class PlanTypedDict(TypedDict):
    id: str
    r"""Unique identifier for the plan."""
    name: str
    r"""Display name of the plan."""
    description: Nullable[str]
    r"""Optional description of the plan."""
    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""
    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""
    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""
    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""
    price: Nullable[PlanPriceTypedDict]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""
    items: List[ItemTypedDict]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""
    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""
    env: PlanEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""
    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""
    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""
    free_trial: NotRequired[FreeTrialTypedDict]
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""


class Plan(BaseModel):
    id: str
    r"""Unique identifier for the plan."""

    name: str
    r"""Display name of the plan."""

    description: Nullable[str]
    r"""Optional description of the plan."""

    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""

    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""

    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""

    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""

    price: Nullable[PlanPrice]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""

    items: List[Item]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""

    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""

    env: PlanEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""

    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""

    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""

    free_trial: Optional[FreeTrial] = None
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["free_trial"])
        nullable_fields = set(["description", "group", "price", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
