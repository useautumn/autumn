"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class UpdatePlanGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class UpdatePlanGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanPriceIntervalRequest = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval (e.g. 'month', 'year')."""


class UpdatePlanPriceRequestTypedDict(TypedDict):
    amount: float
    r"""Base price amount for the plan."""
    interval: UpdatePlanPriceIntervalRequest
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class UpdatePlanPriceRequest(BaseModel):
    amount: float
    r"""Base price amount for the plan."""

    interval: UpdatePlanPriceIntervalRequest
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanResetIntervalRequest = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""


class UpdatePlanResetRequestTypedDict(TypedDict):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: UpdatePlanResetIntervalRequest
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class UpdatePlanResetRequest(BaseModel):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: UpdatePlanResetIntervalRequest
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanToRequestTypedDict = TypeAliasType(
    "UpdatePlanToRequestTypedDict", Union[float, str]
)


UpdatePlanToRequest = TypeAliasType("UpdatePlanToRequest", Union[float, str])


class UpdatePlanTierRequestTypedDict(TypedDict):
    to: UpdatePlanToRequestTypedDict
    amount: float


class UpdatePlanTierRequest(BaseModel):
    to: UpdatePlanToRequest

    amount: float


UpdatePlanItemPriceIntervalRequest = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval. For consumable features, should match reset.interval."""


UpdatePlanBillingMethodRequest = Literal[
    "prepaid",
    "usage_based",
]
r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""


class UpdatePlanItemPriceRequestTypedDict(TypedDict):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: UpdatePlanItemPriceIntervalRequest
    r"""Billing interval. For consumable features, should match reset.interval."""
    billing_method: UpdatePlanBillingMethodRequest
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""
    tiers: NotRequired[List[UpdatePlanTierRequestTypedDict]]
    r"""Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    billing_units: NotRequired[float]
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""
    max_purchase: NotRequired[float]
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""


class UpdatePlanItemPriceRequest(BaseModel):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: UpdatePlanItemPriceIntervalRequest
    r"""Billing interval. For consumable features, should match reset.interval."""

    billing_method: UpdatePlanBillingMethodRequest
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""

    tiers: Optional[List[UpdatePlanTierRequest]] = None
    r"""Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required."""

    interval_count: Optional[float] = 1
    r"""Number of intervals per billing cycle. Defaults to 1."""

    billing_units: Optional[float] = 1
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""

    max_purchase: Optional[float] = None
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]
r"""Billing behavior when quantity increases mid-cycle."""


UpdatePlanOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]
r"""Credit behavior when quantity decreases mid-cycle."""


class UpdatePlanProrationTypedDict(TypedDict):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: UpdatePlanOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""
    on_decrease: UpdatePlanOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


class UpdatePlanProration(BaseModel):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: UpdatePlanOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""

    on_decrease: UpdatePlanOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


UpdatePlanExpiryDurationTypeRequest = Literal[
    "month",
    "forever",
]
r"""When rolled over units expire."""


class UpdatePlanRolloverRequestTypedDict(TypedDict):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: UpdatePlanExpiryDurationTypeRequest
    r"""When rolled over units expire."""
    max: NotRequired[float]
    r"""Max rollover units. Omit for unlimited rollover."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class UpdatePlanRolloverRequest(BaseModel):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: UpdatePlanExpiryDurationTypeRequest
    r"""When rolled over units expire."""

    max: Optional[float] = None
    r"""Max rollover units. Omit for unlimited rollover."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdatePlanItemRequestTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature to configure."""
    included: NotRequired[float]
    r"""Number of free units included. Balance resets to this each interval for consumable features."""
    unlimited: NotRequired[bool]
    r"""If true, customer has unlimited access to this feature."""
    reset: NotRequired[UpdatePlanResetRequestTypedDict]
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""
    price: NotRequired[UpdatePlanItemPriceRequestTypedDict]
    r"""Pricing for usage beyond included units. Omit for free features."""
    proration: NotRequired[UpdatePlanProrationTypedDict]
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""
    rollover: NotRequired[UpdatePlanRolloverRequestTypedDict]
    r"""Rollover config for unused units. If set, unused included units carry over."""


class UpdatePlanItemRequest(BaseModel):
    feature_id: str
    r"""The ID of the feature to configure."""

    included: Optional[float] = None
    r"""Number of free units included. Balance resets to this each interval for consumable features."""

    unlimited: Optional[bool] = None
    r"""If true, customer has unlimited access to this feature."""

    reset: Optional[UpdatePlanResetRequest] = None
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    price: Optional[UpdatePlanItemPriceRequest] = None
    r"""Pricing for usage beyond included units. Omit for free features."""

    proration: Optional[UpdatePlanProration] = None
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    rollover: Optional[UpdatePlanRolloverRequest] = None
    r"""Rollover config for unused units. If set, unused included units carry over."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanDurationTypeRequest = Literal[
    "day",
    "month",
    "year",
]
r"""Unit of time for the trial ('day', 'month', 'year')."""


class UpdatePlanFreeTrialRequestTypedDict(TypedDict):
    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: NotRequired[UpdatePlanDurationTypeRequest]
    r"""Unit of time for the trial ('day', 'month', 'year')."""
    card_required: NotRequired[bool]
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""


class UpdatePlanFreeTrialRequest(BaseModel):
    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: Optional[UpdatePlanDurationTypeRequest] = "month"
    r"""Unit of time for the trial ('day', 'month', 'year')."""

    card_required: Optional[bool] = True
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdatePlanParamsTypedDict(TypedDict):
    plan_id: str
    r"""The ID of the plan to update."""
    group: NotRequired[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""
    name: NotRequired[str]
    r"""Display name of the plan."""
    description: NotRequired[str]
    add_on: NotRequired[bool]
    r"""Whether the plan is an add-on."""
    auto_enable: NotRequired[bool]
    r"""Whether the plan is automatically enabled."""
    price: NotRequired[Nullable[UpdatePlanPriceRequestTypedDict]]
    r"""The price of the plan. Set to null to remove the base price."""
    items: NotRequired[List[UpdatePlanItemRequestTypedDict]]
    r"""Feature configurations for this plan. Each item defines included units, pricing, and reset behavior."""
    free_trial: NotRequired[Nullable[UpdatePlanFreeTrialRequestTypedDict]]
    r"""The free trial of the plan. Set to null to remove the free trial."""
    version: NotRequired[float]
    archived: NotRequired[bool]
    new_plan_id: NotRequired[str]
    r"""The new ID to use for the plan. Can only be updated if the plan has not been used by any customers."""


class UpdatePlanParams(BaseModel):
    plan_id: str
    r"""The ID of the plan to update."""

    group: Optional[str] = ""
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""

    name: Optional[str] = None
    r"""Display name of the plan."""

    description: Optional[str] = None

    add_on: Optional[bool] = None
    r"""Whether the plan is an add-on."""

    auto_enable: Optional[bool] = None
    r"""Whether the plan is automatically enabled."""

    price: OptionalNullable[UpdatePlanPriceRequest] = UNSET
    r"""The price of the plan. Set to null to remove the base price."""

    items: Optional[List[UpdatePlanItemRequest]] = None
    r"""Feature configurations for this plan. Each item defines included units, pricing, and reset behavior."""

    free_trial: OptionalNullable[UpdatePlanFreeTrialRequest] = UNSET
    r"""The free trial of the plan. Set to null to remove the free trial."""

    version: Optional[float] = None

    archived: Optional[bool] = False

    new_plan_id: Optional[str] = None
    r"""The new ID to use for the plan. Can only be updated if the plan has not been used by any customers."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "group",
                "name",
                "description",
                "add_on",
                "auto_enable",
                "price",
                "items",
                "free_trial",
                "version",
                "archived",
                "new_plan_id",
            ]
        )
        nullable_fields = set(["price", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdatePlanPriceIntervalResponse = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval (e.g. 'month', 'year')."""


class UpdatePlanPriceDisplayTypedDict(TypedDict):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class UpdatePlanPriceDisplay(BaseModel):
    r"""Display text for showing this price in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdatePlanPriceResponseTypedDict(TypedDict):
    amount: float
    r"""Base price amount for the plan."""
    interval: UpdatePlanPriceIntervalResponse
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    display: NotRequired[UpdatePlanPriceDisplayTypedDict]
    r"""Display text for showing this price in pricing pages."""


class UpdatePlanPriceResponse(BaseModel):
    amount: float
    r"""Base price amount for the plan."""

    interval: UpdatePlanPriceIntervalResponse
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    display: Optional[UpdatePlanPriceDisplay] = None
    r"""Display text for showing this price in pricing pages."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanType = Union[
    Literal[
        "static",
        "boolean",
        "single_use",
        "continuous_use",
        "credit_system",
    ],
    UnrecognizedStr,
]
r"""The type of the feature"""


class UpdatePlanFeatureDisplayTypedDict(TypedDict):
    singular: str
    r"""The singular display name for the feature."""
    plural: str
    r"""The plural display name for the feature."""


class UpdatePlanFeatureDisplay(BaseModel):
    singular: str
    r"""The singular display name for the feature."""

    plural: str
    r"""The plural display name for the feature."""


class UpdatePlanCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""
    credit_cost: float
    r"""The credit cost of the metered feature."""


class UpdatePlanCreditSchema(BaseModel):
    metered_feature_id: str
    r"""The ID of the metered feature (should be a single_use feature)."""

    credit_cost: float
    r"""The credit cost of the metered feature."""


class UpdatePlanFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""
    type: UpdatePlanType
    r"""The type of the feature"""
    name: NotRequired[Nullable[str]]
    r"""The name of the feature."""
    display: NotRequired[Nullable[UpdatePlanFeatureDisplayTypedDict]]
    r"""Singular and plural display names for the feature."""
    credit_schema: NotRequired[Nullable[List[UpdatePlanCreditSchemaTypedDict]]]
    r"""Credit cost schema for credit system features."""
    archived: NotRequired[Nullable[bool]]
    r"""Whether or not the feature is archived."""


class UpdatePlanFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str
    r"""The ID of the feature, used to refer to it in other API calls like /track or /check."""

    type: UpdatePlanType
    r"""The type of the feature"""

    name: OptionalNullable[str] = UNSET
    r"""The name of the feature."""

    display: OptionalNullable[UpdatePlanFeatureDisplay] = UNSET
    r"""Singular and plural display names for the feature."""

    credit_schema: OptionalNullable[List[UpdatePlanCreditSchema]] = UNSET
    r"""Credit cost schema for credit system features."""

    archived: OptionalNullable[bool] = UNSET
    r"""Whether or not the feature is archived."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "display", "credit_schema", "archived"])
        nullable_fields = set(["name", "display", "credit_schema", "archived"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdatePlanResetIntervalResponse = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""


class UpdatePlanResetResponseTypedDict(TypedDict):
    interval: UpdatePlanResetIntervalResponse
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class UpdatePlanResetResponse(BaseModel):
    interval: UpdatePlanResetIntervalResponse
    r"""The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanToResponseTypedDict = TypeAliasType(
    "UpdatePlanToResponseTypedDict", Union[float, str]
)


UpdatePlanToResponse = TypeAliasType("UpdatePlanToResponse", Union[float, str])


class UpdatePlanTierResponseTypedDict(TypedDict):
    to: UpdatePlanToResponseTypedDict
    amount: float


class UpdatePlanTierResponse(BaseModel):
    to: UpdatePlanToResponse

    amount: float


UpdatePlanPriceItemIntervalResponse = Union[
    Literal[
        "one_off",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]
r"""Billing interval for this price. For consumable features, should match reset.interval."""


UpdatePlanBillingMethodResponse = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""


class UpdatePlanItemPriceResponseTypedDict(TypedDict):
    interval: UpdatePlanPriceItemIntervalResponse
    r"""Billing interval for this price. For consumable features, should match reset.interval."""
    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""
    billing_method: UpdatePlanBillingMethodResponse
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""
    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""
    tiers: NotRequired[List[UpdatePlanTierResponseTypedDict]]
    r"""Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class UpdatePlanItemPriceResponse(BaseModel):
    interval: UpdatePlanPriceItemIntervalResponse
    r"""Billing interval for this price. For consumable features, should match reset.interval."""

    billing_units: float
    r"""Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200)."""

    billing_method: UpdatePlanBillingMethodResponse
    r"""'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage."""

    max_purchase: Nullable[float]
    r"""Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage is consumed. Mutually exclusive with tiers."""

    tiers: Optional[List[UpdatePlanTierResponse]] = None
    r"""Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers", "interval_count"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class UpdatePlanItemDisplayTypedDict(TypedDict):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""
    secondary_text: NotRequired[str]
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""


class UpdatePlanItemDisplay(BaseModel):
    r"""Display text for showing this item in pricing pages."""

    primary_text: str
    r"""Main display text (e.g. '$10' or '100 messages')."""

    secondary_text: Optional[str] = None
    r"""Secondary display text (e.g. 'per month' or 'then $0.5 per 100')."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdatePlanExpiryDurationTypeResponse = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]
r"""When rolled over units expire."""


class UpdatePlanRolloverResponseTypedDict(TypedDict):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""
    expiry_duration_type: UpdatePlanExpiryDurationTypeResponse
    r"""When rolled over units expire."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class UpdatePlanRolloverResponse(BaseModel):
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    max: Nullable[float]
    r"""Maximum rollover units. Null for unlimited rollover."""

    expiry_duration_type: UpdatePlanExpiryDurationTypeResponse
    r"""When rolled over units expire."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["expiry_duration_length"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class UpdatePlanItemResponseTypedDict(TypedDict):
    feature_id: str
    r"""The ID of the feature this item configures."""
    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""
    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""
    reset: Nullable[UpdatePlanResetResponseTypedDict]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""
    price: Nullable[UpdatePlanItemPriceResponseTypedDict]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""
    feature: NotRequired[UpdatePlanFeatureTypedDict]
    r"""The full feature object if expanded."""
    display: NotRequired[UpdatePlanItemDisplayTypedDict]
    r"""Display text for showing this item in pricing pages."""
    rollover: NotRequired[UpdatePlanRolloverResponseTypedDict]
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""


class UpdatePlanItemResponse(BaseModel):
    feature_id: str
    r"""The ID of the feature this item configures."""

    included: float
    r"""Number of free units included. For consumable features, balance resets to this number each interval."""

    unlimited: bool
    r"""Whether the customer has unlimited access to this feature."""

    reset: Nullable[UpdatePlanResetResponse]
    r"""Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles."""

    price: Nullable[UpdatePlanItemPriceResponse]
    r"""Pricing configuration for usage beyond included units. Null if feature is entirely free."""

    feature: Optional[UpdatePlanFeature] = None
    r"""The full feature object if expanded."""

    display: Optional[UpdatePlanItemDisplay] = None
    r"""Display text for showing this item in pricing pages."""

    rollover: Optional[UpdatePlanRolloverResponse] = None
    r"""Rollover configuration for unused units. If set, unused included units roll over to the next period."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "display", "rollover"])
        nullable_fields = set(["reset", "price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdatePlanDurationTypeResponse = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""Unit of time for the trial duration ('day', 'month', 'year')."""


class UpdatePlanFreeTrialResponseTypedDict(TypedDict):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: UpdatePlanDurationTypeResponse
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""
    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


class UpdatePlanFreeTrialResponse(BaseModel):
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: UpdatePlanDurationTypeResponse
    r"""Unit of time for the trial duration ('day', 'month', 'year')."""

    card_required: bool
    r"""Whether a payment method is required to start the trial. If true, customer will be charged after trial ends."""


UpdatePlanEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""Environment this plan belongs to ('sandbox' or 'live')."""


class UpdatePlanResponseTypedDict(TypedDict):
    r"""A plan defines a set of features, pricing, and entitlements that can be attached to customers."""

    id: str
    r"""Unique identifier for the plan."""
    name: str
    r"""Display name of the plan."""
    description: Nullable[str]
    r"""Optional description of the plan."""
    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""
    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""
    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""
    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""
    price: Nullable[UpdatePlanPriceResponseTypedDict]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""
    items: List[UpdatePlanItemResponseTypedDict]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""
    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""
    env: UpdatePlanEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""
    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""
    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""
    free_trial: NotRequired[UpdatePlanFreeTrialResponseTypedDict]
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""


class UpdatePlanResponse(BaseModel):
    r"""A plan defines a set of features, pricing, and entitlements that can be attached to customers."""

    id: str
    r"""Unique identifier for the plan."""

    name: str
    r"""Display name of the plan."""

    description: Nullable[str]
    r"""Optional description of the plan."""

    group: Nullable[str]
    r"""Group identifier for organizing related plans. Plans in the same group are mutually exclusive."""

    version: float
    r"""Version number of the plan. Incremented when plan configuration changes."""

    add_on: bool
    r"""Whether this is an add-on plan that can be attached alongside a main plan."""

    auto_enable: bool
    r"""If true, this plan is automatically attached when a customer is created. Used for free plans."""

    price: Nullable[UpdatePlanPriceResponse]
    r"""Base recurring price for the plan. Null for free plans or usage-only plans."""

    items: List[UpdatePlanItemResponse]
    r"""Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature."""

    created_at: float
    r"""Unix timestamp (ms) when the plan was created."""

    env: UpdatePlanEnv
    r"""Environment this plan belongs to ('sandbox' or 'live')."""

    archived: bool
    r"""Whether the plan is archived. Archived plans cannot be attached to new customers."""

    base_variant_id: Nullable[str]
    r"""If this is a variant, the ID of the base plan it was created from."""

    free_trial: Optional[UpdatePlanFreeTrialResponse] = None
    r"""Free trial configuration. If set, new customers can try this plan before being charged."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["free_trial"])
        nullable_fields = set(["description", "group", "price", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
