"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CheckGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class CheckGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CheckParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer."""
    feature_id: str
    r"""The ID of the feature."""
    entity_id: NotRequired[str]
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""
    required_balance: NotRequired[float]
    r"""Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1."""
    properties: NotRequired[Dict[str, Any]]
    r"""Additional properties to attach to the usage event if send_event is true."""
    send_event: NotRequired[bool]
    r"""If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call."""
    with_preview: NotRequired[bool]
    r"""If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls."""


class CheckParams(BaseModel):
    customer_id: str
    r"""The ID of the customer."""

    feature_id: str
    r"""The ID of the feature."""

    entity_id: Optional[str] = None
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""

    required_balance: Optional[float] = None
    r"""Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1."""

    properties: Optional[Dict[str, Any]] = None
    r"""Additional properties to attach to the usage event if send_event is true."""

    send_event: Optional[bool] = None
    r"""If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call."""

    with_preview: Optional[bool] = None
    r"""If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "required_balance",
                "properties",
                "send_event",
                "with_preview",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CheckBalanceType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class CheckCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class CheckCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class CheckBalanceDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class CheckBalanceDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CheckFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    name: str
    type: CheckBalanceType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[CheckCreditSchemaTypedDict]]
    display: NotRequired[CheckBalanceDisplayTypedDict]


class CheckFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str

    name: str

    type: CheckBalanceType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[CheckCreditSchema]] = None

    display: Optional[CheckBalanceDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CheckBalanceIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


CheckIntervalUnionTypedDict = TypeAliasType(
    "CheckIntervalUnionTypedDict", Union[CheckBalanceIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


CheckIntervalUnion = TypeAliasType(
    "CheckIntervalUnion", Union[CheckBalanceIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


class CheckResetTypedDict(TypedDict):
    interval: CheckIntervalUnionTypedDict
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""
    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""


class CheckReset(BaseModel):
    interval: CheckIntervalUnion
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""

    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CheckBalanceToTypedDict = TypeAliasType("CheckBalanceToTypedDict", Union[float, str])


CheckBalanceTo = TypeAliasType("CheckBalanceTo", Union[float, str])


class CheckTierTypedDict(TypedDict):
    to: CheckBalanceToTypedDict
    amount: float


class CheckTier(BaseModel):
    to: CheckBalanceTo

    amount: float


CheckBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""Whether usage is prepaid or billed pay-per-use."""


class CheckPriceTypedDict(TypedDict):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""
    billing_method: CheckBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""
    amount: NotRequired[float]
    r"""The per-unit price amount."""
    tiers: NotRequired[List[CheckTierTypedDict]]
    r"""Tiered pricing configuration if applicable."""


class CheckPrice(BaseModel):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""

    billing_method: CheckBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""

    amount: Optional[float] = None
    r"""The per-unit price amount."""

    tiers: Optional[List[CheckTier]] = None
    r"""Tiered pricing configuration if applicable."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CheckBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""
    included_grant: float
    r"""Amount granted from the plan's included usage."""
    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Amount consumed in the current period."""
    unlimited: bool
    r"""Whether this balance has unlimited usage."""
    reset: Nullable[CheckResetTypedDict]
    r"""Reset configuration for this balance, or null if no reset."""
    price: Nullable[CheckPriceTypedDict]
    r"""Pricing configuration if this balance has usage-based pricing."""
    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""
    id: NotRequired[str]
    r"""The unique identifier for this balance breakdown."""


class CheckBreakdown(BaseModel):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""

    included_grant: float
    r"""Amount granted from the plan's included usage."""

    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Amount consumed in the current period."""

    unlimited: bool
    r"""Whether this balance has unlimited usage."""

    reset: Nullable[CheckReset]
    r"""Reset configuration for this balance, or null if no reset."""

    price: Nullable[CheckPrice]
    r"""Pricing configuration if this balance has usage-based pricing."""

    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""

    id: Optional[str] = ""
    r"""The unique identifier for this balance breakdown."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CheckBalanceRolloverTypedDict(TypedDict):
    balance: float
    r"""Amount of balance rolled over from a previous period."""
    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class CheckBalanceRollover(BaseModel):
    balance: float
    r"""Amount of balance rolled over from a previous period."""

    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class CheckBalanceTypedDict(TypedDict):
    feature_id: str
    r"""The feature ID this balance is for."""
    granted: float
    r"""Total balance granted (included + prepaid)."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Total usage consumed in the current period."""
    unlimited: bool
    r"""Whether this feature has unlimited usage."""
    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""
    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""
    feature: NotRequired[CheckFeatureTypedDict]
    r"""The full feature object if expanded."""
    breakdown: NotRequired[List[CheckBreakdownTypedDict]]
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""
    rollovers: NotRequired[List[CheckBalanceRolloverTypedDict]]
    r"""Rollover balances carried over from previous periods."""


class CheckBalance(BaseModel):
    feature_id: str
    r"""The feature ID this balance is for."""

    granted: float
    r"""Total balance granted (included + prepaid)."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Total usage consumed in the current period."""

    unlimited: bool
    r"""Whether this feature has unlimited usage."""

    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""

    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""

    feature: Optional[CheckFeature] = None
    r"""The full feature object if expanded."""

    breakdown: Optional[List[CheckBreakdown]] = None
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""

    rollovers: Optional[List[CheckBalanceRollover]] = None
    r"""Rollover balances carried over from previous periods."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CheckScenario = Union[
    Literal[
        "usage_limit",
        "feature_flag",
    ],
    UnrecognizedStr,
]
r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""


CheckEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment of the product"""


ProductType = Union[
    Literal[
        "feature",
        "priced_feature",
        "price",
    ],
    UnrecognizedStr,
]


FeatureType = Union[
    Literal[
        "single_use",
        "continuous_use",
        "boolean",
        "static",
    ],
    UnrecognizedStr,
]


IncludedUsageTypedDict = TypeAliasType("IncludedUsageTypedDict", Union[float, str])


IncludedUsage = TypeAliasType("IncludedUsage", Union[float, str])


ProductInterval = Union[
    Literal[
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


TiersToTypedDict = TypeAliasType("TiersToTypedDict", Union[float, str])
r"""The maximum amount of usage for this tier."""


TiersTo = TypeAliasType("TiersTo", Union[float, str])
r"""The maximum amount of usage for this tier."""


class TiersTypedDict(TypedDict):
    to: TiersToTypedDict
    r"""The maximum amount of usage for this tier."""
    amount: float
    r"""The price of the product item for this tier."""


class Tiers(BaseModel):
    to: TiersTo
    r"""The maximum amount of usage for this tier."""

    amount: float
    r"""The price of the product item for this tier."""


UsageModel = Union[
    Literal[
        "prepaid",
        "pay_per_use",
    ],
    UnrecognizedStr,
]


class ProductDisplayTypedDict(TypedDict):
    primary_text: str
    secondary_text: NotRequired[Nullable[str]]


class ProductDisplay(BaseModel):
    primary_text: str

    secondary_text: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        nullable_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RolloverDuration = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]


class ConfigRolloverTypedDict(TypedDict):
    max: Nullable[float]
    length: float
    duration: NotRequired[RolloverDuration]


class ConfigRollover(BaseModel):
    max: Nullable[float]

    length: float

    duration: Optional[RolloverDuration] = "month"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CheckOnIncrease = Union[
    Literal[
        "bill_immediately",
        "prorate_immediately",
        "prorate_next_cycle",
        "bill_next_cycle",
    ],
    UnrecognizedStr,
]


CheckOnDecrease = Union[
    Literal[
        "prorate",
        "prorate_immediately",
        "prorate_next_cycle",
        "none",
        "no_prorations",
    ],
    UnrecognizedStr,
]


class ConfigTypedDict(TypedDict):
    rollover: NotRequired[Nullable[ConfigRolloverTypedDict]]
    on_increase: NotRequired[Nullable[CheckOnIncrease]]
    on_decrease: NotRequired[Nullable[CheckOnDecrease]]


class Config(BaseModel):
    rollover: OptionalNullable[ConfigRollover] = UNSET

    on_increase: OptionalNullable[CheckOnIncrease] = UNSET

    on_decrease: OptionalNullable[CheckOnDecrease] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rollover", "on_increase", "on_decrease"])
        nullable_fields = set(["rollover", "on_increase", "on_decrease"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CheckItemTypedDict(TypedDict):
    r"""Product item defining features and pricing within a product"""

    type: NotRequired[Nullable[ProductType]]
    r"""The type of the product item"""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""
    feature_type: NotRequired[Nullable[FeatureType]]
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""
    included_usage: NotRequired[Nullable[IncludedUsageTypedDict]]
    r"""The amount of usage included for this feature."""
    interval: NotRequired[Nullable[ProductInterval]]
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""
    interval_count: NotRequired[Nullable[float]]
    r"""The interval count of the product item."""
    price: NotRequired[Nullable[float]]
    r"""The price of the product item. Should be `null` if tiered pricing is set."""
    tiers: NotRequired[Nullable[List[TiersTypedDict]]]
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""
    usage_model: NotRequired[Nullable[UsageModel]]
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""
    billing_units: NotRequired[Nullable[float]]
    r"""The amount per billing unit (eg. $9 / 250 units)"""
    reset_usage_when_enabled: NotRequired[Nullable[bool]]
    r"""Whether the usage should be reset when the product is enabled."""
    entity_feature_id: NotRequired[Nullable[str]]
    r"""The entity feature ID of the product item if applicable."""
    display: NotRequired[Nullable[ProductDisplayTypedDict]]
    r"""The display of the product item."""
    quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""
    next_cycle_quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""
    config: NotRequired[Nullable[ConfigTypedDict]]
    r"""Configuration for rollover and proration behavior of the feature."""


class CheckItem(BaseModel):
    r"""Product item defining features and pricing within a product"""

    type: OptionalNullable[ProductType] = UNSET
    r"""The type of the product item"""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""

    feature_type: OptionalNullable[FeatureType] = UNSET
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""

    included_usage: OptionalNullable[IncludedUsage] = UNSET
    r"""The amount of usage included for this feature."""

    interval: OptionalNullable[ProductInterval] = UNSET
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""

    interval_count: OptionalNullable[float] = UNSET
    r"""The interval count of the product item."""

    price: OptionalNullable[float] = UNSET
    r"""The price of the product item. Should be `null` if tiered pricing is set."""

    tiers: OptionalNullable[List[Tiers]] = UNSET
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""

    usage_model: OptionalNullable[UsageModel] = UNSET
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""

    billing_units: OptionalNullable[float] = UNSET
    r"""The amount per billing unit (eg. $9 / 250 units)"""

    reset_usage_when_enabled: OptionalNullable[bool] = UNSET
    r"""Whether the usage should be reset when the product is enabled."""

    entity_feature_id: OptionalNullable[str] = UNSET
    r"""The entity feature ID of the product item if applicable."""

    display: OptionalNullable[ProductDisplay] = UNSET
    r"""The display of the product item."""

    quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""

    next_cycle_quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""

    config: OptionalNullable[Config] = UNSET
    r"""Configuration for rollover and proration behavior of the feature."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        nullable_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


FreeTrialDuration = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""The duration type of the free trial"""


class CheckFreeTrialTypedDict(TypedDict):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""
    length: float
    r"""The length of the duration type specified"""
    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""
    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""
    trial_available: NotRequired[Nullable[bool]]
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""


class CheckFreeTrial(BaseModel):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""

    length: float
    r"""The length of the duration type specified"""

    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""

    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""

    trial_available: OptionalNullable[bool] = True
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["trial_available"])
        nullable_fields = set(["trial_available"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ProductScenario = Union[
    Literal[
        "scheduled",
        "active",
        "new",
        "renew",
        "upgrade",
        "downgrade",
        "cancel",
        "expired",
        "past_due",
    ],
    UnrecognizedStr,
]
r"""Scenario for when this product is used in attach flows"""


class CheckPropertiesTypedDict(TypedDict):
    is_free: bool
    r"""True if the product has no base price or usage prices"""
    is_one_off: bool
    r"""True if the product only contains a one-time price"""
    interval_group: NotRequired[Nullable[str]]
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""
    has_trial: NotRequired[Nullable[bool]]
    r"""True if the product includes a free trial"""
    updateable: NotRequired[Nullable[bool]]
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""


class CheckProperties(BaseModel):
    is_free: bool
    r"""True if the product has no base price or usage prices"""

    is_one_off: bool
    r"""True if the product only contains a one-time price"""

    interval_group: OptionalNullable[str] = UNSET
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""

    has_trial: OptionalNullable[bool] = UNSET
    r"""True if the product includes a free trial"""

    updateable: OptionalNullable[bool] = UNSET
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_group", "has_trial", "updateable"])
        nullable_fields = set(["interval_group", "has_trial", "updateable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ProductTypedDict(TypedDict):
    id: str
    r"""The ID of the product you set when creating the product"""
    name: str
    r"""The name of the product"""
    group: Nullable[str]
    r"""Product group which this product belongs to"""
    env: CheckEnv
    r"""The environment of the product"""
    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""
    is_default: bool
    r"""Whether the product is the default product"""
    archived: bool
    r"""Whether this product has been archived and is no longer available"""
    version: float
    r"""The current version of the product"""
    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""
    items: List[CheckItemTypedDict]
    r"""Array of product items that define the product's features and pricing"""
    free_trial: Nullable[CheckFreeTrialTypedDict]
    r"""Free trial configuration for this product, if available"""
    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""
    scenario: NotRequired[ProductScenario]
    r"""Scenario for when this product is used in attach flows"""
    properties: NotRequired[CheckPropertiesTypedDict]


class Product(BaseModel):
    id: str
    r"""The ID of the product you set when creating the product"""

    name: str
    r"""The name of the product"""

    group: Nullable[str]
    r"""Product group which this product belongs to"""

    env: CheckEnv
    r"""The environment of the product"""

    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""

    is_default: bool
    r"""Whether the product is the default product"""

    archived: bool
    r"""Whether this product has been archived and is no longer available"""

    version: float
    r"""The current version of the product"""

    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""

    items: List[CheckItem]
    r"""Array of product items that define the product's features and pricing"""

    free_trial: Nullable[CheckFreeTrial]
    r"""Free trial configuration for this product, if available"""

    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""

    scenario: Optional[ProductScenario] = None
    r"""Scenario for when this product is used in attach flows"""

    properties: Optional[CheckProperties] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["scenario", "properties"])
        nullable_fields = set(["group", "free_trial", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewTypedDict(TypedDict):
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    scenario: CheckScenario
    r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""
    title: str
    r"""A title suitable for displaying in a paywall or upgrade modal."""
    message: str
    r"""A message explaining why access was denied."""
    feature_id: str
    r"""The ID of the feature that was checked."""
    feature_name: str
    r"""The display name of the feature."""
    products: List[ProductTypedDict]
    r"""Products that would grant access to this feature. Use to display upgrade options."""


class Preview(BaseModel):
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    scenario: CheckScenario
    r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""

    title: str
    r"""A title suitable for displaying in a paywall or upgrade modal."""

    message: str
    r"""A message explaining why access was denied."""

    feature_id: str
    r"""The ID of the feature that was checked."""

    feature_name: str
    r"""The display name of the feature."""

    products: List[Product]
    r"""Products that would grant access to this feature. Use to display upgrade options."""


class CheckResponseTypedDict(TypedDict):
    r"""OK"""

    allowed: bool
    r"""Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean."""
    customer_id: str
    r"""The ID of the customer that was checked."""
    balance: Nullable[CheckBalanceTypedDict]
    r"""The customer's balance for this feature. Null if the customer has no balance for this feature."""
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity, if an entity-scoped check was performed."""
    required_balance: NotRequired[float]
    r"""The required balance that was checked against."""
    preview: NotRequired[PreviewTypedDict]
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""


class CheckResponse(BaseModel):
    r"""OK"""

    allowed: bool
    r"""Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean."""

    customer_id: str
    r"""The ID of the customer that was checked."""

    balance: Nullable[CheckBalance]
    r"""The customer's balance for this feature. Null if the customer has no balance for this feature."""

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity, if an entity-scoped check was performed."""

    required_balance: Optional[float] = None
    r"""The required balance that was checked against."""

    preview: Optional[Preview] = None
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "required_balance", "preview"])
        nullable_fields = set(["entity_id", "balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
