"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .balance import Balance, BalanceTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CheckGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class CheckGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CheckParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer."""
    feature_id: str
    r"""The ID of the feature."""
    entity_id: NotRequired[str]
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""
    required_balance: NotRequired[float]
    r"""Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1."""
    properties: NotRequired[Dict[str, Any]]
    r"""Additional properties to attach to the usage event if send_event is true."""
    send_event: NotRequired[bool]
    r"""If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call."""
    with_preview: NotRequired[bool]
    r"""If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls."""


class CheckParams(BaseModel):
    customer_id: str
    r"""The ID of the customer."""

    feature_id: str
    r"""The ID of the feature."""

    entity_id: Optional[str] = None
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""

    required_balance: Optional[float] = None
    r"""Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1."""

    properties: Optional[Dict[str, Any]] = None
    r"""Additional properties to attach to the usage event if send_event is true."""

    send_event: Optional[bool] = None
    r"""If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call."""

    with_preview: Optional[bool] = None
    r"""If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "required_balance",
                "properties",
                "send_event",
                "with_preview",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CheckScenario = Union[
    Literal[
        "usage_limit",
        "feature_flag",
    ],
    UnrecognizedStr,
]
r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""


CheckEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment of the product"""


CheckType = Union[
    Literal[
        "feature",
        "priced_feature",
        "price",
    ],
    UnrecognizedStr,
]


FeatureType = Union[
    Literal[
        "single_use",
        "continuous_use",
        "boolean",
        "static",
    ],
    UnrecognizedStr,
]


IncludedUsageTypedDict = TypeAliasType("IncludedUsageTypedDict", Union[float, str])


IncludedUsage = TypeAliasType("IncludedUsage", Union[float, str])


CheckInterval = Union[
    Literal[
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


CheckToTypedDict = TypeAliasType("CheckToTypedDict", Union[float, str])
r"""The maximum amount of usage for this tier."""


CheckTo = TypeAliasType("CheckTo", Union[float, str])
r"""The maximum amount of usage for this tier."""


class TiersTypedDict(TypedDict):
    to: CheckToTypedDict
    r"""The maximum amount of usage for this tier."""
    amount: float
    r"""The price of the product item for this tier."""
    flat_amount: NotRequired[Nullable[float]]
    r"""A flat fee charged for this tier, in addition to the per-unit amount."""


class Tiers(BaseModel):
    to: CheckTo
    r"""The maximum amount of usage for this tier."""

    amount: float
    r"""The price of the product item for this tier."""

    flat_amount: OptionalNullable[float] = UNSET
    r"""A flat fee charged for this tier, in addition to the per-unit amount."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["flat_amount"])
        nullable_fields = set(["flat_amount"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CheckTierBehavior = Union[
    Literal[
        "graduated",
        "volume",
    ],
    UnrecognizedStr,
]


UsageModel = Union[
    Literal[
        "prepaid",
        "pay_per_use",
    ],
    UnrecognizedStr,
]


class CheckDisplayTypedDict(TypedDict):
    primary_text: str
    secondary_text: NotRequired[Nullable[str]]


class CheckDisplay(BaseModel):
    primary_text: str

    secondary_text: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        nullable_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RolloverDuration = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]


class CheckRolloverTypedDict(TypedDict):
    max: Nullable[float]
    length: float
    duration: NotRequired[RolloverDuration]


class CheckRollover(BaseModel):
    max: Nullable[float]

    length: float

    duration: Optional[RolloverDuration] = "month"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CheckOnIncrease = Union[
    Literal[
        "bill_immediately",
        "prorate_immediately",
        "prorate_next_cycle",
        "bill_next_cycle",
    ],
    UnrecognizedStr,
]


CheckOnDecrease = Union[
    Literal[
        "prorate",
        "prorate_immediately",
        "prorate_next_cycle",
        "none",
        "no_prorations",
    ],
    UnrecognizedStr,
]


class ConfigTypedDict(TypedDict):
    rollover: NotRequired[Nullable[CheckRolloverTypedDict]]
    on_increase: NotRequired[Nullable[CheckOnIncrease]]
    on_decrease: NotRequired[Nullable[CheckOnDecrease]]


class Config(BaseModel):
    rollover: OptionalNullable[CheckRollover] = UNSET

    on_increase: OptionalNullable[CheckOnIncrease] = UNSET

    on_decrease: OptionalNullable[CheckOnDecrease] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rollover", "on_increase", "on_decrease"])
        nullable_fields = set(["rollover", "on_increase", "on_decrease"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CheckItemTypedDict(TypedDict):
    r"""Product item defining features and pricing within a product"""

    type: NotRequired[Nullable[CheckType]]
    r"""The type of the product item"""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""
    feature_type: NotRequired[Nullable[FeatureType]]
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""
    included_usage: NotRequired[Nullable[IncludedUsageTypedDict]]
    r"""The amount of usage included for this feature."""
    interval: NotRequired[Nullable[CheckInterval]]
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""
    interval_count: NotRequired[Nullable[float]]
    r"""The interval count of the product item."""
    price: NotRequired[Nullable[float]]
    r"""The price of the product item. Should be `null` if tiered pricing is set."""
    tiers: NotRequired[Nullable[List[TiersTypedDict]]]
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""
    tier_behavior: NotRequired[Nullable[CheckTierBehavior]]
    r"""How tiers are applied: graduated (split across bands) or volume (flat rate for the matched tier). Defaults to graduated."""
    usage_model: NotRequired[Nullable[UsageModel]]
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""
    billing_units: NotRequired[Nullable[float]]
    r"""The amount per billing unit (eg. $9 / 250 units)"""
    reset_usage_when_enabled: NotRequired[Nullable[bool]]
    r"""Whether the usage should be reset when the product is enabled."""
    entity_feature_id: NotRequired[Nullable[str]]
    r"""The entity feature ID of the product item if applicable."""
    display: NotRequired[Nullable[CheckDisplayTypedDict]]
    r"""The display of the product item."""
    quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""
    next_cycle_quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""
    config: NotRequired[Nullable[ConfigTypedDict]]
    r"""Configuration for rollover and proration behavior of the feature."""


class CheckItem(BaseModel):
    r"""Product item defining features and pricing within a product"""

    type: OptionalNullable[CheckType] = UNSET
    r"""The type of the product item"""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""

    feature_type: OptionalNullable[FeatureType] = UNSET
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""

    included_usage: OptionalNullable[IncludedUsage] = UNSET
    r"""The amount of usage included for this feature."""

    interval: OptionalNullable[CheckInterval] = UNSET
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""

    interval_count: OptionalNullable[float] = UNSET
    r"""The interval count of the product item."""

    price: OptionalNullable[float] = UNSET
    r"""The price of the product item. Should be `null` if tiered pricing is set."""

    tiers: OptionalNullable[List[Tiers]] = UNSET
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""

    tier_behavior: OptionalNullable[CheckTierBehavior] = UNSET
    r"""How tiers are applied: graduated (split across bands) or volume (flat rate for the matched tier). Defaults to graduated."""

    usage_model: OptionalNullable[UsageModel] = UNSET
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""

    billing_units: OptionalNullable[float] = UNSET
    r"""The amount per billing unit (eg. $9 / 250 units)"""

    reset_usage_when_enabled: OptionalNullable[bool] = UNSET
    r"""Whether the usage should be reset when the product is enabled."""

    entity_feature_id: OptionalNullable[str] = UNSET
    r"""The entity feature ID of the product item if applicable."""

    display: OptionalNullable[CheckDisplay] = UNSET
    r"""The display of the product item."""

    quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""

    next_cycle_quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""

    config: OptionalNullable[Config] = UNSET
    r"""Configuration for rollover and proration behavior of the feature."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "tier_behavior",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        nullable_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "tier_behavior",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


FreeTrialDuration = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""The duration type of the free trial"""


class CheckFreeTrialTypedDict(TypedDict):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""
    length: float
    r"""The length of the duration type specified"""
    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""
    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""
    trial_available: NotRequired[Nullable[bool]]
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""


class CheckFreeTrial(BaseModel):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""

    length: float
    r"""The length of the duration type specified"""

    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""

    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""

    trial_available: OptionalNullable[bool] = True
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["trial_available"])
        nullable_fields = set(["trial_available"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ProductScenario = Union[
    Literal[
        "scheduled",
        "active",
        "new",
        "renew",
        "upgrade",
        "downgrade",
        "cancel",
        "expired",
        "past_due",
    ],
    UnrecognizedStr,
]
r"""Scenario for when this product is used in attach flows"""


class CheckPropertiesTypedDict(TypedDict):
    is_free: bool
    r"""True if the product has no base price or usage prices"""
    is_one_off: bool
    r"""True if the product only contains a one-time price"""
    interval_group: NotRequired[Nullable[str]]
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""
    has_trial: NotRequired[Nullable[bool]]
    r"""True if the product includes a free trial"""
    updateable: NotRequired[Nullable[bool]]
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""


class CheckProperties(BaseModel):
    is_free: bool
    r"""True if the product has no base price or usage prices"""

    is_one_off: bool
    r"""True if the product only contains a one-time price"""

    interval_group: OptionalNullable[str] = UNSET
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""

    has_trial: OptionalNullable[bool] = UNSET
    r"""True if the product includes a free trial"""

    updateable: OptionalNullable[bool] = UNSET
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_group", "has_trial", "updateable"])
        nullable_fields = set(["interval_group", "has_trial", "updateable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ProductTypedDict(TypedDict):
    id: str
    r"""The ID of the product you set when creating the product"""
    name: str
    r"""The name of the product"""
    group: Nullable[str]
    r"""Product group which this product belongs to"""
    env: CheckEnv
    r"""The environment of the product"""
    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""
    is_default: bool
    r"""Whether the product is the default product"""
    archived: bool
    r"""Whether this product has been archived and is no longer available"""
    version: float
    r"""The current version of the product"""
    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""
    items: List[CheckItemTypedDict]
    r"""Array of product items that define the product's features and pricing"""
    free_trial: Nullable[CheckFreeTrialTypedDict]
    r"""Free trial configuration for this product, if available"""
    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""
    scenario: NotRequired[ProductScenario]
    r"""Scenario for when this product is used in attach flows"""
    properties: NotRequired[CheckPropertiesTypedDict]


class Product(BaseModel):
    id: str
    r"""The ID of the product you set when creating the product"""

    name: str
    r"""The name of the product"""

    group: Nullable[str]
    r"""Product group which this product belongs to"""

    env: CheckEnv
    r"""The environment of the product"""

    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""

    is_default: bool
    r"""Whether the product is the default product"""

    archived: bool
    r"""Whether this product has been archived and is no longer available"""

    version: float
    r"""The current version of the product"""

    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""

    items: List[CheckItem]
    r"""Array of product items that define the product's features and pricing"""

    free_trial: Nullable[CheckFreeTrial]
    r"""Free trial configuration for this product, if available"""

    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""

    scenario: Optional[ProductScenario] = None
    r"""Scenario for when this product is used in attach flows"""

    properties: Optional[CheckProperties] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["scenario", "properties"])
        nullable_fields = set(["group", "free_trial", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewTypedDict(TypedDict):
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    scenario: CheckScenario
    r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""
    title: str
    r"""A title suitable for displaying in a paywall or upgrade modal."""
    message: str
    r"""A message explaining why access was denied."""
    feature_id: str
    r"""The ID of the feature that was checked."""
    feature_name: str
    r"""The display name of the feature."""
    products: List[ProductTypedDict]
    r"""Products that would grant access to this feature. Use to display upgrade options."""


class Preview(BaseModel):
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    scenario: CheckScenario
    r"""The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan."""

    title: str
    r"""A title suitable for displaying in a paywall or upgrade modal."""

    message: str
    r"""A message explaining why access was denied."""

    feature_id: str
    r"""The ID of the feature that was checked."""

    feature_name: str
    r"""The display name of the feature."""

    products: List[Product]
    r"""Products that would grant access to this feature. Use to display upgrade options."""


class CheckResponseTypedDict(TypedDict):
    r"""OK"""

    allowed: bool
    r"""Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean."""
    customer_id: str
    r"""The ID of the customer that was checked."""
    balance: Nullable[BalanceTypedDict]
    r"""The customer's balance for this feature. Null if the customer has no balance for this feature."""
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity, if an entity-scoped check was performed."""
    required_balance: NotRequired[float]
    r"""The required balance that was checked against."""
    preview: NotRequired[PreviewTypedDict]
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""


class CheckResponse(BaseModel):
    r"""OK"""

    allowed: bool
    r"""Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean."""

    customer_id: str
    r"""The ID of the customer that was checked."""

    balance: Nullable[Balance]
    r"""The customer's balance for this feature. Null if the customer has no balance for this feature."""

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity, if an entity-scoped check was performed."""

    required_balance: Optional[float] = None
    r"""The required balance that was checked against."""

    preview: Optional[Preview] = None
    r"""Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "required_balance", "preview"])
        nullable_fields = set(["entity_id", "balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
