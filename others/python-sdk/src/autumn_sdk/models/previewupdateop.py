"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class PreviewUpdateGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class PreviewUpdateGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewUpdateFeatureQuantityTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class PreviewUpdateFeatureQuantity(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdateDurationType = Literal[
    "day",
    "month",
    "year",
]


class PreviewUpdateFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[PreviewUpdateDurationType]
    card_required: NotRequired[bool]


class PreviewUpdateFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[PreviewUpdateDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdatePriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class PreviewUpdatePriceTypedDict(TypedDict):
    amount: float
    interval: PreviewUpdatePriceInterval
    interval_count: NotRequired[float]


class PreviewUpdatePrice(BaseModel):
    amount: float

    interval: PreviewUpdatePriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdateResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class PreviewUpdateResetTypedDict(TypedDict):
    interval: PreviewUpdateResetInterval
    interval_count: NotRequired[float]


class PreviewUpdateReset(BaseModel):
    interval: PreviewUpdateResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdateToTypedDict = TypeAliasType("PreviewUpdateToTypedDict", Union[float, str])


PreviewUpdateTo = TypeAliasType("PreviewUpdateTo", Union[float, str])


class PreviewUpdateTierTypedDict(TypedDict):
    to: PreviewUpdateToTypedDict
    amount: float


class PreviewUpdateTier(BaseModel):
    to: PreviewUpdateTo

    amount: float


PreviewUpdateItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


PreviewUpdateBillingMethod = Literal[
    "prepaid",
    "usage_based",
]


class PreviewUpdateItemPriceTypedDict(TypedDict):
    interval: PreviewUpdateItemPriceInterval
    billing_method: PreviewUpdateBillingMethod
    amount: NotRequired[float]
    tiers: NotRequired[List[PreviewUpdateTierTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class PreviewUpdateItemPrice(BaseModel):
    interval: PreviewUpdateItemPriceInterval

    billing_method: PreviewUpdateBillingMethod

    amount: Optional[float] = None

    tiers: Optional[List[PreviewUpdateTier]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdateOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


PreviewUpdateOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class PreviewUpdateProrationTypedDict(TypedDict):
    on_increase: PreviewUpdateOnIncrease
    on_decrease: PreviewUpdateOnDecrease


class PreviewUpdateProration(BaseModel):
    on_increase: PreviewUpdateOnIncrease

    on_decrease: PreviewUpdateOnDecrease


PreviewUpdateExpiryDurationType = Literal[
    "month",
    "forever",
]


class PreviewUpdateRolloverTypedDict(TypedDict):
    expiry_duration_type: PreviewUpdateExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class PreviewUpdateRollover(BaseModel):
    expiry_duration_type: PreviewUpdateExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewUpdateItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[PreviewUpdateResetTypedDict]
    price: NotRequired[PreviewUpdateItemPriceTypedDict]
    proration: NotRequired[PreviewUpdateProrationTypedDict]
    rollover: NotRequired[PreviewUpdateRolloverTypedDict]


class PreviewUpdateItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[PreviewUpdateReset] = None

    price: Optional[PreviewUpdateItemPrice] = None

    proration: Optional[PreviewUpdateProration] = None

    rollover: Optional[PreviewUpdateRollover] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewUpdateCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: NotRequired[Nullable[PreviewUpdatePriceTypedDict]]
    items: NotRequired[List[PreviewUpdateItemTypedDict]]


class PreviewUpdateCustomize(BaseModel):
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    price: OptionalNullable[PreviewUpdatePrice] = UNSET

    items: Optional[List[PreviewUpdateItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewUpdateInvoiceModeTypedDict(TypedDict):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""
    enable_plan_immediately: NotRequired[bool]
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""
    finalize: NotRequired[bool]
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""


class PreviewUpdateInvoiceMode(BaseModel):
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    enabled: bool
    r"""When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method."""

    enable_plan_immediately: Optional[bool] = False
    r"""If true, enables the plan immediately even though the invoice is not paid yet."""

    finalize: Optional[bool] = True
    r"""If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_plan_immediately", "finalize"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PreviewUpdateBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]
r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""


PreviewUpdateCancelAction = Literal[
    "cancel_immediately",
    "cancel_end_of_cycle",
    "uncancel",
]
r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""


class PreviewUpdateParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    plan_id: str
    r"""The ID of the plan."""
    entity_id: NotRequired[str]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[List[PreviewUpdateFeatureQuantityTypedDict]]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    free_trial: NotRequired[Nullable[PreviewUpdateFreeTrialTypedDict]]
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""
    customize: NotRequired[PreviewUpdateCustomizeTypedDict]
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""
    invoice_mode: NotRequired[PreviewUpdateInvoiceModeTypedDict]
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""
    billing_behavior: NotRequired[PreviewUpdateBillingBehavior]
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""
    cancel_action: NotRequired[PreviewUpdateCancelAction]
    r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""


class PreviewUpdateParams(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    plan_id: str
    r"""The ID of the plan."""

    entity_id: Optional[str] = None
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: Optional[List[PreviewUpdateFeatureQuantity]] = None
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    free_trial: OptionalNullable[PreviewUpdateFreeTrial] = UNSET
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""

    customize: Optional[PreviewUpdateCustomize] = None
    r"""Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both."""

    invoice_mode: Optional[PreviewUpdateInvoiceMode] = None
    r"""Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method."""

    billing_behavior: Optional[PreviewUpdateBillingBehavior] = None
    r"""How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle."""

    cancel_action: Optional[PreviewUpdateCancelAction] = None
    r"""Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "invoice_mode",
                "billing_behavior",
                "cancel_action",
            ]
        )
        nullable_fields = set(["free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewUpdateDiscountTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class PreviewUpdateDiscount(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewUpdateLineItemTypedDict(TypedDict):
    title: str
    r"""The title of the line item."""
    description: str
    r"""A detailed description of the line item."""
    amount: float
    r"""The amount in cents for this line item."""
    discounts: NotRequired[List[PreviewUpdateDiscountTypedDict]]
    r"""List of discounts applied to this line item."""


class PreviewUpdateLineItem(BaseModel):
    title: str
    r"""The title of the line item."""

    description: str
    r"""A detailed description of the line item."""

    amount: float
    r"""The amount in cents for this line item."""

    discounts: Optional[List[PreviewUpdateDiscount]] = None
    r"""List of discounts applied to this line item."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discounts"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PreviewUpdateNextCycleTypedDict(TypedDict):
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    starts_at: float
    r"""Unix timestamp (milliseconds) when the next billing cycle starts."""
    total: float
    r"""The total amount in cents for the next cycle."""


class PreviewUpdateNextCycle(BaseModel):
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    starts_at: float
    r"""Unix timestamp (milliseconds) when the next billing cycle starts."""

    total: float
    r"""The total amount in cents for the next cycle."""


class PreviewUpdateResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""
    line_items: List[PreviewUpdateLineItemTypedDict]
    r"""List of line items for the current billing period."""
    total: float
    r"""The total amount in cents for the current billing period."""
    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""
    next_cycle: NotRequired[PreviewUpdateNextCycleTypedDict]
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""


class PreviewUpdateResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer."""

    line_items: List[PreviewUpdateLineItem]
    r"""List of line items for the current billing period."""

    total: float
    r"""The total amount in cents for the current billing period."""

    currency: str
    r"""The three-letter ISO currency code (e.g., 'usd')."""

    next_cycle: Optional[PreviewUpdateNextCycle] = None
    r"""Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["next_cycle"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    PreviewUpdateDiscount.model_rebuild()
except NameError:
    pass
