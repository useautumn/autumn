"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BalancesCheckGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BalancesCheckGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BalancesCheckRequestTypedDict(TypedDict):
    customer_id: str
    r"""ID which you provided when creating the customer"""
    feature_id: NotRequired[str]
    entity_id: NotRequired[str]
    r"""If using entity balances (eg, seats), the entity ID to check access for."""
    required_balance: NotRequired[float]
    r"""If you know the amount of the feature the end user is consuming in advance. If their balance is below this quantity, allowed will be false."""
    properties: NotRequired[Dict[str, Any]]
    send_event: NotRequired[bool]
    r"""If true, a usage event will be recorded together with checking access. The required_balance field will be used as the usage value."""
    with_preview: NotRequired[bool]
    r"""If true, the response will include a preview object, which can be used to display information such as a paywall or upgrade confirmation."""
    product_id: NotRequired[str]
    required_quantity: NotRequired[float]


class BalancesCheckRequest(BaseModel):
    customer_id: str
    r"""ID which you provided when creating the customer"""

    feature_id: Optional[str] = None

    entity_id: Optional[str] = None
    r"""If using entity balances (eg, seats), the entity ID to check access for."""

    required_balance: Optional[float] = None
    r"""If you know the amount of the feature the end user is consuming in advance. If their balance is below this quantity, allowed will be false."""

    properties: Optional[Dict[str, Any]] = None

    send_event: Optional[bool] = None
    r"""If true, a usage event will be recorded together with checking access. The required_balance field will be used as the usage value."""

    with_preview: Optional[bool] = None
    r"""If true, the response will include a preview object, which can be used to display information such as a paywall or upgrade confirmation."""

    product_id: Optional[str] = None

    required_quantity: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "feature_id",
                "entity_id",
                "required_balance",
                "properties",
                "send_event",
                "with_preview",
                "product_id",
                "required_quantity",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BalancesCheckBalanceType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class BalancesCheckCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class BalancesCheckCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class BalancesCheckBalanceDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class BalancesCheckBalanceDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesCheckFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: BalancesCheckBalanceType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[BalancesCheckCreditSchemaTypedDict]]
    display: NotRequired[BalancesCheckBalanceDisplayTypedDict]


class BalancesCheckFeature(BaseModel):
    id: str

    name: str

    type: BalancesCheckBalanceType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[BalancesCheckCreditSchema]] = None

    display: Optional[BalancesCheckBalanceDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BalancesCheckBalanceIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


BalancesCheckIntervalUnionTypedDict = TypeAliasType(
    "BalancesCheckIntervalUnionTypedDict", Union[BalancesCheckBalanceIntervalEnum, str]
)


BalancesCheckIntervalUnion = TypeAliasType(
    "BalancesCheckIntervalUnion", Union[BalancesCheckBalanceIntervalEnum, str]
)


class BalancesCheckResetTypedDict(TypedDict):
    interval: BalancesCheckIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class BalancesCheckReset(BaseModel):
    interval: BalancesCheckIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesCheckBalanceToTypedDict = TypeAliasType(
    "BalancesCheckBalanceToTypedDict", Union[float, str]
)


BalancesCheckBalanceTo = TypeAliasType("BalancesCheckBalanceTo", Union[float, str])


class BalancesCheckTierTypedDict(TypedDict):
    to: BalancesCheckBalanceToTypedDict
    amount: float


class BalancesCheckTier(BaseModel):
    to: BalancesCheckBalanceTo

    amount: float


BalancesCheckBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class BalancesCheckPriceTypedDict(TypedDict):
    billing_units: float
    billing_method: BalancesCheckBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[BalancesCheckTierTypedDict]]


class BalancesCheckPrice(BaseModel):
    billing_units: float

    billing_method: BalancesCheckBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[BalancesCheckTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesCheckBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[BalancesCheckResetTypedDict]
    price: Nullable[BalancesCheckPriceTypedDict]
    expires_at: Nullable[float]
    id: NotRequired[str]


class BalancesCheckBreakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[BalancesCheckReset]

    price: Nullable[BalancesCheckPrice]

    expires_at: Nullable[float]

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesCheckBalanceRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class BalancesCheckBalanceRollover(BaseModel):
    balance: float

    expires_at: float


class BalancesCheckBalanceTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    feature: NotRequired[BalancesCheckFeatureTypedDict]
    breakdown: NotRequired[List[BalancesCheckBreakdownTypedDict]]
    rollovers: NotRequired[List[BalancesCheckBalanceRolloverTypedDict]]


class BalancesCheckBalance(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    feature: Optional[BalancesCheckFeature] = None

    breakdown: Optional[List[BalancesCheckBreakdown]] = None

    rollovers: Optional[List[BalancesCheckBalanceRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesCheckScenario = Union[
    Literal[
        "usage_limit",
        "feature_flag",
    ],
    UnrecognizedStr,
]


BalancesCheckEnv = Union[
    Literal[
        "sandbox",
        "live",
    ],
    UnrecognizedStr,
]
r"""The environment of the product"""


ProductType = Union[
    Literal[
        "feature",
        "priced_feature",
        "price",
    ],
    UnrecognizedStr,
]


FeatureType = Union[
    Literal[
        "single_use",
        "continuous_use",
        "boolean",
        "static",
    ],
    UnrecognizedStr,
]


IncludedUsageTypedDict = TypeAliasType("IncludedUsageTypedDict", Union[float, str])


IncludedUsage = TypeAliasType("IncludedUsage", Union[float, str])


ProductInterval = Union[
    Literal[
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


TiersToTypedDict = TypeAliasType("TiersToTypedDict", Union[float, str])
r"""The maximum amount of usage for this tier."""


TiersTo = TypeAliasType("TiersTo", Union[float, str])
r"""The maximum amount of usage for this tier."""


class TiersTypedDict(TypedDict):
    to: TiersToTypedDict
    r"""The maximum amount of usage for this tier."""
    amount: float
    r"""The price of the product item for this tier."""


class Tiers(BaseModel):
    to: TiersTo
    r"""The maximum amount of usage for this tier."""

    amount: float
    r"""The price of the product item for this tier."""


UsageModel = Union[
    Literal[
        "prepaid",
        "pay_per_use",
    ],
    UnrecognizedStr,
]


class ProductDisplayTypedDict(TypedDict):
    primary_text: str
    secondary_text: NotRequired[Nullable[str]]


class ProductDisplay(BaseModel):
    primary_text: str

    secondary_text: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["secondary_text"])
        nullable_fields = set(["secondary_text"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RolloverDuration = Union[
    Literal[
        "month",
        "forever",
    ],
    UnrecognizedStr,
]


class ConfigRolloverTypedDict(TypedDict):
    max: Nullable[float]
    length: float
    duration: NotRequired[RolloverDuration]


class ConfigRollover(BaseModel):
    max: Nullable[float]

    length: float

    duration: Optional[RolloverDuration] = "month"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration"])
        nullable_fields = set(["max"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


BalancesCheckOnIncrease = Union[
    Literal[
        "bill_immediately",
        "prorate_immediately",
        "prorate_next_cycle",
        "bill_next_cycle",
    ],
    UnrecognizedStr,
]


BalancesCheckOnDecrease = Union[
    Literal[
        "prorate",
        "prorate_immediately",
        "prorate_next_cycle",
        "none",
        "no_prorations",
    ],
    UnrecognizedStr,
]


class ConfigTypedDict(TypedDict):
    rollover: NotRequired[Nullable[ConfigRolloverTypedDict]]
    on_increase: NotRequired[Nullable[BalancesCheckOnIncrease]]
    on_decrease: NotRequired[Nullable[BalancesCheckOnDecrease]]


class Config(BaseModel):
    rollover: OptionalNullable[ConfigRollover] = UNSET

    on_increase: OptionalNullable[BalancesCheckOnIncrease] = UNSET

    on_decrease: OptionalNullable[BalancesCheckOnDecrease] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rollover", "on_increase", "on_decrease"])
        nullable_fields = set(["rollover", "on_increase", "on_decrease"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BalancesCheckItemTypedDict(TypedDict):
    r"""Product item defining features and pricing within a product"""

    type: NotRequired[Nullable[ProductType]]
    r"""The type of the product item"""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""
    feature_type: NotRequired[Nullable[FeatureType]]
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""
    included_usage: NotRequired[Nullable[IncludedUsageTypedDict]]
    r"""The amount of usage included for this feature."""
    interval: NotRequired[Nullable[ProductInterval]]
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""
    interval_count: NotRequired[Nullable[float]]
    r"""The interval count of the product item."""
    price: NotRequired[Nullable[float]]
    r"""The price of the product item. Should be `null` if tiered pricing is set."""
    tiers: NotRequired[Nullable[List[TiersTypedDict]]]
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""
    usage_model: NotRequired[Nullable[UsageModel]]
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""
    billing_units: NotRequired[Nullable[float]]
    r"""The amount per billing unit (eg. $9 / 250 units)"""
    reset_usage_when_enabled: NotRequired[Nullable[bool]]
    r"""Whether the usage should be reset when the product is enabled."""
    entity_feature_id: NotRequired[Nullable[str]]
    r"""The entity feature ID of the product item if applicable."""
    display: NotRequired[Nullable[ProductDisplayTypedDict]]
    r"""The display of the product item."""
    quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""
    next_cycle_quantity: NotRequired[Nullable[float]]
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""
    config: NotRequired[Nullable[ConfigTypedDict]]
    r"""Configuration for rollover and proration behavior of the feature."""


class BalancesCheckItem(BaseModel):
    r"""Product item defining features and pricing within a product"""

    type: OptionalNullable[ProductType] = UNSET
    r"""The type of the product item"""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID of the product item. If the item is a fixed price, should be `null`"""

    feature_type: OptionalNullable[FeatureType] = UNSET
    r"""Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats."""

    included_usage: OptionalNullable[IncludedUsage] = UNSET
    r"""The amount of usage included for this feature."""

    interval: OptionalNullable[ProductInterval] = UNSET
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""

    interval_count: OptionalNullable[float] = UNSET
    r"""The interval count of the product item."""

    price: OptionalNullable[float] = UNSET
    r"""The price of the product item. Should be `null` if tiered pricing is set."""

    tiers: OptionalNullable[List[Tiers]] = UNSET
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""

    usage_model: OptionalNullable[UsageModel] = UNSET
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""

    billing_units: OptionalNullable[float] = UNSET
    r"""The amount per billing unit (eg. $9 / 250 units)"""

    reset_usage_when_enabled: OptionalNullable[bool] = UNSET
    r"""Whether the usage should be reset when the product is enabled."""

    entity_feature_id: OptionalNullable[str] = UNSET
    r"""The entity feature ID of the product item if applicable."""

    display: OptionalNullable[ProductDisplay] = UNSET
    r"""The display of the product item."""

    quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer has prepaid for."""

    next_cycle_quantity: OptionalNullable[float] = UNSET
    r"""Used in customer context. Quantity of the feature the customer will prepay for in the next cycle."""

    config: OptionalNullable[Config] = UNSET
    r"""Configuration for rollover and proration behavior of the feature."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        nullable_fields = set(
            [
                "type",
                "feature_id",
                "feature_type",
                "included_usage",
                "interval",
                "interval_count",
                "price",
                "tiers",
                "usage_model",
                "billing_units",
                "reset_usage_when_enabled",
                "entity_feature_id",
                "display",
                "quantity",
                "next_cycle_quantity",
                "config",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


FreeTrialDuration = Union[
    Literal[
        "day",
        "month",
        "year",
    ],
    UnrecognizedStr,
]
r"""The duration type of the free trial"""


class BalancesCheckFreeTrialTypedDict(TypedDict):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""
    length: float
    r"""The length of the duration type specified"""
    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""
    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""
    trial_available: NotRequired[Nullable[bool]]
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""


class BalancesCheckFreeTrial(BaseModel):
    duration: FreeTrialDuration
    r"""The duration type of the free trial"""

    length: float
    r"""The length of the duration type specified"""

    unique_fingerprint: bool
    r"""Whether the free trial is limited to one per customer fingerprint"""

    card_required: bool
    r"""Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file."""

    trial_available: OptionalNullable[bool] = True
    r"""Used in customer context. Whether the free trial is available for the customer if they were to attach the product."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["trial_available"])
        nullable_fields = set(["trial_available"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ProductScenario = Union[
    Literal[
        "scheduled",
        "active",
        "new",
        "renew",
        "upgrade",
        "downgrade",
        "cancel",
        "expired",
        "past_due",
    ],
    UnrecognizedStr,
]
r"""Scenario for when this product is used in attach flows"""


class PropertiesTypedDict(TypedDict):
    is_free: bool
    r"""True if the product has no base price or usage prices"""
    is_one_off: bool
    r"""True if the product only contains a one-time price"""
    interval_group: NotRequired[Nullable[str]]
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""
    has_trial: NotRequired[Nullable[bool]]
    r"""True if the product includes a free trial"""
    updateable: NotRequired[Nullable[bool]]
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""


class Properties(BaseModel):
    is_free: bool
    r"""True if the product has no base price or usage prices"""

    is_one_off: bool
    r"""True if the product only contains a one-time price"""

    interval_group: OptionalNullable[str] = UNSET
    r"""The billing interval group for recurring products (e.g., 'monthly', 'yearly')"""

    has_trial: OptionalNullable[bool] = UNSET
    r"""True if the product includes a free trial"""

    updateable: OptionalNullable[bool] = UNSET
    r"""True if the product can be updated after creation (only applicable if there are prepaid recurring prices)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_group", "has_trial", "updateable"])
        nullable_fields = set(["interval_group", "has_trial", "updateable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ProductTypedDict(TypedDict):
    id: str
    r"""The ID of the product you set when creating the product"""
    name: str
    r"""The name of the product"""
    group: Nullable[str]
    r"""Product group which this product belongs to"""
    env: BalancesCheckEnv
    r"""The environment of the product"""
    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""
    is_default: bool
    r"""Whether the product is the default product"""
    archived: bool
    r"""Whether this product has been archived and is no longer available"""
    version: float
    r"""The current version of the product"""
    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""
    items: List[BalancesCheckItemTypedDict]
    r"""Array of product items that define the product's features and pricing"""
    free_trial: Nullable[BalancesCheckFreeTrialTypedDict]
    r"""Free trial configuration for this product, if available"""
    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""
    scenario: NotRequired[ProductScenario]
    r"""Scenario for when this product is used in attach flows"""
    properties: NotRequired[PropertiesTypedDict]


class Product(BaseModel):
    id: str
    r"""The ID of the product you set when creating the product"""

    name: str
    r"""The name of the product"""

    group: Nullable[str]
    r"""Product group which this product belongs to"""

    env: BalancesCheckEnv
    r"""The environment of the product"""

    is_add_on: bool
    r"""Whether the product is an add-on and can be purchased alongside other products"""

    is_default: bool
    r"""Whether the product is the default product"""

    archived: bool
    r"""Whether this product has been archived and is no longer available"""

    version: float
    r"""The current version of the product"""

    created_at: float
    r"""The timestamp of when the product was created in milliseconds since epoch"""

    items: List[BalancesCheckItem]
    r"""Array of product items that define the product's features and pricing"""

    free_trial: Nullable[BalancesCheckFreeTrial]
    r"""Free trial configuration for this product, if available"""

    base_variant_id: Nullable[str]
    r"""ID of the base variant this product is derived from"""

    scenario: Optional[ProductScenario] = None
    r"""Scenario for when this product is used in attach flows"""

    properties: Optional[Properties] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["scenario", "properties"])
        nullable_fields = set(["group", "free_trial", "base_variant_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PreviewTypedDict(TypedDict):
    scenario: BalancesCheckScenario
    title: str
    message: str
    feature_id: str
    feature_name: str
    products: List[ProductTypedDict]


class Preview(BaseModel):
    scenario: BalancesCheckScenario

    title: str

    message: str

    feature_id: str

    feature_name: str

    products: List[Product]


class BalancesCheckResponseTypedDict(TypedDict):
    r"""OK"""

    allowed: bool
    customer_id: str
    balance: Nullable[BalancesCheckBalanceTypedDict]
    entity_id: NotRequired[Nullable[str]]
    required_balance: NotRequired[float]
    preview: NotRequired[PreviewTypedDict]


class BalancesCheckResponse(BaseModel):
    r"""OK"""

    allowed: bool

    customer_id: str

    balance: Nullable[BalancesCheckBalance]

    entity_id: OptionalNullable[str] = UNSET

    required_balance: Optional[float] = None

    preview: Optional[Preview] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "required_balance", "preview"])
        nullable_fields = set(["entity_id", "balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
