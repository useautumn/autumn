"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .balance import Balance, BalanceTypedDict
from autumn_sdk.types import BaseModel, Nullable, UNSET_SENTINEL
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class TrackGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class TrackGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TrackParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer."""
    feature_id: NotRequired[str]
    r"""The ID of the feature to track usage for. Required if event_name is not provided."""
    entity_id: NotRequired[str]
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""
    event_name: NotRequired[str]
    r"""Event name to track usage for. Use instead of feature_id when multiple features should be tracked from a single event."""
    value: NotRequired[float]
    r"""The amount of usage to record. Defaults to 1. Use negative values to credit balance (e.g., when removing a seat)."""
    properties: NotRequired[Dict[str, Any]]
    r"""Additional properties to attach to this usage event."""


class TrackParams(BaseModel):
    customer_id: str
    r"""The ID of the customer."""

    feature_id: Optional[str] = None
    r"""The ID of the feature to track usage for. Required if event_name is not provided."""

    entity_id: Optional[str] = None
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""

    event_name: Optional[str] = None
    r"""Event name to track usage for. Use instead of feature_id when multiple features should be tracked from a single event."""

    value: Optional[float] = None
    r"""The amount of usage to record. Defaults to 1. Use negative values to credit balance (e.g., when removing a seat)."""

    properties: Optional[Dict[str, Any]] = None
    r"""Additional properties to attach to this usage event."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["feature_id", "entity_id", "event_name", "value", "properties"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TrackResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer whose usage was tracked."""
    value: float
    r"""The amount of usage that was recorded."""
    balance: Nullable[BalanceTypedDict]
    r"""The updated balance for the tracked feature. Null if tracking by event_name that affects multiple features."""
    entity_id: NotRequired[str]
    r"""The ID of the entity, if entity-scoped tracking was performed."""
    event_name: NotRequired[str]
    r"""The event name that was tracked, if event_name was used instead of feature_id."""
    balances: NotRequired[Dict[str, BalanceTypedDict]]
    r"""Map of feature_id to updated balance when tracking by event_name affects multiple features."""


class TrackResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer whose usage was tracked."""

    value: float
    r"""The amount of usage that was recorded."""

    balance: Nullable[Balance]
    r"""The updated balance for the tracked feature. Null if tracking by event_name that affects multiple features."""

    entity_id: Optional[str] = None
    r"""The ID of the entity, if entity-scoped tracking was performed."""

    event_name: Optional[str] = None
    r"""The event name that was tracked, if event_name was used instead of feature_id."""

    balances: Optional[Dict[str, Balance]] = None
    r"""Map of feature_id to updated balance when tracking by event_name affects multiple features."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "event_name", "balances"])
        nullable_fields = set(["balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
