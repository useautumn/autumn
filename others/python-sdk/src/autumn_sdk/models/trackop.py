"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class TrackGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class TrackGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TrackParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer."""
    feature_id: NotRequired[str]
    r"""The ID of the feature to track usage for. Required if event_name is not provided."""
    entity_id: NotRequired[str]
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""
    event_name: NotRequired[str]
    r"""Event name to track usage for. Use instead of feature_id when multiple features should be tracked from a single event."""
    value: NotRequired[float]
    r"""The amount of usage to record. Defaults to 1. Use negative values to credit balance (e.g., when removing a seat)."""
    properties: NotRequired[Dict[str, Any]]
    r"""Additional properties to attach to this usage event."""


class TrackParams(BaseModel):
    customer_id: str
    r"""The ID of the customer."""

    feature_id: Optional[str] = None
    r"""The ID of the feature to track usage for. Required if event_name is not provided."""

    entity_id: Optional[str] = None
    r"""The ID of the entity for entity-scoped balances (e.g., per-seat limits)."""

    event_name: Optional[str] = None
    r"""Event name to track usage for. Use instead of feature_id when multiple features should be tracked from a single event."""

    value: Optional[float] = None
    r"""The amount of usage to record. Defaults to 1. Use negative values to credit balance (e.g., when removing a seat)."""

    properties: Optional[Dict[str, Any]] = None
    r"""Additional properties to attach to this usage event."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["feature_id", "entity_id", "event_name", "value", "properties"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


TrackBalanceType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class TrackBalanceCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class TrackBalanceCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class TrackBalanceDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class TrackBalanceDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalanceFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    name: str
    type: TrackBalanceType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[TrackBalanceCreditSchemaTypedDict]]
    display: NotRequired[TrackBalanceDisplayTypedDict]


class TrackBalanceFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str

    name: str

    type: TrackBalanceType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[TrackBalanceCreditSchema]] = None

    display: Optional[TrackBalanceDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


TrackBalanceIntervalEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


TrackBalanceIntervalUnionTypedDict = TypeAliasType(
    "TrackBalanceIntervalUnionTypedDict", Union[TrackBalanceIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


TrackBalanceIntervalUnion = TypeAliasType(
    "TrackBalanceIntervalUnion", Union[TrackBalanceIntervalEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


class TrackBalanceResetTypedDict(TypedDict):
    interval: TrackBalanceIntervalUnionTypedDict
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""
    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""


class TrackBalanceReset(BaseModel):
    interval: TrackBalanceIntervalUnion
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""

    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


TrackBalanceToTypedDict = TypeAliasType("TrackBalanceToTypedDict", Union[float, str])


TrackBalanceTo = TypeAliasType("TrackBalanceTo", Union[float, str])


class TrackBalanceTierTypedDict(TypedDict):
    to: TrackBalanceToTypedDict
    amount: float


class TrackBalanceTier(BaseModel):
    to: TrackBalanceTo

    amount: float


TrackBalanceBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""Whether usage is prepaid or billed pay-per-use."""


class TrackBalancePriceTypedDict(TypedDict):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""
    billing_method: TrackBalanceBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""
    amount: NotRequired[float]
    r"""The per-unit price amount."""
    tiers: NotRequired[List[TrackBalanceTierTypedDict]]
    r"""Tiered pricing configuration if applicable."""


class TrackBalancePrice(BaseModel):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""

    billing_method: TrackBalanceBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""

    amount: Optional[float] = None
    r"""The per-unit price amount."""

    tiers: Optional[List[TrackBalanceTier]] = None
    r"""Tiered pricing configuration if applicable."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalanceBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""
    included_grant: float
    r"""Amount granted from the plan's included usage."""
    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Amount consumed in the current period."""
    unlimited: bool
    r"""Whether this balance has unlimited usage."""
    reset: Nullable[TrackBalanceResetTypedDict]
    r"""Reset configuration for this balance, or null if no reset."""
    price: Nullable[TrackBalancePriceTypedDict]
    r"""Pricing configuration if this balance has usage-based pricing."""
    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""
    id: NotRequired[str]
    r"""The unique identifier for this balance breakdown."""


class TrackBalanceBreakdown(BaseModel):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""

    included_grant: float
    r"""Amount granted from the plan's included usage."""

    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Amount consumed in the current period."""

    unlimited: bool
    r"""Whether this balance has unlimited usage."""

    reset: Nullable[TrackBalanceReset]
    r"""Reset configuration for this balance, or null if no reset."""

    price: Nullable[TrackBalancePrice]
    r"""Pricing configuration if this balance has usage-based pricing."""

    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""

    id: Optional[str] = ""
    r"""The unique identifier for this balance breakdown."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalanceRolloverTypedDict(TypedDict):
    balance: float
    r"""Amount of balance rolled over from a previous period."""
    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class TrackBalanceRollover(BaseModel):
    balance: float
    r"""Amount of balance rolled over from a previous period."""

    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class TrackBalanceTypedDict(TypedDict):
    feature_id: str
    r"""The feature ID this balance is for."""
    granted: float
    r"""Total balance granted (included + prepaid)."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Total usage consumed in the current period."""
    unlimited: bool
    r"""Whether this feature has unlimited usage."""
    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""
    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""
    feature: NotRequired[TrackBalanceFeatureTypedDict]
    r"""The full feature object if expanded."""
    breakdown: NotRequired[List[TrackBalanceBreakdownTypedDict]]
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""
    rollovers: NotRequired[List[TrackBalanceRolloverTypedDict]]
    r"""Rollover balances carried over from previous periods."""


class TrackBalance(BaseModel):
    feature_id: str
    r"""The feature ID this balance is for."""

    granted: float
    r"""Total balance granted (included + prepaid)."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Total usage consumed in the current period."""

    unlimited: bool
    r"""Whether this feature has unlimited usage."""

    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""

    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""

    feature: Optional[TrackBalanceFeature] = None
    r"""The full feature object if expanded."""

    breakdown: Optional[List[TrackBalanceBreakdown]] = None
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""

    rollovers: Optional[List[TrackBalanceRollover]] = None
    r"""Rollover balances carried over from previous periods."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


TrackBalancesType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class TrackBalancesCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class TrackBalancesCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class TrackBalancesDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class TrackBalancesDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalancesFeatureTypedDict(TypedDict):
    r"""The full feature object if expanded."""

    id: str
    name: str
    type: TrackBalancesType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[TrackBalancesCreditSchemaTypedDict]]
    display: NotRequired[TrackBalancesDisplayTypedDict]


class TrackBalancesFeature(BaseModel):
    r"""The full feature object if expanded."""

    id: str

    name: str

    type: TrackBalancesType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[TrackBalancesCreditSchema]] = None

    display: Optional[TrackBalancesDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


TrackIntervalBalancesEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


TrackBalancesIntervalUnionTypedDict = TypeAliasType(
    "TrackBalancesIntervalUnionTypedDict", Union[TrackIntervalBalancesEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


TrackBalancesIntervalUnion = TypeAliasType(
    "TrackBalancesIntervalUnion", Union[TrackIntervalBalancesEnum, str]
)
r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""


class TrackBalancesResetTypedDict(TypedDict):
    interval: TrackBalancesIntervalUnionTypedDict
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""
    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""


class TrackBalancesReset(BaseModel):
    interval: TrackBalancesIntervalUnion
    r"""The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals."""

    resets_at: Nullable[float]
    r"""Timestamp when the balance will next reset."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets (eg. 2 for bi-monthly)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


TrackBalancesToTypedDict = TypeAliasType("TrackBalancesToTypedDict", Union[float, str])


TrackBalancesTo = TypeAliasType("TrackBalancesTo", Union[float, str])


class TrackBalancesTierTypedDict(TypedDict):
    to: TrackBalancesToTypedDict
    amount: float


class TrackBalancesTier(BaseModel):
    to: TrackBalancesTo

    amount: float


TrackBalancesBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]
r"""Whether usage is prepaid or billed pay-per-use."""


class TrackBalancesPriceTypedDict(TypedDict):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""
    billing_method: TrackBalancesBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""
    amount: NotRequired[float]
    r"""The per-unit price amount."""
    tiers: NotRequired[List[TrackBalancesTierTypedDict]]
    r"""Tiered pricing configuration if applicable."""


class TrackBalancesPrice(BaseModel):
    billing_units: float
    r"""The number of units per billing increment (eg. $9 / 250 units)."""

    billing_method: TrackBalancesBillingMethod
    r"""Whether usage is prepaid or billed pay-per-use."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased, or null for unlimited."""

    amount: Optional[float] = None
    r"""The per-unit price amount."""

    tiers: Optional[List[TrackBalancesTier]] = None
    r"""Tiered pricing configuration if applicable."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalancesBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""
    included_grant: float
    r"""Amount granted from the plan's included usage."""
    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Amount consumed in the current period."""
    unlimited: bool
    r"""Whether this balance has unlimited usage."""
    reset: Nullable[TrackBalancesResetTypedDict]
    r"""Reset configuration for this balance, or null if no reset."""
    price: Nullable[TrackBalancesPriceTypedDict]
    r"""Pricing configuration if this balance has usage-based pricing."""
    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""
    id: NotRequired[str]
    r"""The unique identifier for this balance breakdown."""


class TrackBalancesBreakdown(BaseModel):
    plan_id: Nullable[str]
    r"""The plan ID this balance originates from, or null for standalone balances."""

    included_grant: float
    r"""Amount granted from the plan's included usage."""

    prepaid_grant: float
    r"""Amount granted from prepaid purchases or top-ups."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Amount consumed in the current period."""

    unlimited: bool
    r"""Whether this balance has unlimited usage."""

    reset: Nullable[TrackBalancesReset]
    r"""Reset configuration for this balance, or null if no reset."""

    price: Nullable[TrackBalancesPrice]
    r"""Pricing configuration if this balance has usage-based pricing."""

    expires_at: Nullable[float]
    r"""Timestamp when this balance expires, or null for no expiration."""

    id: Optional[str] = ""
    r"""The unique identifier for this balance breakdown."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackBalancesRolloverTypedDict(TypedDict):
    balance: float
    r"""Amount of balance rolled over from a previous period."""
    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class TrackBalancesRollover(BaseModel):
    balance: float
    r"""Amount of balance rolled over from a previous period."""

    expires_at: float
    r"""Timestamp when the rollover balance expires."""


class TrackBalancesTypedDict(TypedDict):
    feature_id: str
    r"""The feature ID this balance is for."""
    granted: float
    r"""Total balance granted (included + prepaid)."""
    remaining: float
    r"""Remaining balance available for use."""
    usage: float
    r"""Total usage consumed in the current period."""
    unlimited: bool
    r"""Whether this feature has unlimited usage."""
    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""
    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""
    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""
    feature: NotRequired[TrackBalancesFeatureTypedDict]
    r"""The full feature object if expanded."""
    breakdown: NotRequired[List[TrackBalancesBreakdownTypedDict]]
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""
    rollovers: NotRequired[List[TrackBalancesRolloverTypedDict]]
    r"""Rollover balances carried over from previous periods."""


class TrackBalances(BaseModel):
    feature_id: str
    r"""The feature ID this balance is for."""

    granted: float
    r"""Total balance granted (included + prepaid)."""

    remaining: float
    r"""Remaining balance available for use."""

    usage: float
    r"""Total usage consumed in the current period."""

    unlimited: bool
    r"""Whether this feature has unlimited usage."""

    overage_allowed: bool
    r"""Whether usage beyond the granted balance is allowed (with overage charges)."""

    max_purchase: Nullable[float]
    r"""Maximum quantity that can be purchased as a top-up, or null for unlimited."""

    next_reset_at: Nullable[float]
    r"""Timestamp when the balance will reset, or null for no reset."""

    feature: Optional[TrackBalancesFeature] = None
    r"""The full feature object if expanded."""

    breakdown: Optional[List[TrackBalancesBreakdown]] = None
    r"""Detailed breakdown of balance sources when stacking multiple plans or grants."""

    rollovers: Optional[List[TrackBalancesRollover]] = None
    r"""Rollover balances carried over from previous periods."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TrackResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer whose usage was tracked."""
    value: float
    r"""The amount of usage that was recorded."""
    balance: Nullable[TrackBalanceTypedDict]
    r"""The updated balance for the tracked feature. Null if tracking by event_name that affects multiple features."""
    entity_id: NotRequired[str]
    r"""The ID of the entity, if entity-scoped tracking was performed."""
    event_name: NotRequired[str]
    r"""The event name that was tracked, if event_name was used instead of feature_id."""
    balances: NotRequired[Dict[str, TrackBalancesTypedDict]]
    r"""Map of feature_id to updated balance when tracking by event_name affects multiple features."""


class TrackResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer whose usage was tracked."""

    value: float
    r"""The amount of usage that was recorded."""

    balance: Nullable[TrackBalance]
    r"""The updated balance for the tracked feature. Null if tracking by event_name that affects multiple features."""

    entity_id: Optional[str] = None
    r"""The ID of the entity, if entity-scoped tracking was performed."""

    event_name: Optional[str] = None
    r"""The event name that was tracked, if event_name was used instead of feature_id."""

    balances: Optional[Dict[str, TrackBalances]] = None
    r"""Map of feature_id to updated balance when tracking by event_name affects multiple features."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id", "event_name", "balances"])
        nullable_fields = set(["balance"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
