"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .plan import Plan, PlanTypedDict
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata, validate_const
import pydantic
from pydantic import model_serializer
from pydantic.functional_validators import AfterValidator
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BillingPreviewAttachGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class BillingPreviewAttachGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachFeatureQuantitiesTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    adjustable: NotRequired[bool]


class BillingPreviewAttachFeatureQuantities(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    adjustable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewAttachDurationType = Literal[
    "day",
    "month",
    "year",
]


class BillingPreviewAttachFreeTrialTypedDict(TypedDict):
    duration_length: float
    duration_type: NotRequired[BillingPreviewAttachDurationType]
    card_required: NotRequired[bool]


class BillingPreviewAttachFreeTrial(BaseModel):
    duration_length: float

    duration_type: Optional[BillingPreviewAttachDurationType] = "month"

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewAttachPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingPreviewAttachPriceRequestTypedDict(TypedDict):
    amount: float
    interval: BillingPreviewAttachPriceInterval
    interval_count: NotRequired[float]


class BillingPreviewAttachPriceRequest(BaseModel):
    amount: float

    interval: BillingPreviewAttachPriceInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewAttachItemResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


class BillingPreviewAttachCustomizeResetTypedDict(TypedDict):
    interval: BillingPreviewAttachItemResetInterval
    interval_count: NotRequired[float]


class BillingPreviewAttachCustomizeReset(BaseModel):
    interval: BillingPreviewAttachItemResetInterval

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewAttachToTypedDict = TypeAliasType(
    "BillingPreviewAttachToTypedDict", Union[float, str]
)


BillingPreviewAttachTo = TypeAliasType("BillingPreviewAttachTo", Union[float, str])


class BillingPreviewAttachTierRequestTypedDict(TypedDict):
    to: BillingPreviewAttachToTypedDict
    amount: float


class BillingPreviewAttachTierRequest(BaseModel):
    to: BillingPreviewAttachTo

    amount: float


BillingPreviewAttachItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


BillingPreviewAttachBillingMethodRequest = Literal[
    "prepaid",
    "usage_based",
]


class BillingPreviewAttachItemPriceTypedDict(TypedDict):
    interval: BillingPreviewAttachItemPriceInterval
    billing_method: BillingPreviewAttachBillingMethodRequest
    amount: NotRequired[float]
    tiers: NotRequired[List[BillingPreviewAttachTierRequestTypedDict]]
    interval_count: NotRequired[float]
    billing_units: NotRequired[float]
    max_purchase: NotRequired[float]


class BillingPreviewAttachItemPrice(BaseModel):
    interval: BillingPreviewAttachItemPriceInterval

    billing_method: BillingPreviewAttachBillingMethodRequest

    amount: Optional[float] = None

    tiers: Optional[List[BillingPreviewAttachTierRequest]] = None

    interval_count: Optional[float] = 1

    billing_units: Optional[float] = 1

    max_purchase: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["amount", "tiers", "interval_count", "billing_units", "max_purchase"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


BillingPreviewAttachOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]


BillingPreviewAttachOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]


class BillingPreviewAttachProrationTypedDict(TypedDict):
    on_increase: BillingPreviewAttachOnIncrease
    on_decrease: BillingPreviewAttachOnDecrease


class BillingPreviewAttachProration(BaseModel):
    on_increase: BillingPreviewAttachOnIncrease

    on_decrease: BillingPreviewAttachOnDecrease


BillingPreviewAttachExpiryDurationType = Literal[
    "month",
    "forever",
]


class BillingPreviewAttachRolloverRequestTypedDict(TypedDict):
    expiry_duration_type: BillingPreviewAttachExpiryDurationType
    max: NotRequired[float]
    expiry_duration_length: NotRequired[float]


class BillingPreviewAttachRolloverRequest(BaseModel):
    expiry_duration_type: BillingPreviewAttachExpiryDurationType

    max: Optional[float] = None

    expiry_duration_length: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachItemTypedDict(TypedDict):
    feature_id: str
    included: NotRequired[float]
    unlimited: NotRequired[bool]
    reset: NotRequired[BillingPreviewAttachCustomizeResetTypedDict]
    price: NotRequired[BillingPreviewAttachItemPriceTypedDict]
    proration: NotRequired[BillingPreviewAttachProrationTypedDict]
    rollover: NotRequired[BillingPreviewAttachRolloverRequestTypedDict]


class BillingPreviewAttachItem(BaseModel):
    feature_id: str

    included: Optional[float] = None

    unlimited: Optional[bool] = None

    reset: Optional[BillingPreviewAttachCustomizeReset] = None

    price: Optional[BillingPreviewAttachItemPrice] = None

    proration: Optional[BillingPreviewAttachProration] = None

    rollover: Optional[BillingPreviewAttachRolloverRequest] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachCustomizeTypedDict(TypedDict):
    price: NotRequired[Nullable[BillingPreviewAttachPriceRequestTypedDict]]
    items: NotRequired[List[BillingPreviewAttachItemTypedDict]]


class BillingPreviewAttachCustomize(BaseModel):
    price: OptionalNullable[BillingPreviewAttachPriceRequest] = UNSET

    items: Optional[List[BillingPreviewAttachItem]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items"])
        nullable_fields = set(["price"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingPreviewAttachInvoiceModeTypedDict(TypedDict):
    enabled: bool
    enable_product_immediately: NotRequired[bool]
    finalize_invoice: NotRequired[bool]


class BillingPreviewAttachInvoiceMode(BaseModel):
    enabled: bool

    enable_product_immediately: Optional[bool] = False

    finalize_invoice: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable_product_immediately", "finalize_invoice"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachDiscountRequest2TypedDict(TypedDict):
    promotion_code: str


class BillingPreviewAttachDiscountRequest2(BaseModel):
    promotion_code: str


class BillingPreviewAttachDiscountRequest1TypedDict(TypedDict):
    reward_id: str


class BillingPreviewAttachDiscountRequest1(BaseModel):
    reward_id: str


BillingPreviewAttachDiscountUnionTypedDict = TypeAliasType(
    "BillingPreviewAttachDiscountUnionTypedDict",
    Union[
        BillingPreviewAttachDiscountRequest1TypedDict,
        BillingPreviewAttachDiscountRequest2TypedDict,
    ],
)


BillingPreviewAttachDiscountUnion = TypeAliasType(
    "BillingPreviewAttachDiscountUnion",
    Union[BillingPreviewAttachDiscountRequest1, BillingPreviewAttachDiscountRequest2],
)


BillingPreviewAttachRedirectMode = Literal[
    "always",
    "if_required",
    "never",
]


BillingPreviewAttachPlanSchedule = Literal[
    "immediate",
    "end_of_cycle",
]


BillingPreviewAttachBillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]


class BillingPreviewAttachRequestTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    plan_id: str
    entity_id: NotRequired[Nullable[str]]
    r"""The ID of the entity to attach the plan to."""
    feature_quantities: NotRequired[
        Nullable[List[BillingPreviewAttachFeatureQuantitiesTypedDict]]
    ]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    free_trial: NotRequired[Nullable[BillingPreviewAttachFreeTrialTypedDict]]
    customize: NotRequired[BillingPreviewAttachCustomizeTypedDict]
    invoice_mode: NotRequired[BillingPreviewAttachInvoiceModeTypedDict]
    discounts: NotRequired[List[BillingPreviewAttachDiscountUnionTypedDict]]
    redirect_mode: NotRequired[BillingPreviewAttachRedirectMode]
    success_url: NotRequired[str]
    new_billing_subscription: NotRequired[bool]
    plan_schedule: NotRequired[BillingPreviewAttachPlanSchedule]
    billing_behavior: NotRequired[BillingPreviewAttachBillingBehavior]


class BillingPreviewAttachRequest(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    plan_id: str

    entity_id: OptionalNullable[str] = UNSET
    r"""The ID of the entity to attach the plan to."""

    feature_quantities: OptionalNullable[
        List[BillingPreviewAttachFeatureQuantities]
    ] = UNSET
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None

    free_trial: OptionalNullable[BillingPreviewAttachFreeTrial] = UNSET

    customize: Optional[BillingPreviewAttachCustomize] = None

    invoice_mode: Optional[BillingPreviewAttachInvoiceMode] = None

    discounts: Optional[List[BillingPreviewAttachDiscountUnion]] = None

    redirect_mode: Optional[BillingPreviewAttachRedirectMode] = "always"

    success_url: Optional[str] = None

    new_billing_subscription: Optional[bool] = None

    plan_schedule: Optional[BillingPreviewAttachPlanSchedule] = None

    billing_behavior: Optional[BillingPreviewAttachBillingBehavior] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "feature_quantities",
                "version",
                "free_trial",
                "customize",
                "invoice_mode",
                "discounts",
                "redirect_mode",
                "success_url",
                "new_billing_subscription",
                "plan_schedule",
                "billing_behavior",
            ]
        )
        nullable_fields = set(["entity_id", "feature_quantities", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class BillingPreviewAttachDiscountResponseTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class BillingPreviewAttachDiscountResponse(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachEffectivePeriodTypedDict(TypedDict):
    start: float
    end: float


class BillingPreviewAttachEffectivePeriod(BaseModel):
    start: float

    end: float


class BillingPreviewAttachLineItemTypedDict(TypedDict):
    title: str
    description: str
    amount: float
    total_quantity: float
    paid_quantity: float
    plan_id: str
    discounts: NotRequired[List[BillingPreviewAttachDiscountResponseTypedDict]]
    is_base: NotRequired[bool]
    deferred_for_trial: NotRequired[bool]
    effective_period: NotRequired[BillingPreviewAttachEffectivePeriodTypedDict]


class BillingPreviewAttachLineItem(BaseModel):
    title: str

    description: str

    amount: float

    total_quantity: float

    paid_quantity: float

    plan_id: str

    discounts: Optional[List[BillingPreviewAttachDiscountResponse]] = None

    is_base: Optional[bool] = None

    deferred_for_trial: Optional[bool] = None

    effective_period: Optional[BillingPreviewAttachEffectivePeriod] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discounts", "is_base", "deferred_for_trial", "effective_period"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachCreditTypedDict(TypedDict):
    amount: float
    description: str


class BillingPreviewAttachCredit(BaseModel):
    amount: float

    description: str


class BillingPreviewAttachNextCycleDiscountTypedDict(TypedDict):
    amount_off: float
    percent_off: NotRequired[float]
    stripe_coupon_id: NotRequired[str]
    coupon_name: NotRequired[str]


class BillingPreviewAttachNextCycleDiscount(BaseModel):
    amount_off: Annotated[float, pydantic.Field(alias="amountOff")]

    percent_off: Annotated[Optional[float], pydantic.Field(alias="percentOff")] = None

    stripe_coupon_id: Annotated[
        Optional[str], pydantic.Field(alias="stripeCouponId")
    ] = None

    coupon_name: Annotated[Optional[str], pydantic.Field(alias="couponName")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["percentOff", "stripeCouponId", "couponName"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachNextCycleEffectivePeriodTypedDict(TypedDict):
    start: float
    end: float


class BillingPreviewAttachNextCycleEffectivePeriod(BaseModel):
    start: float

    end: float


class BillingPreviewAttachNextCycleLineItemTypedDict(TypedDict):
    title: str
    description: str
    amount: float
    total_quantity: float
    paid_quantity: float
    plan_id: str
    discounts: NotRequired[List[BillingPreviewAttachNextCycleDiscountTypedDict]]
    is_base: NotRequired[bool]
    deferred_for_trial: NotRequired[bool]
    effective_period: NotRequired[BillingPreviewAttachNextCycleEffectivePeriodTypedDict]


class BillingPreviewAttachNextCycleLineItem(BaseModel):
    title: str

    description: str

    amount: float

    total_quantity: float

    paid_quantity: float

    plan_id: str

    discounts: Optional[List[BillingPreviewAttachNextCycleDiscount]] = None

    is_base: Optional[bool] = None

    deferred_for_trial: Optional[bool] = None

    effective_period: Optional[BillingPreviewAttachNextCycleEffectivePeriod] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discounts", "is_base", "deferred_for_trial", "effective_period"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BillingPreviewAttachNextCycleTypedDict(TypedDict):
    starts_at: float
    total: float
    line_items: List[BillingPreviewAttachNextCycleLineItemTypedDict]


class BillingPreviewAttachNextCycle(BaseModel):
    starts_at: float

    total: float

    line_items: List[BillingPreviewAttachNextCycleLineItem]


class IncomingFeatureQuantityTypedDict(TypedDict):
    feature_id: str
    quantity: float


class IncomingFeatureQuantity(BaseModel):
    feature_id: str

    quantity: float


IncomingType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class IncomingCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class IncomingCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class IncomingDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class IncomingDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncomingFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: IncomingType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[IncomingCreditSchemaTypedDict]]
    display: NotRequired[IncomingDisplayTypedDict]


class IncomingFeature(BaseModel):
    id: str

    name: str

    type: IncomingType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[IncomingCreditSchema]] = None

    display: Optional[IncomingDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


IntervalIncomingEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


IncomingIntervalUnionTypedDict = TypeAliasType(
    "IncomingIntervalUnionTypedDict", Union[IntervalIncomingEnum, str]
)


IncomingIntervalUnion = TypeAliasType(
    "IncomingIntervalUnion", Union[IntervalIncomingEnum, str]
)


class IncomingResetTypedDict(TypedDict):
    interval: IncomingIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class IncomingReset(BaseModel):
    interval: IncomingIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncomingTierTypedDict(TypedDict):
    amount: float
    to: NotRequired[Any]


class IncomingTier(BaseModel):
    amount: float

    to: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["to"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


IncomingBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class IncomingPriceTypedDict(TypedDict):
    billing_units: float
    billing_method: IncomingBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[IncomingTierTypedDict]]


class IncomingPrice(BaseModel):
    billing_units: float

    billing_method: IncomingBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[IncomingTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncomingBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[IncomingResetTypedDict]
    price: Nullable[IncomingPriceTypedDict]
    expires_at: Nullable[float]
    object: Literal["balance_breakdown"]
    id: NotRequired[str]


class IncomingBreakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[IncomingReset]

    price: Nullable[IncomingPrice]

    expires_at: Nullable[float]

    object: Annotated[
        Annotated[
            Literal["balance_breakdown"],
            AfterValidator(validate_const("balance_breakdown")),
        ],
        pydantic.Field(alias="object"),
    ] = "balance_breakdown"

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncomingRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class IncomingRollover(BaseModel):
    balance: float

    expires_at: float


class IncomingBalancesTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    object: Literal["balance"]
    feature: NotRequired[IncomingFeatureTypedDict]
    breakdown: NotRequired[List[IncomingBreakdownTypedDict]]
    rollovers: NotRequired[List[IncomingRolloverTypedDict]]


class IncomingBalances(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    object: Annotated[
        Annotated[Literal["balance"], AfterValidator(validate_const("balance"))],
        pydantic.Field(alias="object"),
    ] = "balance"

    feature: Optional[IncomingFeature] = None

    breakdown: Optional[List[IncomingBreakdown]] = None

    rollovers: Optional[List[IncomingRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncomingTypedDict(TypedDict):
    plan: PlanTypedDict
    feature_quantities: List[IncomingFeatureQuantityTypedDict]
    balances: Dict[str, IncomingBalancesTypedDict]
    period_start: NotRequired[float]
    period_end: NotRequired[float]


class Incoming(BaseModel):
    plan: Plan

    feature_quantities: List[IncomingFeatureQuantity]

    balances: Dict[str, IncomingBalances]

    period_start: Optional[float] = None

    period_end: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["period_start", "period_end"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class OutgoingFeatureQuantityTypedDict(TypedDict):
    feature_id: str
    quantity: float


class OutgoingFeatureQuantity(BaseModel):
    feature_id: str

    quantity: float


OutgoingType = Union[
    Literal[
        "boolean",
        "metered",
        "credit_system",
    ],
    UnrecognizedStr,
]


class OutgoingCreditSchemaTypedDict(TypedDict):
    metered_feature_id: str
    credit_cost: float


class OutgoingCreditSchema(BaseModel):
    metered_feature_id: str

    credit_cost: float


class OutgoingDisplayTypedDict(TypedDict):
    singular: NotRequired[Nullable[str]]
    plural: NotRequired[Nullable[str]]


class OutgoingDisplay(BaseModel):
    singular: OptionalNullable[str] = UNSET

    plural: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["singular", "plural"])
        nullable_fields = set(["singular", "plural"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class OutgoingFeatureTypedDict(TypedDict):
    id: str
    name: str
    type: OutgoingType
    consumable: bool
    archived: bool
    event_names: NotRequired[List[str]]
    credit_schema: NotRequired[List[OutgoingCreditSchemaTypedDict]]
    display: NotRequired[OutgoingDisplayTypedDict]


class OutgoingFeature(BaseModel):
    id: str

    name: str

    type: OutgoingType

    consumable: bool

    archived: bool

    event_names: Optional[List[str]] = None

    credit_schema: Optional[List[OutgoingCreditSchema]] = None

    display: Optional[OutgoingDisplay] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["event_names", "credit_schema", "display"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


IntervalOutgoingEnum = Union[
    Literal[
        "one_off",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "quarter",
        "semi_annual",
        "year",
    ],
    UnrecognizedStr,
]


OutgoingIntervalUnionTypedDict = TypeAliasType(
    "OutgoingIntervalUnionTypedDict", Union[IntervalOutgoingEnum, str]
)


OutgoingIntervalUnion = TypeAliasType(
    "OutgoingIntervalUnion", Union[IntervalOutgoingEnum, str]
)


class OutgoingResetTypedDict(TypedDict):
    interval: OutgoingIntervalUnionTypedDict
    resets_at: Nullable[float]
    interval_count: NotRequired[float]


class OutgoingReset(BaseModel):
    interval: OutgoingIntervalUnion

    resets_at: Nullable[float]

    interval_count: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        nullable_fields = set(["resets_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class OutgoingTierTypedDict(TypedDict):
    amount: float
    to: NotRequired[Any]


class OutgoingTier(BaseModel):
    amount: float

    to: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["to"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


OutgoingBillingMethod = Union[
    Literal[
        "prepaid",
        "usage_based",
    ],
    UnrecognizedStr,
]


class OutgoingPriceTypedDict(TypedDict):
    billing_units: float
    billing_method: OutgoingBillingMethod
    max_purchase: Nullable[float]
    amount: NotRequired[float]
    tiers: NotRequired[List[OutgoingTierTypedDict]]


class OutgoingPrice(BaseModel):
    billing_units: float

    billing_method: OutgoingBillingMethod

    max_purchase: Nullable[float]

    amount: Optional[float] = None

    tiers: Optional[List[OutgoingTier]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["amount", "tiers"])
        nullable_fields = set(["max_purchase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class OutgoingBreakdownTypedDict(TypedDict):
    plan_id: Nullable[str]
    included_grant: float
    prepaid_grant: float
    remaining: float
    usage: float
    unlimited: bool
    reset: Nullable[OutgoingResetTypedDict]
    price: Nullable[OutgoingPriceTypedDict]
    expires_at: Nullable[float]
    object: Literal["balance_breakdown"]
    id: NotRequired[str]


class OutgoingBreakdown(BaseModel):
    plan_id: Nullable[str]

    included_grant: float

    prepaid_grant: float

    remaining: float

    usage: float

    unlimited: bool

    reset: Nullable[OutgoingReset]

    price: Nullable[OutgoingPrice]

    expires_at: Nullable[float]

    object: Annotated[
        Annotated[
            Literal["balance_breakdown"],
            AfterValidator(validate_const("balance_breakdown")),
        ],
        pydantic.Field(alias="object"),
    ] = "balance_breakdown"

    id: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        nullable_fields = set(["plan_id", "reset", "price", "expires_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class OutgoingRolloverTypedDict(TypedDict):
    balance: float
    expires_at: float


class OutgoingRollover(BaseModel):
    balance: float

    expires_at: float


class OutgoingBalancesTypedDict(TypedDict):
    feature_id: str
    granted: float
    remaining: float
    usage: float
    unlimited: bool
    overage_allowed: bool
    max_purchase: Nullable[float]
    next_reset_at: Nullable[float]
    object: Literal["balance"]
    feature: NotRequired[OutgoingFeatureTypedDict]
    breakdown: NotRequired[List[OutgoingBreakdownTypedDict]]
    rollovers: NotRequired[List[OutgoingRolloverTypedDict]]


class OutgoingBalances(BaseModel):
    feature_id: str

    granted: float

    remaining: float

    usage: float

    unlimited: bool

    overage_allowed: bool

    max_purchase: Nullable[float]

    next_reset_at: Nullable[float]

    object: Annotated[
        Annotated[Literal["balance"], AfterValidator(validate_const("balance"))],
        pydantic.Field(alias="object"),
    ] = "balance"

    feature: Optional[OutgoingFeature] = None

    breakdown: Optional[List[OutgoingBreakdown]] = None

    rollovers: Optional[List[OutgoingRollover]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["feature", "breakdown", "rollovers"])
        nullable_fields = set(["max_purchase", "next_reset_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class OutgoingTypedDict(TypedDict):
    plan: PlanTypedDict
    feature_quantities: List[OutgoingFeatureQuantityTypedDict]
    balances: Dict[str, OutgoingBalancesTypedDict]
    period_start: NotRequired[float]
    period_end: NotRequired[float]


class Outgoing(BaseModel):
    plan: Plan

    feature_quantities: List[OutgoingFeatureQuantity]

    balances: Dict[str, OutgoingBalances]

    period_start: Optional[float] = None

    period_end: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["period_start", "period_end"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RedirectType = Union[
    Literal[
        "stripe_checkout",
        "autumn_checkout",
    ],
    UnrecognizedStr,
]


class BillingPreviewAttachResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    line_items: List[BillingPreviewAttachLineItemTypedDict]
    total: float
    currency: str
    incoming: List[IncomingTypedDict]
    outgoing: List[OutgoingTypedDict]
    redirect_type: Nullable[RedirectType]
    period_start: NotRequired[float]
    period_end: NotRequired[float]
    credit: NotRequired[BillingPreviewAttachCreditTypedDict]
    next_cycle: NotRequired[BillingPreviewAttachNextCycleTypedDict]


class BillingPreviewAttachResponse(BaseModel):
    r"""OK"""

    customer_id: str

    line_items: List[BillingPreviewAttachLineItem]

    total: float

    currency: str

    incoming: List[Incoming]

    outgoing: List[Outgoing]

    redirect_type: Nullable[RedirectType]

    period_start: Optional[float] = None

    period_end: Optional[float] = None

    credit: Optional[BillingPreviewAttachCredit] = None

    next_cycle: Optional[BillingPreviewAttachNextCycle] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["period_start", "period_end", "credit", "next_cycle"])
        nullable_fields = set(["redirect_type"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    BillingPreviewAttachDiscountResponse.model_rebuild()
except NameError:
    pass
try:
    BillingPreviewAttachNextCycleDiscount.model_rebuild()
except NameError:
    pass
try:
    IncomingBreakdown.model_rebuild()
except NameError:
    pass
try:
    IncomingBalances.model_rebuild()
except NameError:
    pass
try:
    OutgoingBreakdown.model_rebuild()
except NameError:
    pass
try:
    OutgoingBalances.model_rebuild()
except NameError:
    pass
