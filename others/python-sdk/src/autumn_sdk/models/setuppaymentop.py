"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SetupPaymentGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class SetupPaymentGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetupPaymentFeatureQuantityTypedDict(TypedDict):
    r"""Quantity configuration for a prepaid feature."""

    feature_id: str
    r"""The ID of the feature to set quantity for."""
    quantity: NotRequired[float]
    r"""The quantity of the feature."""
    adjustable: NotRequired[bool]
    r"""Whether the customer can adjust the quantity."""


class SetupPaymentFeatureQuantity(BaseModel):
    r"""Quantity configuration for a prepaid feature."""

    feature_id: str
    r"""The ID of the feature to set quantity for."""

    quantity: Optional[float] = None
    r"""The quantity of the feature."""

    adjustable: Optional[bool] = None
    r"""Whether the customer can adjust the quantity."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "adjustable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SetupPaymentPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval (e.g. 'month', 'year')."""


class SetupPaymentBasePriceTypedDict(TypedDict):
    r"""Base price configuration for a plan."""

    amount: float
    r"""Base price amount for the plan."""
    interval: SetupPaymentPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""


class SetupPaymentBasePrice(BaseModel):
    r"""Base price configuration for a plan."""

    amount: float
    r"""Base price amount for the plan."""

    interval: SetupPaymentPriceInterval
    r"""Billing interval (e.g. 'month', 'year')."""

    interval_count: Optional[float] = None
    r"""Number of intervals per billing cycle. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SetupPaymentResetInterval = Literal[
    "one_off",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""


class SetupPaymentResetTypedDict(TypedDict):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: SetupPaymentResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""
    interval_count: NotRequired[float]
    r"""Number of intervals between resets. Defaults to 1."""


class SetupPaymentReset(BaseModel):
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    interval: SetupPaymentResetInterval
    r"""Interval at which balance resets (e.g. 'month', 'year'). For consumable features only."""

    interval_count: Optional[float] = None
    r"""Number of intervals between resets. Defaults to 1."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval_count"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SetupPaymentToTypedDict = TypeAliasType("SetupPaymentToTypedDict", Union[float, str])


SetupPaymentTo = TypeAliasType("SetupPaymentTo", Union[float, str])


class SetupPaymentTierTypedDict(TypedDict):
    to: SetupPaymentToTypedDict
    amount: float
    flat_amount: NotRequired[Nullable[float]]


class SetupPaymentTier(BaseModel):
    to: SetupPaymentTo

    amount: float

    flat_amount: OptionalNullable[float] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["flat_amount"])
        nullable_fields = set(["flat_amount"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


SetupPaymentTierBehavior = Literal[
    "graduated",
    "volume",
]


SetupPaymentItemPriceInterval = Literal[
    "one_off",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]
r"""Billing interval. For consumable features, should match reset.interval."""


SetupPaymentBillingMethod = Literal[
    "prepaid",
    "usage_based",
]
r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""


class SetupPaymentPriceTypedDict(TypedDict):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: SetupPaymentItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""
    billing_method: SetupPaymentBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""
    amount: NotRequired[float]
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""
    tiers: NotRequired[List[SetupPaymentTierTypedDict]]
    r"""Tiered pricing.  Either 'amount' or 'tiers' is required."""
    tier_behavior: NotRequired[SetupPaymentTierBehavior]
    interval_count: NotRequired[float]
    r"""Number of intervals per billing cycle. Defaults to 1."""
    billing_units: NotRequired[float]
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""
    max_purchase: NotRequired[float]
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""


class SetupPaymentPrice(BaseModel):
    r"""Pricing for usage beyond included units. Omit for free features."""

    interval: SetupPaymentItemPriceInterval
    r"""Billing interval. For consumable features, should match reset.interval."""

    billing_method: SetupPaymentBillingMethod
    r"""'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go."""

    amount: Optional[float] = None
    r"""Price per billing_units after included usage. Either 'amount' or 'tiers' is required."""

    tiers: Optional[List[SetupPaymentTier]] = None
    r"""Tiered pricing.  Either 'amount' or 'tiers' is required."""

    tier_behavior: Optional[SetupPaymentTierBehavior] = None

    interval_count: Optional[float] = 1
    r"""Number of intervals per billing cycle. Defaults to 1."""

    billing_units: Optional[float] = 1
    r"""Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200)."""

    max_purchase: Optional[float] = None
    r"""Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "amount",
                "tiers",
                "tier_behavior",
                "interval_count",
                "billing_units",
                "max_purchase",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SetupPaymentOnIncrease = Literal[
    "bill_immediately",
    "prorate_immediately",
    "prorate_next_cycle",
    "bill_next_cycle",
]
r"""Billing behavior when quantity increases mid-cycle."""


SetupPaymentOnDecrease = Literal[
    "prorate",
    "prorate_immediately",
    "prorate_next_cycle",
    "none",
    "no_prorations",
]
r"""Credit behavior when quantity decreases mid-cycle."""


class SetupPaymentProrationTypedDict(TypedDict):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: SetupPaymentOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""
    on_decrease: SetupPaymentOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


class SetupPaymentProration(BaseModel):
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    on_increase: SetupPaymentOnIncrease
    r"""Billing behavior when quantity increases mid-cycle."""

    on_decrease: SetupPaymentOnDecrease
    r"""Credit behavior when quantity decreases mid-cycle."""


SetupPaymentExpiryDurationType = Literal[
    "month",
    "forever",
]
r"""When rolled over units expire."""


class SetupPaymentRolloverTypedDict(TypedDict):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: SetupPaymentExpiryDurationType
    r"""When rolled over units expire."""
    max: NotRequired[float]
    r"""Max rollover units. Omit for unlimited rollover."""
    expiry_duration_length: NotRequired[float]
    r"""Number of periods before expiry."""


class SetupPaymentRollover(BaseModel):
    r"""Rollover config for unused units. If set, unused included units carry over."""

    expiry_duration_type: SetupPaymentExpiryDurationType
    r"""When rolled over units expire."""

    max: Optional[float] = None
    r"""Max rollover units. Omit for unlimited rollover."""

    expiry_duration_length: Optional[float] = None
    r"""Number of periods before expiry."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["max", "expiry_duration_length"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetupPaymentPlanItemTypedDict(TypedDict):
    r"""Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings."""

    feature_id: str
    r"""The ID of the feature to configure."""
    included: NotRequired[float]
    r"""Number of free units included. Balance resets to this each interval for consumable features."""
    unlimited: NotRequired[bool]
    r"""If true, customer has unlimited access to this feature."""
    reset: NotRequired[SetupPaymentResetTypedDict]
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""
    price: NotRequired[SetupPaymentPriceTypedDict]
    r"""Pricing for usage beyond included units. Omit for free features."""
    proration: NotRequired[SetupPaymentProrationTypedDict]
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""
    rollover: NotRequired[SetupPaymentRolloverTypedDict]
    r"""Rollover config for unused units. If set, unused included units carry over."""


class SetupPaymentPlanItem(BaseModel):
    r"""Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings."""

    feature_id: str
    r"""The ID of the feature to configure."""

    included: Optional[float] = None
    r"""Number of free units included. Balance resets to this each interval for consumable features."""

    unlimited: Optional[bool] = None
    r"""If true, customer has unlimited access to this feature."""

    reset: Optional[SetupPaymentReset] = None
    r"""Reset configuration for consumable features. Omit for non-consumable features like seats."""

    price: Optional[SetupPaymentPrice] = None
    r"""Pricing for usage beyond included units. Omit for free features."""

    proration: Optional[SetupPaymentProration] = None
    r"""Proration settings for prepaid features. Controls mid-cycle quantity change billing."""

    rollover: Optional[SetupPaymentRollover] = None
    r"""Rollover config for unused units. If set, unused included units carry over."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["included", "unlimited", "reset", "price", "proration", "rollover"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SetupPaymentDurationType = Literal[
    "day",
    "month",
    "year",
]
r"""Unit of time for the trial ('day', 'month', 'year')."""


class SetupPaymentFreeTrialParamsTypedDict(TypedDict):
    r"""Free trial configuration for a plan."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""
    duration_type: NotRequired[SetupPaymentDurationType]
    r"""Unit of time for the trial ('day', 'month', 'year')."""
    card_required: NotRequired[bool]
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""


class SetupPaymentFreeTrialParams(BaseModel):
    r"""Free trial configuration for a plan."""

    duration_length: float
    r"""Number of duration_type periods the trial lasts."""

    duration_type: Optional[SetupPaymentDurationType] = "month"
    r"""Unit of time for the trial ('day', 'month', 'year')."""

    card_required: Optional[bool] = True
    r"""If true, payment method required to start trial. Customer is charged after trial ends."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration_type", "card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetupPaymentCustomizeTypedDict(TypedDict):
    r"""Customize the plan to attach. Can override the price, items, free trial, or a combination."""

    price: NotRequired[Nullable[SetupPaymentBasePriceTypedDict]]
    r"""Override the base price of the plan. Pass null to remove the base price."""
    items: NotRequired[List[SetupPaymentPlanItemTypedDict]]
    r"""Override the items in the plan."""
    free_trial: NotRequired[Nullable[SetupPaymentFreeTrialParamsTypedDict]]
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""


class SetupPaymentCustomize(BaseModel):
    r"""Customize the plan to attach. Can override the price, items, free trial, or a combination."""

    price: OptionalNullable[SetupPaymentBasePrice] = UNSET
    r"""Override the base price of the plan. Pass null to remove the base price."""

    items: Optional[List[SetupPaymentPlanItem]] = None
    r"""Override the items in the plan."""

    free_trial: OptionalNullable[SetupPaymentFreeTrialParams] = UNSET
    r"""Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["price", "items", "free_trial"])
        nullable_fields = set(["price", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


SetupPaymentProrationBehavior = Literal[
    "prorate_immediately",
    "none",
]
r"""How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges."""


class SetupPaymentAttachDiscountTypedDict(TypedDict):
    r"""A discount to apply. Can be either a reward ID or a promotion code."""

    reward_id: NotRequired[str]
    r"""The ID of the reward to apply as a discount."""
    promotion_code: NotRequired[str]
    r"""The promotion code to apply as a discount."""


class SetupPaymentAttachDiscount(BaseModel):
    r"""A discount to apply. Can be either a reward ID or a promotion code."""

    reward_id: Optional[str] = None
    r"""The ID of the reward to apply as a discount."""

    promotion_code: Optional[str] = None
    r"""The promotion code to apply as a discount."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["reward_id", "promotion_code"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetupPaymentParamsTypedDict(TypedDict):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""
    entity_id: NotRequired[str]
    r"""The ID of the entity to attach the plan to."""
    plan_id: NotRequired[str]
    r"""If specified, the plan will be attached to the customer after setup."""
    feature_quantities: NotRequired[List[SetupPaymentFeatureQuantityTypedDict]]
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""
    version: NotRequired[float]
    r"""The version of the plan to attach."""
    customize: NotRequired[SetupPaymentCustomizeTypedDict]
    r"""Customize the plan to attach. Can override the price, items, free trial, or a combination."""
    proration_behavior: NotRequired[SetupPaymentProrationBehavior]
    r"""How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges."""
    discounts: NotRequired[List[SetupPaymentAttachDiscountTypedDict]]
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""
    success_url: NotRequired[str]
    r"""URL to redirect to after successful checkout."""
    checkout_session_params: NotRequired[Dict[str, Any]]
    r"""Additional parameters to pass into the creation of the Stripe checkout session."""


class SetupPaymentParams(BaseModel):
    customer_id: str
    r"""The ID of the customer to attach the plan to."""

    entity_id: Optional[str] = None
    r"""The ID of the entity to attach the plan to."""

    plan_id: Optional[str] = None
    r"""If specified, the plan will be attached to the customer after setup."""

    feature_quantities: Optional[List[SetupPaymentFeatureQuantity]] = None
    r"""If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan."""

    version: Optional[float] = None
    r"""The version of the plan to attach."""

    customize: Optional[SetupPaymentCustomize] = None
    r"""Customize the plan to attach. Can override the price, items, free trial, or a combination."""

    proration_behavior: Optional[SetupPaymentProrationBehavior] = None
    r"""How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges."""

    discounts: Optional[List[SetupPaymentAttachDiscount]] = None
    r"""List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code."""

    success_url: Optional[str] = None
    r"""URL to redirect to after successful checkout."""

    checkout_session_params: Optional[Dict[str, Any]] = None
    r"""Additional parameters to pass into the creation of the Stripe checkout session."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entity_id",
                "plan_id",
                "feature_quantities",
                "version",
                "customize",
                "proration_behavior",
                "discounts",
                "success_url",
                "checkout_session_params",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetupPaymentResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer"""
    url: str
    r"""URL to redirect the customer to setup their payment."""
    entity_id: NotRequired[str]
    r"""The ID of the entity the plan (if specified) will be attached to after setup."""


class SetupPaymentResponse(BaseModel):
    r"""OK"""

    customer_id: str
    r"""The ID of the customer"""

    url: str
    r"""URL to redirect the customer to setup their payment."""

    entity_id: Optional[str] = None
    r"""The ID of the entity the plan (if specified) will be attached to after setup."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["entity_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
