"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from autumn_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from autumn_sdk.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class AttachGlobalsTypedDict(TypedDict):
    x_api_version: NotRequired[str]


class AttachGlobals(BaseModel):
    x_api_version: Annotated[
        Optional[str],
        pydantic.Field(alias="x-api-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = "2.1"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["x-api-version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class OptionsTypedDict(TypedDict):
    feature_id: str
    quantity: NotRequired[float]
    reset_after_trial_end: NotRequired[bool]


class Options(BaseModel):
    feature_id: str

    quantity: Optional[float] = None

    reset_after_trial_end: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["quantity", "reset_after_trial_end"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


Duration = Literal[
    "day",
    "month",
    "year",
]


class AttachFreeTrialTypedDict(TypedDict):
    length: float
    duration: Duration
    card_required: NotRequired[bool]


class AttachFreeTrial(BaseModel):
    length: float

    duration: Duration

    card_required: Optional[bool] = True

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["card_required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


AttachType = Literal[
    "feature",
    "priced_feature",
    "price",
]


IncludedUsageTypedDict = TypeAliasType("IncludedUsageTypedDict", Union[float, str])


IncludedUsage = TypeAliasType("IncludedUsage", Union[float, str])


AttachInterval = Literal[
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "semi_annual",
    "year",
]


UsageModel = Literal[
    "prepaid",
    "pay_per_use",
]


AttachToTypedDict = TypeAliasType("AttachToTypedDict", Union[float, str])
r"""The maximum amount of usage for this tier."""


AttachTo = TypeAliasType("AttachTo", Union[float, str])
r"""The maximum amount of usage for this tier."""


class TiersTypedDict(TypedDict):
    to: AttachToTypedDict
    r"""The maximum amount of usage for this tier."""
    amount: float
    r"""The price of the product item for this tier."""


class Tiers(BaseModel):
    to: AttachTo
    r"""The maximum amount of usage for this tier."""

    amount: float
    r"""The price of the product item for this tier."""


class AttachItemTypedDict(TypedDict):
    type: NotRequired[Nullable[AttachType]]
    r"""The type of the product item."""
    feature_id: NotRequired[Nullable[str]]
    r"""The feature ID of the product item. Should be null for fixed price items."""
    included_usage: NotRequired[Nullable[IncludedUsageTypedDict]]
    r"""The amount of usage included for this feature (per interval)."""
    interval: NotRequired[Nullable[AttachInterval]]
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""
    interval_count: NotRequired[Nullable[float]]
    r"""Interval count of the feature."""
    entity_feature_id: NotRequired[Nullable[str]]
    r"""The feature ID of the entity (like seats) to track sub-balances for."""
    usage_model: NotRequired[Nullable[UsageModel]]
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""
    price: NotRequired[Nullable[float]]
    r"""The price of the product item. Should be null if tiered pricing is set."""
    tiers: NotRequired[Nullable[List[TiersTypedDict]]]
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""
    billing_units: NotRequired[Nullable[float]]
    r"""The billing units of the product item (eg $1 for 30 credits)."""
    reset_usage_when_enabled: NotRequired[Nullable[bool]]
    r"""Whether the usage should be reset when the product is enabled."""


class AttachItem(BaseModel):
    type: OptionalNullable[AttachType] = UNSET
    r"""The type of the product item."""

    feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID of the product item. Should be null for fixed price items."""

    included_usage: OptionalNullable[IncludedUsage] = UNSET
    r"""The amount of usage included for this feature (per interval)."""

    interval: OptionalNullable[AttachInterval] = UNSET
    r"""The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off."""

    interval_count: OptionalNullable[float] = UNSET
    r"""Interval count of the feature."""

    entity_feature_id: OptionalNullable[str] = UNSET
    r"""The feature ID of the entity (like seats) to track sub-balances for."""

    usage_model: OptionalNullable[UsageModel] = UNSET
    r"""Whether the feature should be prepaid upfront or billed for how much they use end of billing period."""

    price: OptionalNullable[float] = UNSET
    r"""The price of the product item. Should be null if tiered pricing is set."""

    tiers: OptionalNullable[List[Tiers]] = UNSET
    r"""Tiered pricing for the product item. Not applicable for fixed price items."""

    billing_units: OptionalNullable[float] = UNSET
    r"""The billing units of the product item (eg $1 for 30 credits)."""

    reset_usage_when_enabled: OptionalNullable[bool] = UNSET
    r"""Whether the usage should be reset when the product is enabled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "type",
                "feature_id",
                "included_usage",
                "interval",
                "interval_count",
                "entity_feature_id",
                "usage_model",
                "price",
                "tiers",
                "billing_units",
                "reset_usage_when_enabled",
            ]
        )
        nullable_fields = set(
            [
                "type",
                "feature_id",
                "included_usage",
                "interval",
                "interval_count",
                "entity_feature_id",
                "usage_model",
                "price",
                "tiers",
                "billing_units",
                "reset_usage_when_enabled",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RedirectMode = Literal[
    "always",
    "if_required",
    "never",
]


PlanSchedule = Literal[
    "immediate",
    "end_of_cycle",
]


BillingBehavior = Literal[
    "prorate_immediately",
    "next_cycle_only",
]


class AttachRequestTypedDict(TypedDict):
    product_id: str
    options: NotRequired[Nullable[List[OptionsTypedDict]]]
    version: NotRequired[float]
    free_trial: NotRequired[Nullable[AttachFreeTrialTypedDict]]
    items: NotRequired[List[AttachItemTypedDict]]
    invoice: NotRequired[bool]
    enable_product_immediately: NotRequired[bool]
    finalize_invoice: NotRequired[bool]
    redirect_mode: NotRequired[RedirectMode]
    success_url: NotRequired[str]
    new_billing_subscription: NotRequired[bool]
    plan_schedule: NotRequired[PlanSchedule]
    billing_behavior: NotRequired[BillingBehavior]
    adjustable_quantity: NotRequired[bool]


class AttachRequest(BaseModel):
    product_id: str

    options: OptionalNullable[List[Options]] = UNSET

    version: Optional[float] = None

    free_trial: OptionalNullable[AttachFreeTrial] = UNSET

    items: Optional[List[AttachItem]] = None

    invoice: Optional[bool] = None

    enable_product_immediately: Optional[bool] = None

    finalize_invoice: Optional[bool] = None

    redirect_mode: Optional[RedirectMode] = "always"

    success_url: Optional[str] = None

    new_billing_subscription: Optional[bool] = None

    plan_schedule: Optional[PlanSchedule] = None

    billing_behavior: Optional[BillingBehavior] = None

    adjustable_quantity: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "options",
                "version",
                "free_trial",
                "items",
                "invoice",
                "enable_product_immediately",
                "finalize_invoice",
                "redirect_mode",
                "success_url",
                "new_billing_subscription",
                "plan_schedule",
                "billing_behavior",
                "adjustable_quantity",
            ]
        )
        nullable_fields = set(["options", "free_trial"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class AttachInvoiceTypedDict(TypedDict):
    status: Nullable[str]
    stripe_id: str
    total: float
    currency: str
    hosted_invoice_url: Nullable[str]


class AttachInvoice(BaseModel):
    status: Nullable[str]

    stripe_id: str

    total: float

    currency: str

    hosted_invoice_url: Nullable[str]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


Code = Union[
    Literal[
        "3ds_required",
        "payment_method_required",
        "payment_failed",
    ],
    UnrecognizedStr,
]


class RequiredActionTypedDict(TypedDict):
    code: Code
    reason: str


class RequiredAction(BaseModel):
    code: Code

    reason: str


class AttachResponseTypedDict(TypedDict):
    r"""OK"""

    customer_id: str
    payment_url: Nullable[str]
    invoice: NotRequired[AttachInvoiceTypedDict]
    required_action: NotRequired[RequiredActionTypedDict]


class AttachResponse(BaseModel):
    r"""OK"""

    customer_id: str

    payment_url: Nullable[str]

    invoice: Optional[AttachInvoice] = None

    required_action: Optional[RequiredAction] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["invoice", "required_action"])
        nullable_fields = set(["payment_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
