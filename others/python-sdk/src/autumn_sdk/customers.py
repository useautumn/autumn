"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from autumn_sdk import errors, models, utils
from autumn_sdk._hooks import HookContext
from autumn_sdk.types import Nullable, OptionalNullable, UNSET
from autumn_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional


class Customers(BaseSDK):
    def get_or_create(
        self,
        *,
        customer_id: Nullable[str],
        name: OptionalNullable[str] = UNSET,
        email: OptionalNullable[str] = UNSET,
        fingerprint: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[Dict[str, Any]] = UNSET,
        stripe_id: OptionalNullable[str] = UNSET,
        create_in_stripe: Optional[bool] = None,
        auto_enable_plan_id: Optional[str] = None,
        send_email_receipts: Optional[bool] = None,
        expand: Optional[List[models.CustomerExpand]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Customer:
        r"""Creates a customer if they do not exist, or returns the existing customer by your external customer ID.

        Use this as the primary entrypoint before billing operations so the customer record is always present and up to date.

        @example
        ```typescript
        // Create or fetch a customer by external ID
        const response = await client.getOrCreate({


            \"id\": \"cus_123\",
            \"name\": \"John Doe\",
            \"email\": \"john@example.com\"
          });
        ```

        :param customer_id:
        :param name: Customer's name
        :param email: Customer's email address
        :param fingerprint: Unique identifier (eg, serial number) to detect duplicate customers and prevent free trial abuse
        :param metadata: Additional metadata for the customer
        :param stripe_id: Stripe customer ID if you already have one
        :param create_in_stripe: Whether to create the customer in Stripe
        :param auto_enable_plan_id: The ID of the free plan to auto-enable for the customer
        :param send_email_receipts: Whether to send email receipts to this customer
        :param expand: Customer expand options
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrCreateCustomerParams(
            customer_id=customer_id,
            name=name,
            email=email,
            fingerprint=fingerprint,
            metadata=metadata,
            stripe_id=stripe_id,
            create_in_stripe=create_in_stripe,
            auto_enable_plan_id=auto_enable_plan_id,
            send_email_receipts=send_email_receipts,
            expand=expand,
        )

        req = self._build_request(
            method="POST",
            path="/v1/customers.getOrCreate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetOrCreateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetOrCreateCustomerParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getOrCreate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Customer, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def get_or_create_async(
        self,
        *,
        customer_id: Nullable[str],
        name: OptionalNullable[str] = UNSET,
        email: OptionalNullable[str] = UNSET,
        fingerprint: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[Dict[str, Any]] = UNSET,
        stripe_id: OptionalNullable[str] = UNSET,
        create_in_stripe: Optional[bool] = None,
        auto_enable_plan_id: Optional[str] = None,
        send_email_receipts: Optional[bool] = None,
        expand: Optional[List[models.CustomerExpand]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Customer:
        r"""Creates a customer if they do not exist, or returns the existing customer by your external customer ID.

        Use this as the primary entrypoint before billing operations so the customer record is always present and up to date.

        @example
        ```typescript
        // Create or fetch a customer by external ID
        const response = await client.getOrCreate({


            \"id\": \"cus_123\",
            \"name\": \"John Doe\",
            \"email\": \"john@example.com\"
          });
        ```

        :param customer_id:
        :param name: Customer's name
        :param email: Customer's email address
        :param fingerprint: Unique identifier (eg, serial number) to detect duplicate customers and prevent free trial abuse
        :param metadata: Additional metadata for the customer
        :param stripe_id: Stripe customer ID if you already have one
        :param create_in_stripe: Whether to create the customer in Stripe
        :param auto_enable_plan_id: The ID of the free plan to auto-enable for the customer
        :param send_email_receipts: Whether to send email receipts to this customer
        :param expand: Customer expand options
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrCreateCustomerParams(
            customer_id=customer_id,
            name=name,
            email=email,
            fingerprint=fingerprint,
            metadata=metadata,
            stripe_id=stripe_id,
            create_in_stripe=create_in_stripe,
            auto_enable_plan_id=auto_enable_plan_id,
            send_email_receipts=send_email_receipts,
            expand=expand,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/customers.getOrCreate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetOrCreateGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetOrCreateCustomerParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getOrCreate",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Customer, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)
