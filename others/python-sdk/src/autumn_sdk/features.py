"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from autumn_sdk import errors, models, utils
from autumn_sdk._hooks import HookContext
from autumn_sdk.types import BaseModel, OptionalNullable, UNSET
from autumn_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union, cast


class Features(BaseSDK):
    def create(
        self,
        *,
        name: str,
        type_: models.CreateFeatureTypeRequest,
        feature_id: str,
        consumable: Optional[bool] = None,
        display: Optional[
            Union[
                models.CreateFeatureDisplayRequest,
                models.CreateFeatureDisplayRequestTypedDict,
            ]
        ] = None,
        credit_schema: Optional[
            Union[
                List[models.CreateFeatureCreditSchemaRequest],
                List[models.CreateFeatureCreditSchemaRequestTypedDict],
            ]
        ] = None,
        event_names: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateFeatureResponse:
        r"""Creates a new feature.

        Use this to programmatically create features for metering usage, managing access, or building credit systems.

        :param name: The name of the feature.
        :param type: The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
        :param feature_id: The ID of the feature to create.
        :param consumable: Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
        :param display: Singular and plural display names for the feature in your user interface.
        :param credit_schema: A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
        :param event_names:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateFeatureParams(
            name=name,
            type=type_,
            consumable=consumable,
            display=utils.get_pydantic_model(
                display, Optional[models.CreateFeatureDisplayRequest]
            ),
            credit_schema=utils.get_pydantic_model(
                credit_schema, Optional[List[models.CreateFeatureCreditSchemaRequest]]
            ),
            event_names=event_names,
            feature_id=feature_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/features.create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.CreateFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreateFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        name: str,
        type_: models.CreateFeatureTypeRequest,
        feature_id: str,
        consumable: Optional[bool] = None,
        display: Optional[
            Union[
                models.CreateFeatureDisplayRequest,
                models.CreateFeatureDisplayRequestTypedDict,
            ]
        ] = None,
        credit_schema: Optional[
            Union[
                List[models.CreateFeatureCreditSchemaRequest],
                List[models.CreateFeatureCreditSchemaRequestTypedDict],
            ]
        ] = None,
        event_names: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateFeatureResponse:
        r"""Creates a new feature.

        Use this to programmatically create features for metering usage, managing access, or building credit systems.

        :param name: The name of the feature.
        :param type: The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
        :param feature_id: The ID of the feature to create.
        :param consumable: Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
        :param display: Singular and plural display names for the feature in your user interface.
        :param credit_schema: A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
        :param event_names:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateFeatureParams(
            name=name,
            type=type_,
            consumable=consumable,
            display=utils.get_pydantic_model(
                display, Optional[models.CreateFeatureDisplayRequest]
            ),
            credit_schema=utils.get_pydantic_model(
                credit_schema, Optional[List[models.CreateFeatureCreditSchemaRequest]]
            ),
            event_names=event_names,
            feature_id=feature_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/features.create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.CreateFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreateFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def get(
        self,
        *,
        feature_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFeatureResponse:
        r"""Retrieves a single feature by its ID.

        Use this when you need to fetch the details of a specific feature.

        :param feature_id: The ID of the feature.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFeatureParams(
            feature_id=feature_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/features.get",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def get_async(
        self,
        *,
        feature_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFeatureResponse:
        r"""Retrieves a single feature by its ID.

        Use this when you need to fetch the details of a specific feature.

        :param feature_id: The ID of the feature.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFeatureParams(
            feature_id=feature_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/features.get",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def list(
        self,
        *,
        request: Union[
            models.ListFeaturesRequest, models.ListFeaturesRequestTypedDict
        ] = models.ListFeaturesRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListFeaturesResponse:
        r"""Lists all features in the current environment.

        Use this to retrieve all features configured for your organization to display in dashboards or for feature management.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.ListFeaturesRequest)
        request = cast(models.ListFeaturesRequest, request)

        req = self._build_request(
            method="POST",
            path="/v1/features.list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.ListFeaturesGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listFeatures",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListFeaturesResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        request: Union[
            models.ListFeaturesRequest, models.ListFeaturesRequestTypedDict
        ] = models.ListFeaturesRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListFeaturesResponse:
        r"""Lists all features in the current environment.

        Use this to retrieve all features configured for your organization to display in dashboards or for feature management.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.ListFeaturesRequest)
        request = cast(models.ListFeaturesRequest, request)

        req = self._build_request_async(
            method="POST",
            path="/v1/features.list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.ListFeaturesGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listFeatures",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListFeaturesResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        feature_id: str,
        name: Optional[str] = None,
        type_: Optional[models.UpdateFeatureTypeRequest] = None,
        consumable: Optional[bool] = None,
        display: Optional[
            Union[
                models.UpdateFeatureDisplayRequest,
                models.UpdateFeatureDisplayRequestTypedDict,
            ]
        ] = None,
        credit_schema: Optional[
            Union[
                List[models.UpdateFeatureCreditSchemaRequest],
                List[models.UpdateFeatureCreditSchemaRequestTypedDict],
            ]
        ] = None,
        event_names: Optional[List[str]] = None,
        archived: Optional[bool] = None,
        new_feature_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateFeatureResponse:
        r"""Updates an existing feature.

        Use this to modify feature properties like name, display settings, or to archive a feature.

        :param feature_id: The ID of the feature to update.
        :param name: The name of the feature.
        :param type: The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
        :param consumable: Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
        :param display: Singular and plural display names for the feature in your user interface.
        :param credit_schema: A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
        :param event_names:
        :param archived: Whether the feature is archived. Archived features are hidden from the dashboard.
        :param new_feature_id: The new ID of the feature. Feature ID can only be updated if it's not being used by any customers.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateFeatureParams(
            name=name,
            type=type_,
            consumable=consumable,
            display=utils.get_pydantic_model(
                display, Optional[models.UpdateFeatureDisplayRequest]
            ),
            credit_schema=utils.get_pydantic_model(
                credit_schema, Optional[List[models.UpdateFeatureCreditSchemaRequest]]
            ),
            event_names=event_names,
            archived=archived,
            feature_id=feature_id,
            new_feature_id=new_feature_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/features.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.UpdateFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        feature_id: str,
        name: Optional[str] = None,
        type_: Optional[models.UpdateFeatureTypeRequest] = None,
        consumable: Optional[bool] = None,
        display: Optional[
            Union[
                models.UpdateFeatureDisplayRequest,
                models.UpdateFeatureDisplayRequestTypedDict,
            ]
        ] = None,
        credit_schema: Optional[
            Union[
                List[models.UpdateFeatureCreditSchemaRequest],
                List[models.UpdateFeatureCreditSchemaRequestTypedDict],
            ]
        ] = None,
        event_names: Optional[List[str]] = None,
        archived: Optional[bool] = None,
        new_feature_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateFeatureResponse:
        r"""Updates an existing feature.

        Use this to modify feature properties like name, display settings, or to archive a feature.

        :param feature_id: The ID of the feature to update.
        :param name: The name of the feature.
        :param type: The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
        :param consumable: Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
        :param display: Singular and plural display names for the feature in your user interface.
        :param credit_schema: A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
        :param event_names:
        :param archived: Whether the feature is archived. Archived features are hidden from the dashboard.
        :param new_feature_id: The new ID of the feature. Feature ID can only be updated if it's not being used by any customers.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateFeatureParams(
            name=name,
            type=type_,
            consumable=consumable,
            display=utils.get_pydantic_model(
                display, Optional[models.UpdateFeatureDisplayRequest]
            ),
            credit_schema=utils.get_pydantic_model(
                credit_schema, Optional[List[models.UpdateFeatureCreditSchemaRequest]]
            ),
            event_names=event_names,
            archived=archived,
            feature_id=feature_id,
            new_feature_id=new_feature_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/features.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.UpdateFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdateFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        feature_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteFeatureResponse:
        r"""Deletes a feature by its ID.

        Use this to permanently remove a feature. Note: features that are used in products cannot be deleted - archive them instead.

        :param feature_id: The ID of the feature to delete.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteFeatureParams(
            feature_id=feature_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/features.delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeleteFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeleteFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        feature_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteFeatureResponse:
        r"""Deletes a feature by its ID.

        Use this to permanently remove a feature. Note: features that are used in products cannot be deleted - archive them instead.

        :param feature_id: The ID of the feature to delete.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteFeatureParams(
            feature_id=feature_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/features.delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeleteFeatureGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeleteFeatureParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteFeature",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeleteFeatureResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)
