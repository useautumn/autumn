"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from autumn_sdk import errors, models, utils
from autumn_sdk._hooks import HookContext
from autumn_sdk.types import BaseModel, OptionalNullable, UNSET
from autumn_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union, cast


class Plans(BaseSDK):
    def create(
        self,
        *,
        plan_id: str,
        name: str,
        group: Optional[str] = "",
        description: OptionalNullable[str] = UNSET,
        add_on: Optional[bool] = False,
        auto_enable: Optional[bool] = False,
        price: Optional[
            Union[models.CreatePlanPriceRequest, models.CreatePlanPriceRequestTypedDict]
        ] = None,
        items: Optional[
            Union[
                List[models.CreatePlanItemRequest],
                List[models.CreatePlanItemRequestTypedDict],
            ]
        ] = None,
        free_trial: Optional[
            Union[
                models.CreatePlanFreeTrialRequest,
                models.CreatePlanFreeTrialRequestTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreatePlanResponse:
        r"""Create a plan

        Creates a new plan with optional base price and feature configurations.

        Use this to programmatically create pricing plans. See [How plans work](/documentation/pricing/plans) for concepts.

        :param plan_id: The ID of the plan to create.
        :param name: Display name of the plan.
        :param group: Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
        :param description: Optional description of the plan.
        :param add_on: If true, this plan can be attached alongside other plans. Otherwise, attaching replaces existing plans in the same group.
        :param auto_enable: If true, plan is automatically attached when a customer is created. Use for free tiers.
        :param price: Base recurring price for the plan. Omit for free or usage-only plans.
        :param items: Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
        :param free_trial: Free trial configuration. Customers can try this plan before being charged.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreatePlanParams(
            plan_id=plan_id,
            group=group,
            name=name,
            description=description,
            add_on=add_on,
            auto_enable=auto_enable,
            price=utils.get_pydantic_model(
                price, Optional[models.CreatePlanPriceRequest]
            ),
            items=utils.get_pydantic_model(
                items, Optional[List[models.CreatePlanItemRequest]]
            ),
            free_trial=utils.get_pydantic_model(
                free_trial, Optional[models.CreatePlanFreeTrialRequest]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/plans.create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.CreatePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreatePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createPlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreatePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        plan_id: str,
        name: str,
        group: Optional[str] = "",
        description: OptionalNullable[str] = UNSET,
        add_on: Optional[bool] = False,
        auto_enable: Optional[bool] = False,
        price: Optional[
            Union[models.CreatePlanPriceRequest, models.CreatePlanPriceRequestTypedDict]
        ] = None,
        items: Optional[
            Union[
                List[models.CreatePlanItemRequest],
                List[models.CreatePlanItemRequestTypedDict],
            ]
        ] = None,
        free_trial: Optional[
            Union[
                models.CreatePlanFreeTrialRequest,
                models.CreatePlanFreeTrialRequestTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreatePlanResponse:
        r"""Create a plan

        Creates a new plan with optional base price and feature configurations.

        Use this to programmatically create pricing plans. See [How plans work](/documentation/pricing/plans) for concepts.

        :param plan_id: The ID of the plan to create.
        :param name: Display name of the plan.
        :param group: Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
        :param description: Optional description of the plan.
        :param add_on: If true, this plan can be attached alongside other plans. Otherwise, attaching replaces existing plans in the same group.
        :param auto_enable: If true, plan is automatically attached when a customer is created. Use for free tiers.
        :param price: Base recurring price for the plan. Omit for free or usage-only plans.
        :param items: Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
        :param free_trial: Free trial configuration. Customers can try this plan before being charged.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreatePlanParams(
            plan_id=plan_id,
            group=group,
            name=name,
            description=description,
            add_on=add_on,
            auto_enable=auto_enable,
            price=utils.get_pydantic_model(
                price, Optional[models.CreatePlanPriceRequest]
            ),
            items=utils.get_pydantic_model(
                items, Optional[List[models.CreatePlanItemRequest]]
            ),
            free_trial=utils.get_pydantic_model(
                free_trial, Optional[models.CreatePlanFreeTrialRequest]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/plans.create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.CreatePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreatePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createPlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreatePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def get(
        self,
        *,
        plan_id: str,
        version: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetPlanResponse:
        r"""Get a plan

        Retrieves a single plan by its ID.

        Use this to fetch the full configuration of a specific plan, including its features and pricing.

        :param plan_id: The ID of the plan to retrieve.
        :param version: The version of the plan to get. Defaults to the latest version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPlanParams(
            plan_id=plan_id,
            version=version,
        )

        req = self._build_request(
            method="POST",
            path="/v1/plans.get",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetPlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetPlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getPlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetPlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def get_async(
        self,
        *,
        plan_id: str,
        version: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetPlanResponse:
        r"""Get a plan

        Retrieves a single plan by its ID.

        Use this to fetch the full configuration of a specific plan, including its features and pricing.

        :param plan_id: The ID of the plan to retrieve.
        :param version: The version of the plan to get. Defaults to the latest version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPlanParams(
            plan_id=plan_id,
            version=version,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/plans.get",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.GetPlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetPlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getPlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetPlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def list(
        self,
        *,
        request: Optional[
            Union[models.ListPlansParams, models.ListPlansParamsTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListPlansResponse:
        r"""List all plans

        Lists all plans in the current environment.

        Use this to retrieve all plans for displaying pricing pages or managing plan configurations.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, Optional[models.ListPlansParams])
        request = cast(Optional[models.ListPlansParams], request)

        req = self._build_request(
            method="POST",
            path="/v1/plans.list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.ListPlansGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.ListPlansParams]
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listPlans",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListPlansResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        request: Optional[
            Union[models.ListPlansParams, models.ListPlansParamsTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListPlansResponse:
        r"""List all plans

        Lists all plans in the current environment.

        Use this to retrieve all plans for displaying pricing pages or managing plan configurations.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, Optional[models.ListPlansParams])
        request = cast(Optional[models.ListPlansParams], request)

        req = self._build_request_async(
            method="POST",
            path="/v1/plans.list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.ListPlansGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[models.ListPlansParams]
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listPlans",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListPlansResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        plan_id: str,
        group: Optional[str] = "",
        name: Optional[str] = None,
        description: Optional[str] = None,
        add_on: Optional[bool] = None,
        auto_enable: Optional[bool] = None,
        price: OptionalNullable[
            Union[models.UpdatePlanPriceRequest, models.UpdatePlanPriceRequestTypedDict]
        ] = UNSET,
        items: Optional[
            Union[
                List[models.UpdatePlanItemRequest],
                List[models.UpdatePlanItemRequestTypedDict],
            ]
        ] = None,
        free_trial: OptionalNullable[
            Union[
                models.UpdatePlanFreeTrialRequest,
                models.UpdatePlanFreeTrialRequestTypedDict,
            ]
        ] = UNSET,
        version: Optional[float] = None,
        archived: Optional[bool] = False,
        new_plan_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdatePlanResponse:
        r"""Update a plan

        Updates an existing plan. Creates a new version unless `disableVersion` is set.

        Use this to modify plan properties, pricing, or feature configurations. See [Adding features to plans](/documentation/pricing/plan-features) for item configuration.

        :param plan_id: The ID of the plan to update.
        :param group: Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
        :param name: Display name of the plan.
        :param description:
        :param add_on: Whether the plan is an add-on.
        :param auto_enable: Whether the plan is automatically enabled.
        :param price: The price of the plan. Set to null to remove the base price.
        :param items: Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
        :param free_trial: The free trial of the plan. Set to null to remove the free trial.
        :param version:
        :param archived:
        :param new_plan_id: The new ID to use for the plan. Can only be updated if the plan has not been used by any customers.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdatePlanParams(
            plan_id=plan_id,
            group=group,
            name=name,
            description=description,
            add_on=add_on,
            auto_enable=auto_enable,
            price=utils.get_pydantic_model(
                price, OptionalNullable[models.UpdatePlanPriceRequest]
            ),
            items=utils.get_pydantic_model(
                items, Optional[List[models.UpdatePlanItemRequest]]
            ),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.UpdatePlanFreeTrialRequest]
            ),
            version=version,
            archived=archived,
            new_plan_id=new_plan_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/plans.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.UpdatePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdatePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updatePlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdatePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        plan_id: str,
        group: Optional[str] = "",
        name: Optional[str] = None,
        description: Optional[str] = None,
        add_on: Optional[bool] = None,
        auto_enable: Optional[bool] = None,
        price: OptionalNullable[
            Union[models.UpdatePlanPriceRequest, models.UpdatePlanPriceRequestTypedDict]
        ] = UNSET,
        items: Optional[
            Union[
                List[models.UpdatePlanItemRequest],
                List[models.UpdatePlanItemRequestTypedDict],
            ]
        ] = None,
        free_trial: OptionalNullable[
            Union[
                models.UpdatePlanFreeTrialRequest,
                models.UpdatePlanFreeTrialRequestTypedDict,
            ]
        ] = UNSET,
        version: Optional[float] = None,
        archived: Optional[bool] = False,
        new_plan_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdatePlanResponse:
        r"""Update a plan

        Updates an existing plan. Creates a new version unless `disableVersion` is set.

        Use this to modify plan properties, pricing, or feature configurations. See [Adding features to plans](/documentation/pricing/plan-features) for item configuration.

        :param plan_id: The ID of the plan to update.
        :param group: Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
        :param name: Display name of the plan.
        :param description:
        :param add_on: Whether the plan is an add-on.
        :param auto_enable: Whether the plan is automatically enabled.
        :param price: The price of the plan. Set to null to remove the base price.
        :param items: Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
        :param free_trial: The free trial of the plan. Set to null to remove the free trial.
        :param version:
        :param archived:
        :param new_plan_id: The new ID to use for the plan. Can only be updated if the plan has not been used by any customers.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdatePlanParams(
            plan_id=plan_id,
            group=group,
            name=name,
            description=description,
            add_on=add_on,
            auto_enable=auto_enable,
            price=utils.get_pydantic_model(
                price, OptionalNullable[models.UpdatePlanPriceRequest]
            ),
            items=utils.get_pydantic_model(
                items, Optional[List[models.UpdatePlanItemRequest]]
            ),
            free_trial=utils.get_pydantic_model(
                free_trial, OptionalNullable[models.UpdatePlanFreeTrialRequest]
            ),
            version=version,
            archived=archived,
            new_plan_id=new_plan_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/plans.update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.UpdatePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.UpdatePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updatePlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdatePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        plan_id: str,
        all_versions: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeletePlanResponse:
        r"""Delete a plan

        Deletes a plan by its ID.

        Use this to permanently remove a plan. Plans with active customers cannot be deleted - archive them instead.

        :param plan_id: The ID of the plan to delete.
        :param all_versions: If true, deletes all versions of the plan. Otherwise, only deletes the latest version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletePlanParams(
            plan_id=plan_id,
            all_versions=all_versions,
        )

        req = self._build_request(
            method="POST",
            path="/v1/plans.delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeletePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeletePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletePlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeletePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        plan_id: str,
        all_versions: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeletePlanResponse:
        r"""Delete a plan

        Deletes a plan by its ID.

        Use this to permanently remove a plan. Plans with active customers cannot be deleted - archive them instead.

        :param plan_id: The ID of the plan to delete.
        :param all_versions: If true, deletes all versions of the plan. Otherwise, only deletes the latest version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletePlanParams(
            plan_id=plan_id,
            all_versions=all_versions,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/plans.delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeletePlanGlobals(
                x_api_version=self.sdk_configuration.globals.x_api_version,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeletePlanParams
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletePlan",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeletePlanResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.AutumnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.AutumnDefaultError("Unexpected response received", http_res)
