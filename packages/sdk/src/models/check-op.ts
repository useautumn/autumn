/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { Balance, Balance$inboundSchema } from "./balance.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type CheckGlobals = {
  xApiVersion?: string | undefined;
};

export type CheckParams = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the feature.
   */
  featureId: string;
  /**
   * The ID of the entity for entity-scoped balances (e.g., per-seat limits).
   */
  entityId?: string | undefined;
  /**
   * Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1.
   */
  requiredBalance?: number | undefined;
  /**
   * Additional properties to attach to the usage event if send_event is true.
   */
  properties?: { [k: string]: any } | undefined;
  /**
   * If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call.
   */
  sendEvent?: boolean | undefined;
  /**
   * If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls.
   */
  withPreview?: boolean | undefined;
};

/**
 * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
 */
export const CheckScenario = {
  UsageLimit: "usage_limit",
  FeatureFlag: "feature_flag",
} as const;
/**
 * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
 */
export type CheckScenario = OpenEnum<typeof CheckScenario>;

/**
 * The environment of the product
 */
export const CheckEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment of the product
 */
export type CheckEnv = OpenEnum<typeof CheckEnv>;

export const CheckType = {
  Feature: "feature",
  PricedFeature: "priced_feature",
  Price: "price",
} as const;
export type CheckType = OpenEnum<typeof CheckType>;

export const FeatureType = {
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  Boolean: "boolean",
  Static: "static",
} as const;
export type FeatureType = OpenEnum<typeof FeatureType>;

export type IncludedUsage = number | string;

export const CheckInterval = {
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type CheckInterval = OpenEnum<typeof CheckInterval>;

/**
 * The maximum amount of usage for this tier.
 */
export type CheckTo = number | string;

export type Tiers = {
  /**
   * The maximum amount of usage for this tier.
   */
  to: number | string;
  /**
   * The price of the product item for this tier.
   */
  amount: number;
};

export const UsageModel = {
  Prepaid: "prepaid",
  PayPerUse: "pay_per_use",
} as const;
export type UsageModel = OpenEnum<typeof UsageModel>;

export type CheckDisplay = {
  primaryText: string;
  secondaryText?: string | null | undefined;
};

export const RolloverDuration = {
  Month: "month",
  Forever: "forever",
} as const;
export type RolloverDuration = OpenEnum<typeof RolloverDuration>;

export type CheckRollover = {
  max: number | null;
  duration: RolloverDuration;
  length: number;
};

export const CheckOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type CheckOnIncrease = OpenEnum<typeof CheckOnIncrease>;

export const CheckOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type CheckOnDecrease = OpenEnum<typeof CheckOnDecrease>;

export type Config = {
  rollover?: CheckRollover | null | undefined;
  onIncrease?: CheckOnIncrease | null | undefined;
  onDecrease?: CheckOnDecrease | null | undefined;
};

/**
 * Product item defining features and pricing within a product
 */
export type CheckItem = {
  /**
   * The type of the product item
   */
  type?: CheckType | null | undefined;
  /**
   * The feature ID of the product item. If the item is a fixed price, should be `null`
   */
  featureId?: string | null | undefined;
  /**
   * Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats.
   */
  featureType?: FeatureType | null | undefined;
  /**
   * The amount of usage included for this feature.
   */
  includedUsage?: number | string | null | undefined;
  /**
   * The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off.
   */
  interval?: CheckInterval | null | undefined;
  /**
   * The interval count of the product item.
   */
  intervalCount?: number | null | undefined;
  /**
   * The price of the product item. Should be `null` if tiered pricing is set.
   */
  price?: number | null | undefined;
  /**
   * Tiered pricing for the product item. Not applicable for fixed price items.
   */
  tiers?: Array<Tiers> | null | undefined;
  /**
   * Whether the feature should be prepaid upfront or billed for how much they use end of billing period.
   */
  usageModel?: UsageModel | null | undefined;
  /**
   * The amount per billing unit (eg. $9 / 250 units)
   */
  billingUnits?: number | null | undefined;
  /**
   * Whether the usage should be reset when the product is enabled.
   */
  resetUsageWhenEnabled?: boolean | null | undefined;
  /**
   * The entity feature ID of the product item if applicable.
   */
  entityFeatureId?: string | null | undefined;
  /**
   * The display of the product item.
   */
  display?: CheckDisplay | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer has prepaid for.
   */
  quantity?: number | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer will prepay for in the next cycle.
   */
  nextCycleQuantity?: number | null | undefined;
  /**
   * Configuration for rollover and proration behavior of the feature.
   */
  config?: Config | null | undefined;
};

/**
 * The duration type of the free trial
 */
export const FreeTrialDuration = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * The duration type of the free trial
 */
export type FreeTrialDuration = OpenEnum<typeof FreeTrialDuration>;

export type CheckFreeTrial = {
  /**
   * The duration type of the free trial
   */
  duration: FreeTrialDuration;
  /**
   * The length of the duration type specified
   */
  length: number;
  /**
   * Whether the free trial is limited to one per customer fingerprint
   */
  uniqueFingerprint: boolean;
  /**
   * Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file.
   */
  cardRequired: boolean;
  /**
   * Used in customer context. Whether the free trial is available for the customer if they were to attach the product.
   */
  trialAvailable: boolean | null;
};

/**
 * Scenario for when this product is used in attach flows
 */
export const ProductScenario = {
  Scheduled: "scheduled",
  Active: "active",
  New: "new",
  Renew: "renew",
  Upgrade: "upgrade",
  Downgrade: "downgrade",
  Cancel: "cancel",
  Expired: "expired",
  PastDue: "past_due",
} as const;
/**
 * Scenario for when this product is used in attach flows
 */
export type ProductScenario = OpenEnum<typeof ProductScenario>;

export type CheckProperties = {
  /**
   * True if the product has no base price or usage prices
   */
  isFree: boolean;
  /**
   * True if the product only contains a one-time price
   */
  isOneOff: boolean;
  /**
   * The billing interval group for recurring products (e.g., 'monthly', 'yearly')
   */
  intervalGroup?: string | null | undefined;
  /**
   * True if the product includes a free trial
   */
  hasTrial?: boolean | null | undefined;
  /**
   * True if the product can be updated after creation (only applicable if there are prepaid recurring prices)
   */
  updateable?: boolean | null | undefined;
};

export type Product = {
  /**
   * The ID of the product you set when creating the product
   */
  id: string;
  /**
   * The name of the product
   */
  name: string;
  /**
   * Product group which this product belongs to
   */
  group: string | null;
  /**
   * The environment of the product
   */
  env: CheckEnv;
  /**
   * Whether the product is an add-on and can be purchased alongside other products
   */
  isAddOn: boolean;
  /**
   * Whether the product is the default product
   */
  isDefault: boolean;
  /**
   * Whether this product has been archived and is no longer available
   */
  archived: boolean;
  /**
   * The current version of the product
   */
  version: number;
  /**
   * The timestamp of when the product was created in milliseconds since epoch
   */
  createdAt: number;
  /**
   * Array of product items that define the product's features and pricing
   */
  items: Array<CheckItem>;
  /**
   * Free trial configuration for this product, if available
   */
  freeTrial: CheckFreeTrial | null;
  /**
   * ID of the base variant this product is derived from
   */
  baseVariantId: string | null;
  /**
   * Scenario for when this product is used in attach flows
   */
  scenario?: ProductScenario | undefined;
  properties?: CheckProperties | undefined;
};

/**
 * Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false.
 */
export type Preview = {
  /**
   * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
   */
  scenario: CheckScenario;
  /**
   * A title suitable for displaying in a paywall or upgrade modal.
   */
  title: string;
  /**
   * A message explaining why access was denied.
   */
  message: string;
  /**
   * The ID of the feature that was checked.
   */
  featureId: string;
  /**
   * The display name of the feature.
   */
  featureName: string;
  /**
   * Products that would grant access to this feature. Use to display upgrade options.
   */
  products: Array<Product>;
};

/**
 * OK
 */
export type CheckResponse = {
  /**
   * Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean.
   */
  allowed: boolean;
  /**
   * The ID of the customer that was checked.
   */
  customerId: string;
  /**
   * The ID of the entity, if an entity-scoped check was performed.
   */
  entityId?: string | null | undefined;
  /**
   * The required balance that was checked against.
   */
  requiredBalance?: number | undefined;
  /**
   * The customer's balance for this feature. Null if the customer has no balance for this feature.
   */
  balance: Balance | null;
  /**
   * Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false.
   */
  preview?: Preview | undefined;
};

/** @internal */
export type CheckParams$Outbound = {
  customer_id: string;
  feature_id: string;
  entity_id?: string | undefined;
  required_balance?: number | undefined;
  properties?: { [k: string]: any } | undefined;
  send_event?: boolean | undefined;
  with_preview?: boolean | undefined;
};

/** @internal */
export const CheckParams$outboundSchema: z.ZodMiniType<
  CheckParams$Outbound,
  CheckParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: z.string(),
    entityId: z.optional(z.string()),
    requiredBalance: z.optional(z.number()),
    properties: z.optional(z.record(z.string(), z.any())),
    sendEvent: z.optional(z.boolean()),
    withPreview: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      entityId: "entity_id",
      requiredBalance: "required_balance",
      sendEvent: "send_event",
      withPreview: "with_preview",
    });
  }),
);

export function checkParamsToJSON(checkParams: CheckParams): string {
  return JSON.stringify(CheckParams$outboundSchema.parse(checkParams));
}

/** @internal */
export const CheckScenario$inboundSchema: z.ZodMiniType<
  CheckScenario,
  unknown
> = openEnums.inboundSchema(CheckScenario);

/** @internal */
export const CheckEnv$inboundSchema: z.ZodMiniType<CheckEnv, unknown> =
  openEnums.inboundSchema(CheckEnv);

/** @internal */
export const CheckType$inboundSchema: z.ZodMiniType<CheckType, unknown> =
  openEnums.inboundSchema(CheckType);

/** @internal */
export const FeatureType$inboundSchema: z.ZodMiniType<FeatureType, unknown> =
  openEnums.inboundSchema(FeatureType);

/** @internal */
export const IncludedUsage$inboundSchema: z.ZodMiniType<
  IncludedUsage,
  unknown
> = smartUnion([types.number(), types.string()]);

export function includedUsageFromJSON(
  jsonString: string,
): SafeParseResult<IncludedUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncludedUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncludedUsage' from JSON`,
  );
}

/** @internal */
export const CheckInterval$inboundSchema: z.ZodMiniType<
  CheckInterval,
  unknown
> = openEnums.inboundSchema(CheckInterval);

/** @internal */
export const CheckTo$inboundSchema: z.ZodMiniType<CheckTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function checkToFromJSON(
  jsonString: string,
): SafeParseResult<CheckTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckTo' from JSON`,
  );
}

/** @internal */
export const Tiers$inboundSchema: z.ZodMiniType<Tiers, unknown> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function tiersFromJSON(
  jsonString: string,
): SafeParseResult<Tiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tiers' from JSON`,
  );
}

/** @internal */
export const UsageModel$inboundSchema: z.ZodMiniType<UsageModel, unknown> =
  openEnums.inboundSchema(UsageModel);

/** @internal */
export const CheckDisplay$inboundSchema: z.ZodMiniType<CheckDisplay, unknown> =
  z.pipe(
    z.object({
      primary_text: types.string(),
      secondary_text: z.optional(z.nullable(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "primary_text": "primaryText",
        "secondary_text": "secondaryText",
      });
    }),
  );

export function checkDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CheckDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckDisplay' from JSON`,
  );
}

/** @internal */
export const RolloverDuration$inboundSchema: z.ZodMiniType<
  RolloverDuration,
  unknown
> = openEnums.inboundSchema(RolloverDuration);

/** @internal */
export const CheckRollover$inboundSchema: z.ZodMiniType<
  CheckRollover,
  unknown
> = z.object({
  max: types.nullable(types.number()),
  duration: z._default(RolloverDuration$inboundSchema, "month"),
  length: types.number(),
});

export function checkRolloverFromJSON(
  jsonString: string,
): SafeParseResult<CheckRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckRollover' from JSON`,
  );
}

/** @internal */
export const CheckOnIncrease$inboundSchema: z.ZodMiniType<
  CheckOnIncrease,
  unknown
> = openEnums.inboundSchema(CheckOnIncrease);

/** @internal */
export const CheckOnDecrease$inboundSchema: z.ZodMiniType<
  CheckOnDecrease,
  unknown
> = openEnums.inboundSchema(CheckOnDecrease);

/** @internal */
export const Config$inboundSchema: z.ZodMiniType<Config, unknown> = z.pipe(
  z.object({
    rollover: z.optional(z.nullable(z.lazy(() => CheckRollover$inboundSchema))),
    on_increase: z.optional(z.nullable(CheckOnIncrease$inboundSchema)),
    on_decrease: z.optional(z.nullable(CheckOnDecrease$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "on_increase": "onIncrease",
      "on_decrease": "onDecrease",
    });
  }),
);

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const CheckItem$inboundSchema: z.ZodMiniType<CheckItem, unknown> = z
  .pipe(
    z.object({
      type: z.optional(z.nullable(CheckType$inboundSchema)),
      feature_id: z.optional(z.nullable(types.string())),
      feature_type: z.optional(z.nullable(FeatureType$inboundSchema)),
      included_usage: z.optional(
        z.nullable(smartUnion([types.number(), types.string()])),
      ),
      interval: z.optional(z.nullable(CheckInterval$inboundSchema)),
      interval_count: z.optional(z.nullable(types.number())),
      price: z.optional(z.nullable(types.number())),
      tiers: z.optional(z.nullable(z.array(z.lazy(() => Tiers$inboundSchema)))),
      usage_model: z.optional(z.nullable(UsageModel$inboundSchema)),
      billing_units: z.optional(z.nullable(types.number())),
      reset_usage_when_enabled: z.optional(z.nullable(types.boolean())),
      entity_feature_id: z.optional(z.nullable(types.string())),
      display: z.optional(z.nullable(z.lazy(() => CheckDisplay$inboundSchema))),
      quantity: z.optional(z.nullable(types.number())),
      next_cycle_quantity: z.optional(z.nullable(types.number())),
      config: z.optional(z.nullable(z.lazy(() => Config$inboundSchema))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "feature_id": "featureId",
        "feature_type": "featureType",
        "included_usage": "includedUsage",
        "interval_count": "intervalCount",
        "usage_model": "usageModel",
        "billing_units": "billingUnits",
        "reset_usage_when_enabled": "resetUsageWhenEnabled",
        "entity_feature_id": "entityFeatureId",
        "next_cycle_quantity": "nextCycleQuantity",
      });
    }),
  );

export function checkItemFromJSON(
  jsonString: string,
): SafeParseResult<CheckItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckItem' from JSON`,
  );
}

/** @internal */
export const FreeTrialDuration$inboundSchema: z.ZodMiniType<
  FreeTrialDuration,
  unknown
> = openEnums.inboundSchema(FreeTrialDuration);

/** @internal */
export const CheckFreeTrial$inboundSchema: z.ZodMiniType<
  CheckFreeTrial,
  unknown
> = z.pipe(
  z.object({
    duration: FreeTrialDuration$inboundSchema,
    length: types.number(),
    unique_fingerprint: types.boolean(),
    card_required: types.boolean(),
    trial_available: z.nullable(z._default(types.boolean(), true)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unique_fingerprint": "uniqueFingerprint",
      "card_required": "cardRequired",
      "trial_available": "trialAvailable",
    });
  }),
);

export function checkFreeTrialFromJSON(
  jsonString: string,
): SafeParseResult<CheckFreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckFreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckFreeTrial' from JSON`,
  );
}

/** @internal */
export const ProductScenario$inboundSchema: z.ZodMiniType<
  ProductScenario,
  unknown
> = openEnums.inboundSchema(ProductScenario);

/** @internal */
export const CheckProperties$inboundSchema: z.ZodMiniType<
  CheckProperties,
  unknown
> = z.pipe(
  z.object({
    is_free: types.boolean(),
    is_one_off: types.boolean(),
    interval_group: z.optional(z.nullable(types.string())),
    has_trial: z.optional(z.nullable(types.boolean())),
    updateable: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_free": "isFree",
      "is_one_off": "isOneOff",
      "interval_group": "intervalGroup",
      "has_trial": "hasTrial",
    });
  }),
);

export function checkPropertiesFromJSON(
  jsonString: string,
): SafeParseResult<CheckProperties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckProperties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckProperties' from JSON`,
  );
}

/** @internal */
export const Product$inboundSchema: z.ZodMiniType<Product, unknown> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    group: types.nullable(types.string()),
    env: CheckEnv$inboundSchema,
    is_add_on: types.boolean(),
    is_default: types.boolean(),
    archived: types.boolean(),
    version: types.number(),
    created_at: types.number(),
    items: z.array(z.lazy(() => CheckItem$inboundSchema)),
    free_trial: types.nullable(z.lazy(() => CheckFreeTrial$inboundSchema)),
    base_variant_id: types.nullable(types.string()),
    scenario: types.optional(ProductScenario$inboundSchema),
    properties: types.optional(z.lazy(() => CheckProperties$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_add_on": "isAddOn",
      "is_default": "isDefault",
      "created_at": "createdAt",
      "free_trial": "freeTrial",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function productFromJSON(
  jsonString: string,
): SafeParseResult<Product, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Product$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Product' from JSON`,
  );
}

/** @internal */
export const Preview$inboundSchema: z.ZodMiniType<Preview, unknown> = z.pipe(
  z.object({
    scenario: CheckScenario$inboundSchema,
    title: types.string(),
    message: types.string(),
    feature_id: types.string(),
    feature_name: types.string(),
    products: z.array(z.lazy(() => Product$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "feature_name": "featureName",
    });
  }),
);

export function previewFromJSON(
  jsonString: string,
): SafeParseResult<Preview, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Preview$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Preview' from JSON`,
  );
}

/** @internal */
export const CheckResponse$inboundSchema: z.ZodMiniType<
  CheckResponse,
  unknown
> = z.pipe(
  z.object({
    allowed: types.boolean(),
    customer_id: types.string(),
    entity_id: z.optional(z.nullable(types.string())),
    required_balance: types.optional(types.number()),
    balance: types.nullable(Balance$inboundSchema),
    preview: types.optional(z.lazy(() => Preview$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "required_balance": "requiredBalance",
    });
  }),
);

export function checkResponseFromJSON(
  jsonString: string,
): SafeParseResult<CheckResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckResponse' from JSON`,
  );
}
