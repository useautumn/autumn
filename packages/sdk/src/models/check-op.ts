/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type CheckGlobals = {
  xApiVersion?: string | undefined;
};

export type CheckParams = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the feature.
   */
  featureId: string;
  /**
   * The ID of the entity for entity-scoped balances (e.g., per-seat limits).
   */
  entityId?: string | undefined;
  /**
   * Minimum balance required for access. Returns allowed: false if the customer's balance is below this value. Defaults to 1.
   */
  requiredBalance?: number | undefined;
  /**
   * Additional properties to attach to the usage event if send_event is true.
   */
  properties?: { [k: string]: any } | undefined;
  /**
   * If true, atomically records a usage event while checking access. The required_balance value is used as the usage amount. Combines check + track in one call.
   */
  sendEvent?: boolean | undefined;
  /**
   * If true, includes upgrade/upsell information in the response when access is denied. Useful for displaying paywalls.
   */
  withPreview?: boolean | undefined;
};

export const CheckBalanceType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type CheckBalanceType = OpenEnum<typeof CheckBalanceType>;

export type CheckCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type CheckBalanceDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type CheckFeature = {
  id: string;
  name: string;
  type: CheckBalanceType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<CheckCreditSchema> | undefined;
  display?: CheckBalanceDisplay | undefined;
  archived: boolean;
};

export const CheckBalanceIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type CheckBalanceIntervalEnum = OpenEnum<
  typeof CheckBalanceIntervalEnum
>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type CheckIntervalUnion = CheckBalanceIntervalEnum | string;

export type CheckReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: CheckBalanceIntervalEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type CheckBalanceTo = number | string;

export type CheckTier = {
  to: number | string;
  amount: number;
};

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const CheckBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type CheckBillingMethod = OpenEnum<typeof CheckBillingMethod>;

export type CheckPrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<CheckTier> | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: CheckBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type CheckBreakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: CheckReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: CheckPrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type CheckBalanceRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type CheckBalance = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: CheckFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<CheckBreakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<CheckBalanceRollover> | undefined;
};

/**
 * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
 */
export const CheckScenario = {
  UsageLimit: "usage_limit",
  FeatureFlag: "feature_flag",
} as const;
/**
 * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
 */
export type CheckScenario = OpenEnum<typeof CheckScenario>;

/**
 * The environment of the product
 */
export const CheckEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment of the product
 */
export type CheckEnv = OpenEnum<typeof CheckEnv>;

export const ProductType = {
  Feature: "feature",
  PricedFeature: "priced_feature",
  Price: "price",
} as const;
export type ProductType = OpenEnum<typeof ProductType>;

export const FeatureType = {
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  Boolean: "boolean",
  Static: "static",
} as const;
export type FeatureType = OpenEnum<typeof FeatureType>;

export type IncludedUsage = number | string;

export const ProductInterval = {
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type ProductInterval = OpenEnum<typeof ProductInterval>;

/**
 * The maximum amount of usage for this tier.
 */
export type TiersTo = number | string;

export type Tiers = {
  /**
   * The maximum amount of usage for this tier.
   */
  to: number | string;
  /**
   * The price of the product item for this tier.
   */
  amount: number;
};

export const UsageModel = {
  Prepaid: "prepaid",
  PayPerUse: "pay_per_use",
} as const;
export type UsageModel = OpenEnum<typeof UsageModel>;

export type ProductDisplay = {
  primaryText: string;
  secondaryText?: string | null | undefined;
};

export const RolloverDuration = {
  Month: "month",
  Forever: "forever",
} as const;
export type RolloverDuration = OpenEnum<typeof RolloverDuration>;

export type ConfigRollover = {
  max: number | null;
  duration: RolloverDuration;
  length: number;
};

export const CheckOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type CheckOnIncrease = OpenEnum<typeof CheckOnIncrease>;

export const CheckOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type CheckOnDecrease = OpenEnum<typeof CheckOnDecrease>;

export type Config = {
  rollover?: ConfigRollover | null | undefined;
  onIncrease?: CheckOnIncrease | null | undefined;
  onDecrease?: CheckOnDecrease | null | undefined;
};

/**
 * Product item defining features and pricing within a product
 */
export type CheckItem = {
  /**
   * The type of the product item
   */
  type?: ProductType | null | undefined;
  /**
   * The feature ID of the product item. If the item is a fixed price, should be `null`
   */
  featureId?: string | null | undefined;
  /**
   * Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats.
   */
  featureType?: FeatureType | null | undefined;
  /**
   * The amount of usage included for this feature.
   */
  includedUsage?: number | string | null | undefined;
  /**
   * The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off.
   */
  interval?: ProductInterval | null | undefined;
  /**
   * The interval count of the product item.
   */
  intervalCount?: number | null | undefined;
  /**
   * The price of the product item. Should be `null` if tiered pricing is set.
   */
  price?: number | null | undefined;
  /**
   * Tiered pricing for the product item. Not applicable for fixed price items.
   */
  tiers?: Array<Tiers> | null | undefined;
  /**
   * Whether the feature should be prepaid upfront or billed for how much they use end of billing period.
   */
  usageModel?: UsageModel | null | undefined;
  /**
   * The amount per billing unit (eg. $9 / 250 units)
   */
  billingUnits?: number | null | undefined;
  /**
   * Whether the usage should be reset when the product is enabled.
   */
  resetUsageWhenEnabled?: boolean | null | undefined;
  /**
   * The entity feature ID of the product item if applicable.
   */
  entityFeatureId?: string | null | undefined;
  /**
   * The display of the product item.
   */
  display?: ProductDisplay | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer has prepaid for.
   */
  quantity?: number | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer will prepay for in the next cycle.
   */
  nextCycleQuantity?: number | null | undefined;
  /**
   * Configuration for rollover and proration behavior of the feature.
   */
  config?: Config | null | undefined;
};

/**
 * The duration type of the free trial
 */
export const FreeTrialDuration = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * The duration type of the free trial
 */
export type FreeTrialDuration = OpenEnum<typeof FreeTrialDuration>;

export type CheckFreeTrial = {
  /**
   * The duration type of the free trial
   */
  duration: FreeTrialDuration;
  /**
   * The length of the duration type specified
   */
  length: number;
  /**
   * Whether the free trial is limited to one per customer fingerprint
   */
  uniqueFingerprint: boolean;
  /**
   * Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file.
   */
  cardRequired: boolean;
  /**
   * Used in customer context. Whether the free trial is available for the customer if they were to attach the product.
   */
  trialAvailable: boolean | null;
};

/**
 * Scenario for when this product is used in attach flows
 */
export const ProductScenario = {
  Scheduled: "scheduled",
  Active: "active",
  New: "new",
  Renew: "renew",
  Upgrade: "upgrade",
  Downgrade: "downgrade",
  Cancel: "cancel",
  Expired: "expired",
  PastDue: "past_due",
} as const;
/**
 * Scenario for when this product is used in attach flows
 */
export type ProductScenario = OpenEnum<typeof ProductScenario>;

export type CheckProperties = {
  /**
   * True if the product has no base price or usage prices
   */
  isFree: boolean;
  /**
   * True if the product only contains a one-time price
   */
  isOneOff: boolean;
  /**
   * The billing interval group for recurring products (e.g., 'monthly', 'yearly')
   */
  intervalGroup?: string | null | undefined;
  /**
   * True if the product includes a free trial
   */
  hasTrial?: boolean | null | undefined;
  /**
   * True if the product can be updated after creation (only applicable if there are prepaid recurring prices)
   */
  updateable?: boolean | null | undefined;
};

export type Product = {
  /**
   * The ID of the product you set when creating the product
   */
  id: string;
  /**
   * The name of the product
   */
  name: string;
  /**
   * Product group which this product belongs to
   */
  group: string | null;
  /**
   * The environment of the product
   */
  env: CheckEnv;
  /**
   * Whether the product is an add-on and can be purchased alongside other products
   */
  isAddOn: boolean;
  /**
   * Whether the product is the default product
   */
  isDefault: boolean;
  /**
   * Whether this product has been archived and is no longer available
   */
  archived: boolean;
  /**
   * The current version of the product
   */
  version: number;
  /**
   * The timestamp of when the product was created in milliseconds since epoch
   */
  createdAt: number;
  /**
   * Array of product items that define the product's features and pricing
   */
  items: Array<CheckItem>;
  /**
   * Free trial configuration for this product, if available
   */
  freeTrial: CheckFreeTrial | null;
  /**
   * ID of the base variant this product is derived from
   */
  baseVariantId: string | null;
  /**
   * Scenario for when this product is used in attach flows
   */
  scenario?: ProductScenario | undefined;
  properties?: CheckProperties | undefined;
};

/**
 * Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false.
 */
export type Preview = {
  /**
   * The reason access was denied. 'usage_limit' means the customer exceeded their balance, 'feature_flag' means the feature is not included in their plan.
   */
  scenario: CheckScenario;
  /**
   * A title suitable for displaying in a paywall or upgrade modal.
   */
  title: string;
  /**
   * A message explaining why access was denied.
   */
  message: string;
  /**
   * The ID of the feature that was checked.
   */
  featureId: string;
  /**
   * The display name of the feature.
   */
  featureName: string;
  /**
   * Products that would grant access to this feature. Use to display upgrade options.
   */
  products: Array<Product>;
};

/**
 * OK
 */
export type CheckResponse = {
  /**
   * Whether the customer is allowed to use the feature. True if they have sufficient balance or the feature is unlimited/boolean.
   */
  allowed: boolean;
  /**
   * The ID of the customer that was checked.
   */
  customerId: string;
  /**
   * The ID of the entity, if an entity-scoped check was performed.
   */
  entityId?: string | null | undefined;
  /**
   * The required balance that was checked against.
   */
  requiredBalance?: number | undefined;
  /**
   * The customer's balance for this feature. Null if the customer has no balance for this feature.
   */
  balance: CheckBalance | null;
  /**
   * Upgrade/upsell information when access is denied. Only present if with_preview was true and allowed is false.
   */
  preview?: Preview | undefined;
};

/** @internal */
export type CheckParams$Outbound = {
  customer_id: string;
  feature_id: string;
  entity_id?: string | undefined;
  required_balance?: number | undefined;
  properties?: { [k: string]: any } | undefined;
  send_event?: boolean | undefined;
  with_preview?: boolean | undefined;
};

/** @internal */
export const CheckParams$outboundSchema: z.ZodMiniType<
  CheckParams$Outbound,
  CheckParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: z.string(),
    entityId: z.optional(z.string()),
    requiredBalance: z.optional(z.number()),
    properties: z.optional(z.record(z.string(), z.any())),
    sendEvent: z.optional(z.boolean()),
    withPreview: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      entityId: "entity_id",
      requiredBalance: "required_balance",
      sendEvent: "send_event",
      withPreview: "with_preview",
    });
  }),
);

export function checkParamsToJSON(checkParams: CheckParams): string {
  return JSON.stringify(CheckParams$outboundSchema.parse(checkParams));
}

/** @internal */
export const CheckBalanceType$inboundSchema: z.ZodMiniType<
  CheckBalanceType,
  unknown
> = openEnums.inboundSchema(CheckBalanceType);

/** @internal */
export const CheckCreditSchema$inboundSchema: z.ZodMiniType<
  CheckCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function checkCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CheckCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckCreditSchema' from JSON`,
  );
}

/** @internal */
export const CheckBalanceDisplay$inboundSchema: z.ZodMiniType<
  CheckBalanceDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function checkBalanceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CheckBalanceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckBalanceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckBalanceDisplay' from JSON`,
  );
}

/** @internal */
export const CheckFeature$inboundSchema: z.ZodMiniType<CheckFeature, unknown> =
  z.pipe(
    z.object({
      id: types.string(),
      name: types.string(),
      type: CheckBalanceType$inboundSchema,
      consumable: types.boolean(),
      event_names: types.optional(z.array(types.string())),
      credit_schema: types.optional(
        z.array(z.lazy(() => CheckCreditSchema$inboundSchema)),
      ),
      display: types.optional(z.lazy(() => CheckBalanceDisplay$inboundSchema)),
      archived: types.boolean(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "event_names": "eventNames",
        "credit_schema": "creditSchema",
      });
    }),
  );

export function checkFeatureFromJSON(
  jsonString: string,
): SafeParseResult<CheckFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckFeature' from JSON`,
  );
}

/** @internal */
export const CheckBalanceIntervalEnum$inboundSchema: z.ZodMiniType<
  CheckBalanceIntervalEnum,
  unknown
> = openEnums.inboundSchema(CheckBalanceIntervalEnum);

/** @internal */
export const CheckIntervalUnion$inboundSchema: z.ZodMiniType<
  CheckIntervalUnion,
  unknown
> = smartUnion([CheckBalanceIntervalEnum$inboundSchema, types.string()]);

export function checkIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<CheckIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckIntervalUnion' from JSON`,
  );
}

/** @internal */
export const CheckReset$inboundSchema: z.ZodMiniType<CheckReset, unknown> = z
  .pipe(
    z.object({
      interval: smartUnion([
        CheckBalanceIntervalEnum$inboundSchema,
        types.string(),
      ]),
      interval_count: types.optional(types.number()),
      resets_at: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
        "resets_at": "resetsAt",
      });
    }),
  );

export function checkResetFromJSON(
  jsonString: string,
): SafeParseResult<CheckReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckReset' from JSON`,
  );
}

/** @internal */
export const CheckBalanceTo$inboundSchema: z.ZodMiniType<
  CheckBalanceTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function checkBalanceToFromJSON(
  jsonString: string,
): SafeParseResult<CheckBalanceTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckBalanceTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckBalanceTo' from JSON`,
  );
}

/** @internal */
export const CheckTier$inboundSchema: z.ZodMiniType<CheckTier, unknown> = z
  .object({
    to: smartUnion([types.number(), types.string()]),
    amount: types.number(),
  });

export function checkTierFromJSON(
  jsonString: string,
): SafeParseResult<CheckTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckTier' from JSON`,
  );
}

/** @internal */
export const CheckBillingMethod$inboundSchema: z.ZodMiniType<
  CheckBillingMethod,
  unknown
> = openEnums.inboundSchema(CheckBillingMethod);

/** @internal */
export const CheckPrice$inboundSchema: z.ZodMiniType<CheckPrice, unknown> = z
  .pipe(
    z.object({
      amount: types.optional(types.number()),
      tiers: types.optional(z.array(z.lazy(() => CheckTier$inboundSchema))),
      billing_units: types.number(),
      billing_method: CheckBillingMethod$inboundSchema,
      max_purchase: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_units": "billingUnits",
        "billing_method": "billingMethod",
        "max_purchase": "maxPurchase",
      });
    }),
  );

export function checkPriceFromJSON(
  jsonString: string,
): SafeParseResult<CheckPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckPrice' from JSON`,
  );
}

/** @internal */
export const CheckBreakdown$inboundSchema: z.ZodMiniType<
  CheckBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => CheckReset$inboundSchema)),
    price: types.nullable(z.lazy(() => CheckPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function checkBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<CheckBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckBreakdown' from JSON`,
  );
}

/** @internal */
export const CheckBalanceRollover$inboundSchema: z.ZodMiniType<
  CheckBalanceRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function checkBalanceRolloverFromJSON(
  jsonString: string,
): SafeParseResult<CheckBalanceRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckBalanceRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckBalanceRollover' from JSON`,
  );
}

/** @internal */
export const CheckBalance$inboundSchema: z.ZodMiniType<CheckBalance, unknown> =
  z.pipe(
    z.object({
      feature_id: types.string(),
      feature: types.optional(z.lazy(() => CheckFeature$inboundSchema)),
      granted: types.number(),
      remaining: types.number(),
      usage: types.number(),
      unlimited: types.boolean(),
      overage_allowed: types.boolean(),
      max_purchase: types.nullable(types.number()),
      next_reset_at: types.nullable(types.number()),
      breakdown: types.optional(
        z.array(z.lazy(() => CheckBreakdown$inboundSchema)),
      ),
      rollovers: types.optional(
        z.array(z.lazy(() => CheckBalanceRollover$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "feature_id": "featureId",
        "overage_allowed": "overageAllowed",
        "max_purchase": "maxPurchase",
        "next_reset_at": "nextResetAt",
      });
    }),
  );

export function checkBalanceFromJSON(
  jsonString: string,
): SafeParseResult<CheckBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckBalance' from JSON`,
  );
}

/** @internal */
export const CheckScenario$inboundSchema: z.ZodMiniType<
  CheckScenario,
  unknown
> = openEnums.inboundSchema(CheckScenario);

/** @internal */
export const CheckEnv$inboundSchema: z.ZodMiniType<CheckEnv, unknown> =
  openEnums.inboundSchema(CheckEnv);

/** @internal */
export const ProductType$inboundSchema: z.ZodMiniType<ProductType, unknown> =
  openEnums.inboundSchema(ProductType);

/** @internal */
export const FeatureType$inboundSchema: z.ZodMiniType<FeatureType, unknown> =
  openEnums.inboundSchema(FeatureType);

/** @internal */
export const IncludedUsage$inboundSchema: z.ZodMiniType<
  IncludedUsage,
  unknown
> = smartUnion([types.number(), types.string()]);

export function includedUsageFromJSON(
  jsonString: string,
): SafeParseResult<IncludedUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncludedUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncludedUsage' from JSON`,
  );
}

/** @internal */
export const ProductInterval$inboundSchema: z.ZodMiniType<
  ProductInterval,
  unknown
> = openEnums.inboundSchema(ProductInterval);

/** @internal */
export const TiersTo$inboundSchema: z.ZodMiniType<TiersTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function tiersToFromJSON(
  jsonString: string,
): SafeParseResult<TiersTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TiersTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TiersTo' from JSON`,
  );
}

/** @internal */
export const Tiers$inboundSchema: z.ZodMiniType<Tiers, unknown> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function tiersFromJSON(
  jsonString: string,
): SafeParseResult<Tiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tiers' from JSON`,
  );
}

/** @internal */
export const UsageModel$inboundSchema: z.ZodMiniType<UsageModel, unknown> =
  openEnums.inboundSchema(UsageModel);

/** @internal */
export const ProductDisplay$inboundSchema: z.ZodMiniType<
  ProductDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function productDisplayFromJSON(
  jsonString: string,
): SafeParseResult<ProductDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductDisplay' from JSON`,
  );
}

/** @internal */
export const RolloverDuration$inboundSchema: z.ZodMiniType<
  RolloverDuration,
  unknown
> = openEnums.inboundSchema(RolloverDuration);

/** @internal */
export const ConfigRollover$inboundSchema: z.ZodMiniType<
  ConfigRollover,
  unknown
> = z.object({
  max: types.nullable(types.number()),
  duration: z._default(RolloverDuration$inboundSchema, "month"),
  length: types.number(),
});

export function configRolloverFromJSON(
  jsonString: string,
): SafeParseResult<ConfigRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConfigRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConfigRollover' from JSON`,
  );
}

/** @internal */
export const CheckOnIncrease$inboundSchema: z.ZodMiniType<
  CheckOnIncrease,
  unknown
> = openEnums.inboundSchema(CheckOnIncrease);

/** @internal */
export const CheckOnDecrease$inboundSchema: z.ZodMiniType<
  CheckOnDecrease,
  unknown
> = openEnums.inboundSchema(CheckOnDecrease);

/** @internal */
export const Config$inboundSchema: z.ZodMiniType<Config, unknown> = z.pipe(
  z.object({
    rollover: z.optional(
      z.nullable(z.lazy(() => ConfigRollover$inboundSchema)),
    ),
    on_increase: z.optional(z.nullable(CheckOnIncrease$inboundSchema)),
    on_decrease: z.optional(z.nullable(CheckOnDecrease$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "on_increase": "onIncrease",
      "on_decrease": "onDecrease",
    });
  }),
);

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const CheckItem$inboundSchema: z.ZodMiniType<CheckItem, unknown> = z
  .pipe(
    z.object({
      type: z.optional(z.nullable(ProductType$inboundSchema)),
      feature_id: z.optional(z.nullable(types.string())),
      feature_type: z.optional(z.nullable(FeatureType$inboundSchema)),
      included_usage: z.optional(
        z.nullable(smartUnion([types.number(), types.string()])),
      ),
      interval: z.optional(z.nullable(ProductInterval$inboundSchema)),
      interval_count: z.optional(z.nullable(types.number())),
      price: z.optional(z.nullable(types.number())),
      tiers: z.optional(z.nullable(z.array(z.lazy(() => Tiers$inboundSchema)))),
      usage_model: z.optional(z.nullable(UsageModel$inboundSchema)),
      billing_units: z.optional(z.nullable(types.number())),
      reset_usage_when_enabled: z.optional(z.nullable(types.boolean())),
      entity_feature_id: z.optional(z.nullable(types.string())),
      display: z.optional(
        z.nullable(z.lazy(() => ProductDisplay$inboundSchema)),
      ),
      quantity: z.optional(z.nullable(types.number())),
      next_cycle_quantity: z.optional(z.nullable(types.number())),
      config: z.optional(z.nullable(z.lazy(() => Config$inboundSchema))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "feature_id": "featureId",
        "feature_type": "featureType",
        "included_usage": "includedUsage",
        "interval_count": "intervalCount",
        "usage_model": "usageModel",
        "billing_units": "billingUnits",
        "reset_usage_when_enabled": "resetUsageWhenEnabled",
        "entity_feature_id": "entityFeatureId",
        "next_cycle_quantity": "nextCycleQuantity",
      });
    }),
  );

export function checkItemFromJSON(
  jsonString: string,
): SafeParseResult<CheckItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckItem' from JSON`,
  );
}

/** @internal */
export const FreeTrialDuration$inboundSchema: z.ZodMiniType<
  FreeTrialDuration,
  unknown
> = openEnums.inboundSchema(FreeTrialDuration);

/** @internal */
export const CheckFreeTrial$inboundSchema: z.ZodMiniType<
  CheckFreeTrial,
  unknown
> = z.pipe(
  z.object({
    duration: FreeTrialDuration$inboundSchema,
    length: types.number(),
    unique_fingerprint: types.boolean(),
    card_required: types.boolean(),
    trial_available: z.nullable(z._default(types.boolean(), true)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unique_fingerprint": "uniqueFingerprint",
      "card_required": "cardRequired",
      "trial_available": "trialAvailable",
    });
  }),
);

export function checkFreeTrialFromJSON(
  jsonString: string,
): SafeParseResult<CheckFreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckFreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckFreeTrial' from JSON`,
  );
}

/** @internal */
export const ProductScenario$inboundSchema: z.ZodMiniType<
  ProductScenario,
  unknown
> = openEnums.inboundSchema(ProductScenario);

/** @internal */
export const CheckProperties$inboundSchema: z.ZodMiniType<
  CheckProperties,
  unknown
> = z.pipe(
  z.object({
    is_free: types.boolean(),
    is_one_off: types.boolean(),
    interval_group: z.optional(z.nullable(types.string())),
    has_trial: z.optional(z.nullable(types.boolean())),
    updateable: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_free": "isFree",
      "is_one_off": "isOneOff",
      "interval_group": "intervalGroup",
      "has_trial": "hasTrial",
    });
  }),
);

export function checkPropertiesFromJSON(
  jsonString: string,
): SafeParseResult<CheckProperties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckProperties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckProperties' from JSON`,
  );
}

/** @internal */
export const Product$inboundSchema: z.ZodMiniType<Product, unknown> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    group: types.nullable(types.string()),
    env: CheckEnv$inboundSchema,
    is_add_on: types.boolean(),
    is_default: types.boolean(),
    archived: types.boolean(),
    version: types.number(),
    created_at: types.number(),
    items: z.array(z.lazy(() => CheckItem$inboundSchema)),
    free_trial: types.nullable(z.lazy(() => CheckFreeTrial$inboundSchema)),
    base_variant_id: types.nullable(types.string()),
    scenario: types.optional(ProductScenario$inboundSchema),
    properties: types.optional(z.lazy(() => CheckProperties$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_add_on": "isAddOn",
      "is_default": "isDefault",
      "created_at": "createdAt",
      "free_trial": "freeTrial",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function productFromJSON(
  jsonString: string,
): SafeParseResult<Product, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Product$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Product' from JSON`,
  );
}

/** @internal */
export const Preview$inboundSchema: z.ZodMiniType<Preview, unknown> = z.pipe(
  z.object({
    scenario: CheckScenario$inboundSchema,
    title: types.string(),
    message: types.string(),
    feature_id: types.string(),
    feature_name: types.string(),
    products: z.array(z.lazy(() => Product$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "feature_name": "featureName",
    });
  }),
);

export function previewFromJSON(
  jsonString: string,
): SafeParseResult<Preview, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Preview$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Preview' from JSON`,
  );
}

/** @internal */
export const CheckResponse$inboundSchema: z.ZodMiniType<
  CheckResponse,
  unknown
> = z.pipe(
  z.object({
    allowed: types.boolean(),
    customer_id: types.string(),
    entity_id: z.optional(z.nullable(types.string())),
    required_balance: types.optional(types.number()),
    balance: types.nullable(z.lazy(() => CheckBalance$inboundSchema)),
    preview: types.optional(z.lazy(() => Preview$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "required_balance": "requiredBalance",
    });
  }),
);

export function checkResponseFromJSON(
  jsonString: string,
): SafeParseResult<CheckResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckResponse' from JSON`,
  );
}
