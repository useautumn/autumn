/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type ListFeaturesGlobals = {
  xApiVersion?: string | undefined;
};

export type ListFeaturesRequest = {};

/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export const ListFeaturesType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export type ListFeaturesType = OpenEnum<typeof ListFeaturesType>;

export type ListFeaturesCreditSchema = {
  /**
   * ID of the metered feature that draws from this credit system.
   */
  meteredFeatureId: string;
  /**
   * Credits consumed per unit of the metered feature.
   */
  creditCost: number;
};

/**
 * Display names for the feature in billing UI and customer-facing components.
 */
export type ListFeaturesDisplay = {
  /**
   * Singular form for UI display (e.g., 'API call', 'seat').
   */
  singular?: string | null | undefined;
  /**
   * Plural form for UI display (e.g., 'API calls', 'seats').
   */
  plural?: string | null | undefined;
};

export type ListFeaturesList = {
  /**
   * The unique identifier for this feature, used in /check and /track calls.
   */
  id: string;
  /**
   * Human-readable name displayed in the dashboard and billing UI.
   */
  name: string;
  /**
   * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
   */
  type: ListFeaturesType;
  /**
   * For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage).
   */
  consumable: boolean;
  /**
   * Event names that trigger this feature's balance. Allows multiple features to respond to a single event.
   */
  eventNames?: Array<string> | undefined;
  /**
   * For credit_system features: maps metered features to their credit costs.
   */
  creditSchema?: Array<ListFeaturesCreditSchema> | undefined;
  /**
   * Display names for the feature in billing UI and customer-facing components.
   */
  display?: ListFeaturesDisplay | undefined;
  /**
   * Whether the feature is archived and hidden from the dashboard.
   */
  archived: boolean;
};

/**
 * OK
 */
export type ListFeaturesResponse = {
  list: Array<ListFeaturesList>;
};

/** @internal */
export type ListFeaturesRequest$Outbound = {};

/** @internal */
export const ListFeaturesRequest$outboundSchema: z.ZodMiniType<
  ListFeaturesRequest$Outbound,
  ListFeaturesRequest
> = z.object({});

export function listFeaturesRequestToJSON(
  listFeaturesRequest: ListFeaturesRequest,
): string {
  return JSON.stringify(
    ListFeaturesRequest$outboundSchema.parse(listFeaturesRequest),
  );
}

/** @internal */
export const ListFeaturesType$inboundSchema: z.ZodMiniType<
  ListFeaturesType,
  unknown
> = openEnums.inboundSchema(ListFeaturesType);

/** @internal */
export const ListFeaturesCreditSchema$inboundSchema: z.ZodMiniType<
  ListFeaturesCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function listFeaturesCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ListFeaturesCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListFeaturesCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListFeaturesCreditSchema' from JSON`,
  );
}

/** @internal */
export const ListFeaturesDisplay$inboundSchema: z.ZodMiniType<
  ListFeaturesDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function listFeaturesDisplayFromJSON(
  jsonString: string,
): SafeParseResult<ListFeaturesDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListFeaturesDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListFeaturesDisplay' from JSON`,
  );
}

/** @internal */
export const ListFeaturesList$inboundSchema: z.ZodMiniType<
  ListFeaturesList,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: ListFeaturesType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => ListFeaturesCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => ListFeaturesDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function listFeaturesListFromJSON(
  jsonString: string,
): SafeParseResult<ListFeaturesList, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListFeaturesList$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListFeaturesList' from JSON`,
  );
}

/** @internal */
export const ListFeaturesResponse$inboundSchema: z.ZodMiniType<
  ListFeaturesResponse,
  unknown
> = z.object({
  list: z.array(z.lazy(() => ListFeaturesList$inboundSchema)),
});

export function listFeaturesResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListFeaturesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListFeaturesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListFeaturesResponse' from JSON`,
  );
}
