/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type ListCustomersGlobals = {
  xApiVersion?: string | undefined;
};

export type ListCustomersPlan = {
  id: string;
  versions?: Array<number> | undefined;
};

/**
 * Filter by customer product status. Defaults to active and scheduled
 */
export const SubscriptionStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Filter by customer product status. Defaults to active and scheduled
 */
export type SubscriptionStatus = ClosedEnum<typeof SubscriptionStatus>;

export type ListCustomersParams = {
  /**
   * Number of items to skip
   */
  offset?: number | undefined;
  /**
   * Number of items to return. Default 10, max 1000.
   */
  limit?: number | undefined;
  /**
   * Filter by plan ID and version. Returns customers with active subscriptions to this plan.
   */
  plans?: Array<ListCustomersPlan> | undefined;
  /**
   * Filter by customer product status. Defaults to active and scheduled
   */
  subscriptionStatus?: SubscriptionStatus | undefined;
  /**
   * Search customers by id, name, or email
   */
  search?: string | undefined;
};

/**
 * The environment this customer was created in.
 */
export const ListCustomersEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment this customer was created in.
 */
export type ListCustomersEnv = OpenEnum<typeof ListCustomersEnv>;

export const ListCustomersStatus = {
  Active: "active",
  Scheduled: "scheduled",
  Expired: "expired",
} as const;
export type ListCustomersStatus = OpenEnum<typeof ListCustomersStatus>;

export type ListCustomersSubscription = {
  plan?: Plan | undefined;
  planId: string;
  autoEnable: boolean;
  addOn: boolean;
  status: ListCustomersStatus;
  pastDue: boolean;
  canceledAt: number | null;
  expiresAt: number | null;
  trialEndsAt: number | null;
  startedAt: number;
  currentPeriodStart: number | null;
  currentPeriodEnd: number | null;
  quantity: number;
};

export type ListCustomersPurchase = {
  plan?: Plan | undefined;
  planId: string;
  expiresAt: number | null;
  startedAt: number;
  quantity: number;
};

export const ListCustomersType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type ListCustomersType = OpenEnum<typeof ListCustomersType>;

export type ListCustomersCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type ListCustomersDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type ListCustomersFeature = {
  id: string;
  name: string;
  type: ListCustomersType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<ListCustomersCreditSchema> | undefined;
  display?: ListCustomersDisplay | undefined;
  archived: boolean;
};

export const ListCustomersIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type ListCustomersIntervalEnum = OpenEnum<
  typeof ListCustomersIntervalEnum
>;

export type ListCustomersIntervalUnion = ListCustomersIntervalEnum | string;

export type ListCustomersReset = {
  interval: ListCustomersIntervalEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type ListCustomersTier = {
  to?: any | undefined;
  amount: number;
};

export const ListCustomersBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type ListCustomersBillingMethod = OpenEnum<
  typeof ListCustomersBillingMethod
>;

export type ListCustomersPrice = {
  amount?: number | undefined;
  tiers?: Array<ListCustomersTier> | undefined;
  billingUnits: number;
  billingMethod: ListCustomersBillingMethod;
  maxPurchase: number | null;
};

export type ListCustomersBreakdown = {
  object: "balance_breakdown";
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: ListCustomersReset | null;
  price: ListCustomersPrice | null;
  expiresAt: number | null;
};

export type ListCustomersRollover = {
  balance: number;
  expiresAt: number;
};

export type ListCustomersBalances = {
  object: "balance";
  featureId: string;
  feature?: ListCustomersFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<ListCustomersBreakdown> | undefined;
  rollovers?: Array<ListCustomersRollover> | undefined;
};

export type List = {
  /**
   * Your unique identifier for the customer.
   */
  id: string | null;
  /**
   * The name of the customer.
   */
  name: string | null;
  /**
   * The email address of the customer.
   */
  email: string | null;
  /**
   * Timestamp of customer creation in milliseconds since epoch.
   */
  createdAt: number;
  /**
   * A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID.
   */
  fingerprint: string | null;
  /**
   * Stripe customer ID.
   */
  stripeId: string | null;
  /**
   * The environment this customer was created in.
   */
  env: ListCustomersEnv;
  /**
   * The metadata for the customer.
   */
  metadata: { [k: string]: any };
  /**
   * Whether to send email receipts to the customer.
   */
  sendEmailReceipts: boolean;
  subscriptions: Array<ListCustomersSubscription>;
  purchases: Array<ListCustomersPurchase>;
  balances: { [k: string]: ListCustomersBalances };
};

/**
 * OK
 */
export type ListCustomersResponse = {
  /**
   * Array of items for current page
   */
  list: Array<List>;
  /**
   * Whether more results exist after this page
   */
  hasMore: boolean;
  /**
   * Current offset position
   */
  offset: number;
  /**
   * Limit passed in the request
   */
  limit: number;
  /**
   * Total number of items returned in the current page
   */
  total: number;
};

/** @internal */
export type ListCustomersPlan$Outbound = {
  id: string;
  versions?: Array<number> | undefined;
};

/** @internal */
export const ListCustomersPlan$outboundSchema: z.ZodMiniType<
  ListCustomersPlan$Outbound,
  ListCustomersPlan
> = z.object({
  id: z.string(),
  versions: z.optional(z.array(z.number())),
});

export function listCustomersPlanToJSON(
  listCustomersPlan: ListCustomersPlan,
): string {
  return JSON.stringify(
    ListCustomersPlan$outboundSchema.parse(listCustomersPlan),
  );
}

/** @internal */
export const SubscriptionStatus$outboundSchema: z.ZodMiniEnum<
  typeof SubscriptionStatus
> = z.enum(SubscriptionStatus);

/** @internal */
export type ListCustomersParams$Outbound = {
  offset: number;
  limit: number;
  plans?: Array<ListCustomersPlan$Outbound> | undefined;
  subscription_status?: string | undefined;
  search?: string | undefined;
};

/** @internal */
export const ListCustomersParams$outboundSchema: z.ZodMiniType<
  ListCustomersParams$Outbound,
  ListCustomersParams
> = z.pipe(
  z.object({
    offset: z._default(z.int(), 0),
    limit: z._default(z.int(), 10),
    plans: z.optional(z.array(z.lazy(() => ListCustomersPlan$outboundSchema))),
    subscriptionStatus: z.optional(SubscriptionStatus$outboundSchema),
    search: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      subscriptionStatus: "subscription_status",
    });
  }),
);

export function listCustomersParamsToJSON(
  listCustomersParams: ListCustomersParams,
): string {
  return JSON.stringify(
    ListCustomersParams$outboundSchema.parse(listCustomersParams),
  );
}

/** @internal */
export const ListCustomersEnv$inboundSchema: z.ZodMiniType<
  ListCustomersEnv,
  unknown
> = openEnums.inboundSchema(ListCustomersEnv);

/** @internal */
export const ListCustomersStatus$inboundSchema: z.ZodMiniType<
  ListCustomersStatus,
  unknown
> = openEnums.inboundSchema(ListCustomersStatus);

/** @internal */
export const ListCustomersSubscription$inboundSchema: z.ZodMiniType<
  ListCustomersSubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: ListCustomersStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function listCustomersSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersSubscription' from JSON`,
  );
}

/** @internal */
export const ListCustomersPurchase$inboundSchema: z.ZodMiniType<
  ListCustomersPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function listCustomersPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersPurchase' from JSON`,
  );
}

/** @internal */
export const ListCustomersType$inboundSchema: z.ZodMiniType<
  ListCustomersType,
  unknown
> = openEnums.inboundSchema(ListCustomersType);

/** @internal */
export const ListCustomersCreditSchema$inboundSchema: z.ZodMiniType<
  ListCustomersCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function listCustomersCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersCreditSchema' from JSON`,
  );
}

/** @internal */
export const ListCustomersDisplay$inboundSchema: z.ZodMiniType<
  ListCustomersDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function listCustomersDisplayFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersDisplay' from JSON`,
  );
}

/** @internal */
export const ListCustomersFeature$inboundSchema: z.ZodMiniType<
  ListCustomersFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: ListCustomersType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => ListCustomersCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => ListCustomersDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function listCustomersFeatureFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersFeature' from JSON`,
  );
}

/** @internal */
export const ListCustomersIntervalEnum$inboundSchema: z.ZodMiniType<
  ListCustomersIntervalEnum,
  unknown
> = openEnums.inboundSchema(ListCustomersIntervalEnum);

/** @internal */
export const ListCustomersIntervalUnion$inboundSchema: z.ZodMiniType<
  ListCustomersIntervalUnion,
  unknown
> = smartUnion([ListCustomersIntervalEnum$inboundSchema, types.string()]);

export function listCustomersIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersIntervalUnion' from JSON`,
  );
}

/** @internal */
export const ListCustomersReset$inboundSchema: z.ZodMiniType<
  ListCustomersReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      ListCustomersIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function listCustomersResetFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersReset' from JSON`,
  );
}

/** @internal */
export const ListCustomersTier$inboundSchema: z.ZodMiniType<
  ListCustomersTier,
  unknown
> = z.object({
  to: types.optional(z.any()),
  amount: types.number(),
});

export function listCustomersTierFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersTier' from JSON`,
  );
}

/** @internal */
export const ListCustomersBillingMethod$inboundSchema: z.ZodMiniType<
  ListCustomersBillingMethod,
  unknown
> = openEnums.inboundSchema(ListCustomersBillingMethod);

/** @internal */
export const ListCustomersPrice$inboundSchema: z.ZodMiniType<
  ListCustomersPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => ListCustomersTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: ListCustomersBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function listCustomersPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersPrice' from JSON`,
  );
}

/** @internal */
export const ListCustomersBreakdown$inboundSchema: z.ZodMiniType<
  ListCustomersBreakdown,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance_breakdown"),
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => ListCustomersReset$inboundSchema)),
    price: types.nullable(z.lazy(() => ListCustomersPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function listCustomersBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersBreakdown' from JSON`,
  );
}

/** @internal */
export const ListCustomersRollover$inboundSchema: z.ZodMiniType<
  ListCustomersRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function listCustomersRolloverFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersRollover' from JSON`,
  );
}

/** @internal */
export const ListCustomersBalances$inboundSchema: z.ZodMiniType<
  ListCustomersBalances,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance"),
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => ListCustomersFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => ListCustomersBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => ListCustomersRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function listCustomersBalancesFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersBalances' from JSON`,
  );
}

/** @internal */
export const List$inboundSchema: z.ZodMiniType<List, unknown> = z.pipe(
  z.object({
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    email: types.nullable(types.string()),
    created_at: types.number(),
    fingerprint: types.nullable(types.string()),
    stripe_id: types.nullable(types.string()),
    env: ListCustomersEnv$inboundSchema,
    metadata: z.record(z.string(), z.any()),
    send_email_receipts: types.boolean(),
    subscriptions: z.array(
      z.lazy(() => ListCustomersSubscription$inboundSchema),
    ),
    purchases: z.array(z.lazy(() => ListCustomersPurchase$inboundSchema)),
    balances: z.record(
      z.string(),
      z.lazy(() => ListCustomersBalances$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "stripe_id": "stripeId",
      "send_email_receipts": "sendEmailReceipts",
    });
  }),
);

export function listFromJSON(
  jsonString: string,
): SafeParseResult<List, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => List$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'List' from JSON`,
  );
}

/** @internal */
export const ListCustomersResponse$inboundSchema: z.ZodMiniType<
  ListCustomersResponse,
  unknown
> = z.pipe(
  z.object({
    list: z.array(z.lazy(() => List$inboundSchema)),
    has_more: types.boolean(),
    offset: types.number(),
    limit: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "has_more": "hasMore",
    });
  }),
);

export function listCustomersResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersResponse' from JSON`,
  );
}
