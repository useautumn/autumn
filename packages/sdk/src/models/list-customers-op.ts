/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { Balance, Balance$inboundSchema } from "./balance.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type ListCustomersGlobals = {
  xApiVersion?: string | undefined;
};

export type ListCustomersPlan = {
  id: string;
  versions?: Array<number> | undefined;
};

/**
 * Filter by customer product status. Defaults to active and scheduled
 */
export const SubscriptionStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Filter by customer product status. Defaults to active and scheduled
 */
export type SubscriptionStatus = ClosedEnum<typeof SubscriptionStatus>;

export type ListCustomersParams = {
  /**
   * Number of items to skip
   */
  offset?: number | undefined;
  /**
   * Number of items to return. Default 10, max 1000.
   */
  limit?: number | undefined;
  /**
   * Filter by plan ID and version. Returns customers with active subscriptions to this plan.
   */
  plans?: Array<ListCustomersPlan> | undefined;
  /**
   * Filter by customer product status. Defaults to active and scheduled
   */
  subscriptionStatus?: SubscriptionStatus | undefined;
  /**
   * Search customers by id, name, or email
   */
  search?: string | undefined;
};

/**
 * The environment this customer was created in.
 */
export const ListCustomersEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment this customer was created in.
 */
export type ListCustomersEnv = OpenEnum<typeof ListCustomersEnv>;

/**
 * Current status of the subscription.
 */
export const ListCustomersStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Current status of the subscription.
 */
export type ListCustomersStatus = OpenEnum<typeof ListCustomersStatus>;

export type ListCustomersSubscription = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the subscribed plan.
   */
  planId: string;
  /**
   * Whether the plan was automatically enabled for the customer.
   */
  autoEnable: boolean;
  /**
   * Whether this is an add-on plan rather than a base subscription.
   */
  addOn: boolean;
  /**
   * Current status of the subscription.
   */
  status: ListCustomersStatus;
  /**
   * Whether the subscription has overdue payments.
   */
  pastDue: boolean;
  /**
   * Timestamp when the subscription was canceled, or null if not canceled.
   */
  canceledAt: number | null;
  /**
   * Timestamp when the subscription will expire, or null if no expiry set.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the trial period ends, or null if not on trial.
   */
  trialEndsAt: number | null;
  /**
   * Timestamp when the subscription started.
   */
  startedAt: number;
  /**
   * Start timestamp of the current billing period.
   */
  currentPeriodStart: number | null;
  /**
   * End timestamp of the current billing period.
   */
  currentPeriodEnd: number | null;
  /**
   * Number of units of this subscription (for per-seat plans).
   */
  quantity: number;
};

export type ListCustomersPurchase = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the purchased plan.
   */
  planId: string;
  /**
   * Timestamp when the purchase expires, or null for lifetime access.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the purchase was made.
   */
  startedAt: number;
  /**
   * Number of units purchased.
   */
  quantity: number;
};

export type ListCustomersList = {
  /**
   * Your unique identifier for the customer.
   */
  id: string | null;
  /**
   * The name of the customer.
   */
  name: string | null;
  /**
   * The email address of the customer.
   */
  email: string | null;
  /**
   * Timestamp of customer creation in milliseconds since epoch.
   */
  createdAt: number;
  /**
   * A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID.
   */
  fingerprint: string | null;
  /**
   * Stripe customer ID.
   */
  stripeId: string | null;
  /**
   * The environment this customer was created in.
   */
  env: ListCustomersEnv;
  /**
   * The metadata for the customer.
   */
  metadata: { [k: string]: any };
  /**
   * Whether to send email receipts to the customer.
   */
  sendEmailReceipts: boolean;
  /**
   * Active and scheduled recurring plans that this customer has attached.
   */
  subscriptions: Array<ListCustomersSubscription>;
  /**
   * One-time purchases made by the customer.
   */
  purchases: Array<ListCustomersPurchase>;
  /**
   * Feature balances keyed by feature ID, showing usage limits and remaining amounts.
   */
  balances: { [k: string]: Balance };
};

/**
 * OK
 */
export type ListCustomersResponse = {
  /**
   * Array of items for current page
   */
  list: Array<ListCustomersList>;
  /**
   * Whether more results exist after this page
   */
  hasMore: boolean;
  /**
   * Current offset position
   */
  offset: number;
  /**
   * Limit passed in the request
   */
  limit: number;
  /**
   * Total number of items returned in the current page
   */
  total: number;
};

/** @internal */
export type ListCustomersPlan$Outbound = {
  id: string;
  versions?: Array<number> | undefined;
};

/** @internal */
export const ListCustomersPlan$outboundSchema: z.ZodMiniType<
  ListCustomersPlan$Outbound,
  ListCustomersPlan
> = z.object({
  id: z.string(),
  versions: z.optional(z.array(z.number())),
});

export function listCustomersPlanToJSON(
  listCustomersPlan: ListCustomersPlan,
): string {
  return JSON.stringify(
    ListCustomersPlan$outboundSchema.parse(listCustomersPlan),
  );
}

/** @internal */
export const SubscriptionStatus$outboundSchema: z.ZodMiniEnum<
  typeof SubscriptionStatus
> = z.enum(SubscriptionStatus);

/** @internal */
export type ListCustomersParams$Outbound = {
  offset: number;
  limit: number;
  plans?: Array<ListCustomersPlan$Outbound> | undefined;
  subscription_status?: string | undefined;
  search?: string | undefined;
};

/** @internal */
export const ListCustomersParams$outboundSchema: z.ZodMiniType<
  ListCustomersParams$Outbound,
  ListCustomersParams
> = z.pipe(
  z.object({
    offset: z._default(z.int(), 0),
    limit: z._default(z.int(), 10),
    plans: z.optional(z.array(z.lazy(() => ListCustomersPlan$outboundSchema))),
    subscriptionStatus: z.optional(SubscriptionStatus$outboundSchema),
    search: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      subscriptionStatus: "subscription_status",
    });
  }),
);

export function listCustomersParamsToJSON(
  listCustomersParams: ListCustomersParams,
): string {
  return JSON.stringify(
    ListCustomersParams$outboundSchema.parse(listCustomersParams),
  );
}

/** @internal */
export const ListCustomersEnv$inboundSchema: z.ZodMiniType<
  ListCustomersEnv,
  unknown
> = openEnums.inboundSchema(ListCustomersEnv);

/** @internal */
export const ListCustomersStatus$inboundSchema: z.ZodMiniType<
  ListCustomersStatus,
  unknown
> = openEnums.inboundSchema(ListCustomersStatus);

/** @internal */
export const ListCustomersSubscription$inboundSchema: z.ZodMiniType<
  ListCustomersSubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: ListCustomersStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function listCustomersSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersSubscription' from JSON`,
  );
}

/** @internal */
export const ListCustomersPurchase$inboundSchema: z.ZodMiniType<
  ListCustomersPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function listCustomersPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersPurchase' from JSON`,
  );
}

/** @internal */
export const ListCustomersList$inboundSchema: z.ZodMiniType<
  ListCustomersList,
  unknown
> = z.pipe(
  z.object({
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    email: types.nullable(types.string()),
    created_at: types.number(),
    fingerprint: types.nullable(types.string()),
    stripe_id: types.nullable(types.string()),
    env: ListCustomersEnv$inboundSchema,
    metadata: z.record(z.string(), z.any()),
    send_email_receipts: types.boolean(),
    subscriptions: z.array(
      z.lazy(() => ListCustomersSubscription$inboundSchema),
    ),
    purchases: z.array(z.lazy(() => ListCustomersPurchase$inboundSchema)),
    balances: z.record(z.string(), Balance$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "stripe_id": "stripeId",
      "send_email_receipts": "sendEmailReceipts",
    });
  }),
);

export function listCustomersListFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersList, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersList$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersList' from JSON`,
  );
}

/** @internal */
export const ListCustomersResponse$inboundSchema: z.ZodMiniType<
  ListCustomersResponse,
  unknown
> = z.pipe(
  z.object({
    list: z.array(z.lazy(() => ListCustomersList$inboundSchema)),
    has_more: types.boolean(),
    offset: types.number(),
    limit: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "has_more": "hasMore",
    });
  }),
);

export function listCustomersResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersResponse' from JSON`,
  );
}
