/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import {
  CustomerData,
  CustomerData$Outbound,
  CustomerData$outboundSchema,
} from "./customer-data.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type PreviewMultiAttachGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const PreviewMultiAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type PreviewMultiAttachPriceInterval = ClosedEnum<
  typeof PreviewMultiAttachPriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type PreviewMultiAttachBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: PreviewMultiAttachPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const PreviewMultiAttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type PreviewMultiAttachResetInterval = ClosedEnum<
  typeof PreviewMultiAttachResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type PreviewMultiAttachReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: PreviewMultiAttachResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type PreviewMultiAttachTo = number | string;

export type PreviewMultiAttachTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const PreviewMultiAttachTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type PreviewMultiAttachTierBehavior = ClosedEnum<
  typeof PreviewMultiAttachTierBehavior
>;

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const PreviewMultiAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type PreviewMultiAttachItemPriceInterval = ClosedEnum<
  typeof PreviewMultiAttachItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const PreviewMultiAttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type PreviewMultiAttachBillingMethod = ClosedEnum<
  typeof PreviewMultiAttachBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type PreviewMultiAttachPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing.  Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<PreviewMultiAttachTier> | undefined;
  tierBehavior?: PreviewMultiAttachTierBehavior | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: PreviewMultiAttachItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: PreviewMultiAttachBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const PreviewMultiAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type PreviewMultiAttachOnIncrease = ClosedEnum<
  typeof PreviewMultiAttachOnIncrease
>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const PreviewMultiAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type PreviewMultiAttachOnDecrease = ClosedEnum<
  typeof PreviewMultiAttachOnDecrease
>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type PreviewMultiAttachProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: PreviewMultiAttachOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: PreviewMultiAttachOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const PreviewMultiAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type PreviewMultiAttachExpiryDurationType = ClosedEnum<
  typeof PreviewMultiAttachExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type PreviewMultiAttachRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: PreviewMultiAttachExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type PreviewMultiAttachPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: PreviewMultiAttachReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: PreviewMultiAttachPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: PreviewMultiAttachProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: PreviewMultiAttachRollover | undefined;
};

/**
 * Customize the plan to attach. Can override the price or items.
 */
export type PreviewMultiAttachCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: PreviewMultiAttachBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<PreviewMultiAttachPlanItem> | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type PreviewMultiAttachFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

export type PreviewMultiAttachPlan = {
  /**
   * The ID of the plan to attach.
   */
  planId: string;
  /**
   * Customize the plan to attach. Can override the price or items.
   */
  customize?: PreviewMultiAttachCustomize | undefined;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature.
   */
  featureQuantities?: Array<PreviewMultiAttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const PreviewMultiAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type PreviewMultiAttachDurationType = ClosedEnum<
  typeof PreviewMultiAttachDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type PreviewMultiAttachFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: PreviewMultiAttachDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
 */
export type PreviewMultiAttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type PreviewMultiAttachAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

/**
 * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
 */
export const PreviewMultiAttachRedirectMode = {
  Always: "always",
  IfRequired: "if_required",
  Never: "never",
} as const;
/**
 * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
 */
export type PreviewMultiAttachRedirectMode = ClosedEnum<
  typeof PreviewMultiAttachRedirectMode
>;

export type PreviewMultiAttachEntityData = {
  /**
   * The feature ID that this entity is associated with
   */
  featureId: string;
  /**
   * Name of the entity
   */
  name?: string | undefined;
};

export type PreviewMultiAttachParams = {
  /**
   * The ID of the customer to attach the plans to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plans to.
   */
  entityId?: string | undefined;
  /**
   * The list of plans to attach to the customer.
   */
  plans: Array<PreviewMultiAttachPlan>;
  /**
   * Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
   */
  freeTrial?: PreviewMultiAttachFreeTrialParams | null | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
   */
  invoiceMode?: PreviewMultiAttachInvoiceMode | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<PreviewMultiAttachAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Additional parameters to pass into the creation of the Stripe checkout session.
   */
  checkoutSessionParams?: { [k: string]: any } | undefined;
  /**
   * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
   */
  redirectMode?: PreviewMultiAttachRedirectMode | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * Customer details to set when creating a customer
   */
  customerData?: CustomerData | undefined;
  entityData?: PreviewMultiAttachEntityData | undefined;
};

export type PreviewMultiAttachDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type PreviewMultiAttachLineItem = {
  /**
   * The title of the line item.
   */
  title: string;
  /**
   * A detailed description of the line item.
   */
  description: string;
  /**
   * The amount in cents for this line item.
   */
  amount: number;
  /**
   * List of discounts applied to this line item.
   */
  discounts?: Array<PreviewMultiAttachDiscount> | undefined;
};

/**
 * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
 */
export type PreviewMultiAttachNextCycle = {
  /**
   * Unix timestamp (milliseconds) when the next billing cycle starts.
   */
  startsAt: number;
  /**
   * The total amount in cents for the next cycle.
   */
  total: number;
};

/**
 * OK
 */
export type PreviewMultiAttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * List of line items for the current billing period.
   */
  lineItems: Array<PreviewMultiAttachLineItem>;
  /**
   * The total amount in cents for the current billing period.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
   */
  nextCycle?: PreviewMultiAttachNextCycle | undefined;
};

/** @internal */
export const PreviewMultiAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachPriceInterval
> = z.enum(PreviewMultiAttachPriceInterval);

/** @internal */
export type PreviewMultiAttachBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewMultiAttachBasePrice$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachBasePrice$Outbound,
  PreviewMultiAttachBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: PreviewMultiAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewMultiAttachBasePriceToJSON(
  previewMultiAttachBasePrice: PreviewMultiAttachBasePrice,
): string {
  return JSON.stringify(
    PreviewMultiAttachBasePrice$outboundSchema.parse(
      previewMultiAttachBasePrice,
    ),
  );
}

/** @internal */
export const PreviewMultiAttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachResetInterval
> = z.enum(PreviewMultiAttachResetInterval);

/** @internal */
export type PreviewMultiAttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewMultiAttachReset$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachReset$Outbound,
  PreviewMultiAttachReset
> = z.pipe(
  z.object({
    interval: PreviewMultiAttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewMultiAttachResetToJSON(
  previewMultiAttachReset: PreviewMultiAttachReset,
): string {
  return JSON.stringify(
    PreviewMultiAttachReset$outboundSchema.parse(previewMultiAttachReset),
  );
}

/** @internal */
export type PreviewMultiAttachTo$Outbound = number | string;

/** @internal */
export const PreviewMultiAttachTo$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachTo$Outbound,
  PreviewMultiAttachTo
> = smartUnion([z.number(), z.string()]);

export function previewMultiAttachToToJSON(
  previewMultiAttachTo: PreviewMultiAttachTo,
): string {
  return JSON.stringify(
    PreviewMultiAttachTo$outboundSchema.parse(previewMultiAttachTo),
  );
}

/** @internal */
export type PreviewMultiAttachTier$Outbound = {
  to: number | string;
  amount: number;
  flat_amount?: number | null | undefined;
};

/** @internal */
export const PreviewMultiAttachTier$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachTier$Outbound,
  PreviewMultiAttachTier
> = z.pipe(
  z.object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
    flatAmount: z.optional(z.nullable(z.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      flatAmount: "flat_amount",
    });
  }),
);

export function previewMultiAttachTierToJSON(
  previewMultiAttachTier: PreviewMultiAttachTier,
): string {
  return JSON.stringify(
    PreviewMultiAttachTier$outboundSchema.parse(previewMultiAttachTier),
  );
}

/** @internal */
export const PreviewMultiAttachTierBehavior$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachTierBehavior
> = z.enum(PreviewMultiAttachTierBehavior);

/** @internal */
export const PreviewMultiAttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachItemPriceInterval
> = z.enum(PreviewMultiAttachItemPriceInterval);

/** @internal */
export const PreviewMultiAttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachBillingMethod
> = z.enum(PreviewMultiAttachBillingMethod);

/** @internal */
export type PreviewMultiAttachPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<PreviewMultiAttachTier$Outbound> | undefined;
  tier_behavior?: string | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const PreviewMultiAttachPrice$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachPrice$Outbound,
  PreviewMultiAttachPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(
      z.array(z.lazy(() => PreviewMultiAttachTier$outboundSchema)),
    ),
    tierBehavior: z.optional(PreviewMultiAttachTierBehavior$outboundSchema),
    interval: PreviewMultiAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: PreviewMultiAttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      tierBehavior: "tier_behavior",
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function previewMultiAttachPriceToJSON(
  previewMultiAttachPrice: PreviewMultiAttachPrice,
): string {
  return JSON.stringify(
    PreviewMultiAttachPrice$outboundSchema.parse(previewMultiAttachPrice),
  );
}

/** @internal */
export const PreviewMultiAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachOnIncrease
> = z.enum(PreviewMultiAttachOnIncrease);

/** @internal */
export const PreviewMultiAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachOnDecrease
> = z.enum(PreviewMultiAttachOnDecrease);

/** @internal */
export type PreviewMultiAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const PreviewMultiAttachProration$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachProration$Outbound,
  PreviewMultiAttachProration
> = z.pipe(
  z.object({
    onIncrease: PreviewMultiAttachOnIncrease$outboundSchema,
    onDecrease: PreviewMultiAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function previewMultiAttachProrationToJSON(
  previewMultiAttachProration: PreviewMultiAttachProration,
): string {
  return JSON.stringify(
    PreviewMultiAttachProration$outboundSchema.parse(
      previewMultiAttachProration,
    ),
  );
}

/** @internal */
export const PreviewMultiAttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachExpiryDurationType
> = z.enum(PreviewMultiAttachExpiryDurationType);

/** @internal */
export type PreviewMultiAttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const PreviewMultiAttachRollover$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachRollover$Outbound,
  PreviewMultiAttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: PreviewMultiAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function previewMultiAttachRolloverToJSON(
  previewMultiAttachRollover: PreviewMultiAttachRollover,
): string {
  return JSON.stringify(
    PreviewMultiAttachRollover$outboundSchema.parse(previewMultiAttachRollover),
  );
}

/** @internal */
export type PreviewMultiAttachPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: PreviewMultiAttachReset$Outbound | undefined;
  price?: PreviewMultiAttachPrice$Outbound | undefined;
  proration?: PreviewMultiAttachProration$Outbound | undefined;
  rollover?: PreviewMultiAttachRollover$Outbound | undefined;
};

/** @internal */
export const PreviewMultiAttachPlanItem$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachPlanItem$Outbound,
  PreviewMultiAttachPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => PreviewMultiAttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => PreviewMultiAttachPrice$outboundSchema)),
    proration: z.optional(
      z.lazy(() => PreviewMultiAttachProration$outboundSchema),
    ),
    rollover: z.optional(
      z.lazy(() => PreviewMultiAttachRollover$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewMultiAttachPlanItemToJSON(
  previewMultiAttachPlanItem: PreviewMultiAttachPlanItem,
): string {
  return JSON.stringify(
    PreviewMultiAttachPlanItem$outboundSchema.parse(previewMultiAttachPlanItem),
  );
}

/** @internal */
export type PreviewMultiAttachCustomize$Outbound = {
  price?: PreviewMultiAttachBasePrice$Outbound | null | undefined;
  items?: Array<PreviewMultiAttachPlanItem$Outbound> | undefined;
};

/** @internal */
export const PreviewMultiAttachCustomize$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachCustomize$Outbound,
  PreviewMultiAttachCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => PreviewMultiAttachBasePrice$outboundSchema)),
  ),
  items: z.optional(
    z.array(z.lazy(() => PreviewMultiAttachPlanItem$outboundSchema)),
  ),
});

export function previewMultiAttachCustomizeToJSON(
  previewMultiAttachCustomize: PreviewMultiAttachCustomize,
): string {
  return JSON.stringify(
    PreviewMultiAttachCustomize$outboundSchema.parse(
      previewMultiAttachCustomize,
    ),
  );
}

/** @internal */
export type PreviewMultiAttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const PreviewMultiAttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachFeatureQuantity$Outbound,
  PreviewMultiAttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewMultiAttachFeatureQuantityToJSON(
  previewMultiAttachFeatureQuantity: PreviewMultiAttachFeatureQuantity,
): string {
  return JSON.stringify(
    PreviewMultiAttachFeatureQuantity$outboundSchema.parse(
      previewMultiAttachFeatureQuantity,
    ),
  );
}

/** @internal */
export type PreviewMultiAttachPlan$Outbound = {
  plan_id: string;
  customize?: PreviewMultiAttachCustomize$Outbound | undefined;
  feature_quantities?:
    | Array<PreviewMultiAttachFeatureQuantity$Outbound>
    | undefined;
  version?: number | undefined;
};

/** @internal */
export const PreviewMultiAttachPlan$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachPlan$Outbound,
  PreviewMultiAttachPlan
> = z.pipe(
  z.object({
    planId: z.string(),
    customize: z.optional(
      z.lazy(() => PreviewMultiAttachCustomize$outboundSchema),
    ),
    featureQuantities: z.optional(
      z.array(z.lazy(() => PreviewMultiAttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      planId: "plan_id",
      featureQuantities: "feature_quantities",
    });
  }),
);

export function previewMultiAttachPlanToJSON(
  previewMultiAttachPlan: PreviewMultiAttachPlan,
): string {
  return JSON.stringify(
    PreviewMultiAttachPlan$outboundSchema.parse(previewMultiAttachPlan),
  );
}

/** @internal */
export const PreviewMultiAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachDurationType
> = z.enum(PreviewMultiAttachDurationType);

/** @internal */
export type PreviewMultiAttachFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const PreviewMultiAttachFreeTrialParams$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachFreeTrialParams$Outbound,
  PreviewMultiAttachFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(
      PreviewMultiAttachDurationType$outboundSchema,
      "month",
    ),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function previewMultiAttachFreeTrialParamsToJSON(
  previewMultiAttachFreeTrialParams: PreviewMultiAttachFreeTrialParams,
): string {
  return JSON.stringify(
    PreviewMultiAttachFreeTrialParams$outboundSchema.parse(
      previewMultiAttachFreeTrialParams,
    ),
  );
}

/** @internal */
export type PreviewMultiAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const PreviewMultiAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachInvoiceMode$Outbound,
  PreviewMultiAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function previewMultiAttachInvoiceModeToJSON(
  previewMultiAttachInvoiceMode: PreviewMultiAttachInvoiceMode,
): string {
  return JSON.stringify(
    PreviewMultiAttachInvoiceMode$outboundSchema.parse(
      previewMultiAttachInvoiceMode,
    ),
  );
}

/** @internal */
export type PreviewMultiAttachAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const PreviewMultiAttachAttachDiscount$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachAttachDiscount$Outbound,
  PreviewMultiAttachAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function previewMultiAttachAttachDiscountToJSON(
  previewMultiAttachAttachDiscount: PreviewMultiAttachAttachDiscount,
): string {
  return JSON.stringify(
    PreviewMultiAttachAttachDiscount$outboundSchema.parse(
      previewMultiAttachAttachDiscount,
    ),
  );
}

/** @internal */
export const PreviewMultiAttachRedirectMode$outboundSchema: z.ZodMiniEnum<
  typeof PreviewMultiAttachRedirectMode
> = z.enum(PreviewMultiAttachRedirectMode);

/** @internal */
export type PreviewMultiAttachEntityData$Outbound = {
  feature_id: string;
  name?: string | undefined;
};

/** @internal */
export const PreviewMultiAttachEntityData$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachEntityData$Outbound,
  PreviewMultiAttachEntityData
> = z.pipe(
  z.object({
    featureId: z.string(),
    name: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewMultiAttachEntityDataToJSON(
  previewMultiAttachEntityData: PreviewMultiAttachEntityData,
): string {
  return JSON.stringify(
    PreviewMultiAttachEntityData$outboundSchema.parse(
      previewMultiAttachEntityData,
    ),
  );
}

/** @internal */
export type PreviewMultiAttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plans: Array<PreviewMultiAttachPlan$Outbound>;
  free_trial?: PreviewMultiAttachFreeTrialParams$Outbound | null | undefined;
  invoice_mode?: PreviewMultiAttachInvoiceMode$Outbound | undefined;
  discounts?: Array<PreviewMultiAttachAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  checkout_session_params?: { [k: string]: any } | undefined;
  redirect_mode: string;
  new_billing_subscription?: boolean | undefined;
  customer_data?: CustomerData$Outbound | undefined;
  entity_data?: PreviewMultiAttachEntityData$Outbound | undefined;
};

/** @internal */
export const PreviewMultiAttachParams$outboundSchema: z.ZodMiniType<
  PreviewMultiAttachParams$Outbound,
  PreviewMultiAttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    plans: z.array(z.lazy(() => PreviewMultiAttachPlan$outboundSchema)),
    freeTrial: z.optional(
      z.nullable(
        z.lazy(() => PreviewMultiAttachFreeTrialParams$outboundSchema),
      ),
    ),
    invoiceMode: z.optional(
      z.lazy(() => PreviewMultiAttachInvoiceMode$outboundSchema),
    ),
    discounts: z.optional(
      z.array(z.lazy(() => PreviewMultiAttachAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    checkoutSessionParams: z.optional(z.record(z.string(), z.any())),
    redirectMode: z._default(
      PreviewMultiAttachRedirectMode$outboundSchema,
      "if_required",
    ),
    newBillingSubscription: z.optional(z.boolean()),
    customerData: z.optional(CustomerData$outboundSchema),
    entityData: z.optional(
      z.lazy(() => PreviewMultiAttachEntityData$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      freeTrial: "free_trial",
      invoiceMode: "invoice_mode",
      successUrl: "success_url",
      checkoutSessionParams: "checkout_session_params",
      redirectMode: "redirect_mode",
      newBillingSubscription: "new_billing_subscription",
      customerData: "customer_data",
      entityData: "entity_data",
    });
  }),
);

export function previewMultiAttachParamsToJSON(
  previewMultiAttachParams: PreviewMultiAttachParams,
): string {
  return JSON.stringify(
    PreviewMultiAttachParams$outboundSchema.parse(previewMultiAttachParams),
  );
}

/** @internal */
export const PreviewMultiAttachDiscount$inboundSchema: z.ZodMiniType<
  PreviewMultiAttachDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function previewMultiAttachDiscountFromJSON(
  jsonString: string,
): SafeParseResult<PreviewMultiAttachDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewMultiAttachDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewMultiAttachDiscount' from JSON`,
  );
}

/** @internal */
export const PreviewMultiAttachLineItem$inboundSchema: z.ZodMiniType<
  PreviewMultiAttachLineItem,
  unknown
> = z.object({
  title: types.string(),
  description: types.string(),
  amount: types.number(),
  discounts: types.optional(
    z.array(z.lazy(() => PreviewMultiAttachDiscount$inboundSchema)),
  ),
});

export function previewMultiAttachLineItemFromJSON(
  jsonString: string,
): SafeParseResult<PreviewMultiAttachLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewMultiAttachLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewMultiAttachLineItem' from JSON`,
  );
}

/** @internal */
export const PreviewMultiAttachNextCycle$inboundSchema: z.ZodMiniType<
  PreviewMultiAttachNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
    });
  }),
);

export function previewMultiAttachNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<PreviewMultiAttachNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewMultiAttachNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewMultiAttachNextCycle' from JSON`,
  );
}

/** @internal */
export const PreviewMultiAttachResponse$inboundSchema: z.ZodMiniType<
  PreviewMultiAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(z.lazy(() => PreviewMultiAttachLineItem$inboundSchema)),
    total: types.number(),
    currency: types.string(),
    next_cycle: types.optional(
      z.lazy(() => PreviewMultiAttachNextCycle$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "next_cycle": "nextCycle",
    });
  }),
);

export function previewMultiAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<PreviewMultiAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewMultiAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewMultiAttachResponse' from JSON`,
  );
}
