/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export const BalanceType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export type BalanceType = OpenEnum<typeof BalanceType>;

export type BalanceCreditSchema = {
  /**
   * ID of the metered feature that draws from this credit system.
   */
  meteredFeatureId: string;
  /**
   * Credits consumed per unit of the metered feature.
   */
  creditCost: number;
};

/**
 * Display names for the feature in billing UI and customer-facing components.
 */
export type BalanceDisplay = {
  /**
   * Singular form for UI display (e.g., 'API call', 'seat').
   */
  singular?: string | null | undefined;
  /**
   * Plural form for UI display (e.g., 'API calls', 'seats').
   */
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type BalanceFeature = {
  /**
   * The unique identifier for this feature, used in /check and /track calls.
   */
  id: string;
  /**
   * Human-readable name displayed in the dashboard and billing UI.
   */
  name: string;
  /**
   * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
   */
  type: BalanceType;
  /**
   * For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage).
   */
  consumable: boolean;
  /**
   * Event names that trigger this feature's balance. Allows multiple features to respond to a single event.
   */
  eventNames?: Array<string> | undefined;
  /**
   * For credit_system features: maps metered features to their credit costs.
   */
  creditSchema?: Array<BalanceCreditSchema> | undefined;
  /**
   * Display names for the feature in billing UI and customer-facing components.
   */
  display?: BalanceDisplay | undefined;
  /**
   * Whether the feature is archived and hidden from the dashboard.
   */
  archived: boolean;
};

export const BalanceIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BalanceIntervalEnum = OpenEnum<typeof BalanceIntervalEnum>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type Interval = BalanceIntervalEnum | string;

export type BalanceReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: BalanceIntervalEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type BalanceTo = number | string;

export type BalanceTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

/**
 * How tiers are applied: graduated (split across bands) or volume (flat rate for the matched tier).
 */
export const BalanceTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
/**
 * How tiers are applied: graduated (split across bands) or volume (flat rate for the matched tier).
 */
export type BalanceTierBehavior = OpenEnum<typeof BalanceTierBehavior>;

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const BalanceBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type BalanceBillingMethod = OpenEnum<typeof BalanceBillingMethod>;

export type BalancePrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<BalanceTier> | undefined;
  /**
   * How tiers are applied: graduated (split across bands) or volume (flat rate for the matched tier).
   */
  tierBehavior?: BalanceTierBehavior | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: BalanceBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type Breakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: BalanceReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: BalancePrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type BalanceRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type Balance = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: BalanceFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<Breakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<BalanceRollover> | undefined;
};

/** @internal */
export const BalanceType$inboundSchema: z.ZodMiniType<BalanceType, unknown> =
  openEnums.inboundSchema(BalanceType);

/** @internal */
export const BalanceCreditSchema$inboundSchema: z.ZodMiniType<
  BalanceCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function balanceCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<BalanceCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceCreditSchema' from JSON`,
  );
}

/** @internal */
export const BalanceDisplay$inboundSchema: z.ZodMiniType<
  BalanceDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function balanceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<BalanceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceDisplay' from JSON`,
  );
}

/** @internal */
export const BalanceFeature$inboundSchema: z.ZodMiniType<
  BalanceFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: BalanceType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => BalanceCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => BalanceDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function balanceFeatureFromJSON(
  jsonString: string,
): SafeParseResult<BalanceFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceFeature' from JSON`,
  );
}

/** @internal */
export const BalanceIntervalEnum$inboundSchema: z.ZodMiniType<
  BalanceIntervalEnum,
  unknown
> = openEnums.inboundSchema(BalanceIntervalEnum);

/** @internal */
export const Interval$inboundSchema: z.ZodMiniType<Interval, unknown> =
  smartUnion([BalanceIntervalEnum$inboundSchema, types.string()]);

export function intervalFromJSON(
  jsonString: string,
): SafeParseResult<Interval, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Interval$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Interval' from JSON`,
  );
}

/** @internal */
export const BalanceReset$inboundSchema: z.ZodMiniType<BalanceReset, unknown> =
  z.pipe(
    z.object({
      interval: smartUnion([BalanceIntervalEnum$inboundSchema, types.string()]),
      interval_count: types.optional(types.number()),
      resets_at: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
        "resets_at": "resetsAt",
      });
    }),
  );

export function balanceResetFromJSON(
  jsonString: string,
): SafeParseResult<BalanceReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceReset' from JSON`,
  );
}

/** @internal */
export const BalanceTo$inboundSchema: z.ZodMiniType<BalanceTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function balanceToFromJSON(
  jsonString: string,
): SafeParseResult<BalanceTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceTo' from JSON`,
  );
}

/** @internal */
export const BalanceTier$inboundSchema: z.ZodMiniType<BalanceTier, unknown> = z
  .pipe(
    z.object({
      to: smartUnion([types.number(), types.string()]),
      amount: types.number(),
      flat_amount: z.optional(z.nullable(types.number())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "flat_amount": "flatAmount",
      });
    }),
  );

export function balanceTierFromJSON(
  jsonString: string,
): SafeParseResult<BalanceTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceTier' from JSON`,
  );
}

/** @internal */
export const BalanceTierBehavior$inboundSchema: z.ZodMiniType<
  BalanceTierBehavior,
  unknown
> = openEnums.inboundSchema(BalanceTierBehavior);

/** @internal */
export const BalanceBillingMethod$inboundSchema: z.ZodMiniType<
  BalanceBillingMethod,
  unknown
> = openEnums.inboundSchema(BalanceBillingMethod);

/** @internal */
export const BalancePrice$inboundSchema: z.ZodMiniType<BalancePrice, unknown> =
  z.pipe(
    z.object({
      amount: types.optional(types.number()),
      tiers: types.optional(z.array(z.lazy(() => BalanceTier$inboundSchema))),
      tier_behavior: types.optional(BalanceTierBehavior$inboundSchema),
      billing_units: types.number(),
      billing_method: BalanceBillingMethod$inboundSchema,
      max_purchase: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tier_behavior": "tierBehavior",
        "billing_units": "billingUnits",
        "billing_method": "billingMethod",
        "max_purchase": "maxPurchase",
      });
    }),
  );

export function balancePriceFromJSON(
  jsonString: string,
): SafeParseResult<BalancePrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancePrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancePrice' from JSON`,
  );
}

/** @internal */
export const Breakdown$inboundSchema: z.ZodMiniType<Breakdown, unknown> = z
  .pipe(
    z.object({
      id: z._default(types.string(), ""),
      plan_id: types.nullable(types.string()),
      included_grant: types.number(),
      prepaid_grant: types.number(),
      remaining: types.number(),
      usage: types.number(),
      unlimited: types.boolean(),
      reset: types.nullable(z.lazy(() => BalanceReset$inboundSchema)),
      price: types.nullable(z.lazy(() => BalancePrice$inboundSchema)),
      expires_at: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "plan_id": "planId",
        "included_grant": "includedGrant",
        "prepaid_grant": "prepaidGrant",
        "expires_at": "expiresAt",
      });
    }),
  );

export function breakdownFromJSON(
  jsonString: string,
): SafeParseResult<Breakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Breakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Breakdown' from JSON`,
  );
}

/** @internal */
export const BalanceRollover$inboundSchema: z.ZodMiniType<
  BalanceRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function balanceRolloverFromJSON(
  jsonString: string,
): SafeParseResult<BalanceRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceRollover' from JSON`,
  );
}

/** @internal */
export const Balance$inboundSchema: z.ZodMiniType<Balance, unknown> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => BalanceFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(z.array(z.lazy(() => Breakdown$inboundSchema))),
    rollovers: types.optional(z.array(z.lazy(() =>
      BalanceRollover$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function balanceFromJSON(
  jsonString: string,
): SafeParseResult<Balance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Balance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Balance' from JSON`,
  );
}
