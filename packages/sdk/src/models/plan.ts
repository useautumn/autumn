/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const PlanPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type PlanPriceInterval = OpenEnum<typeof PlanPriceInterval>;

/**
 * Display text for showing this price in pricing pages.
 */
export type PlanPriceDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

export type PlanPrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: PlanPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Display text for showing this price in pricing pages.
   */
  display?: PlanPriceDisplay | undefined;
};

/**
 * The type of the feature
 */
export const PlanType = {
  Static: "static",
  Boolean: "boolean",
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature
 */
export type PlanType = OpenEnum<typeof PlanType>;

export type PlanFeatureDisplay = {
  /**
   * The singular display name for the feature.
   */
  singular: string;
  /**
   * The plural display name for the feature.
   */
  plural: string;
};

export type PlanCreditSchema = {
  /**
   * The ID of the metered feature (should be a single_use feature).
   */
  meteredFeatureId: string;
  /**
   * The credit cost of the metered feature.
   */
  creditCost: number;
};

/**
 * The full feature object if expanded.
 */
export type PlanFeature = {
  /**
   * The ID of the feature, used to refer to it in other API calls like /track or /check.
   */
  id: string;
  /**
   * The name of the feature.
   */
  name?: string | null | undefined;
  /**
   * The type of the feature
   */
  type: PlanType;
  /**
   * Singular and plural display names for the feature.
   */
  display?: PlanFeatureDisplay | null | undefined;
  /**
   * Credit cost schema for credit system features.
   */
  creditSchema?: Array<PlanCreditSchema> | null | undefined;
  /**
   * Whether or not the feature is archived.
   */
  archived?: boolean | null | undefined;
};

/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export const PlanResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export type PlanResetInterval = OpenEnum<typeof PlanResetInterval>;

export type PlanReset = {
  /**
   * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
   */
  interval: PlanResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type PlanTo = number | string;

export type PlanTier = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export const PlanPriceItemInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export type PlanPriceItemInterval = OpenEnum<typeof PlanPriceItemInterval>;

/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export const PlanBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export type PlanBillingMethod = OpenEnum<typeof PlanBillingMethod>;

export type PlanItemPrice = {
  /**
   * Price per billing_units after included usage is consumed. Mutually exclusive with tiers.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required.
   */
  tiers?: Array<PlanTier> | undefined;
  /**
   * Billing interval for this price. For consumable features, should match reset.interval.
   */
  interval: PlanPriceItemInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200).
   */
  billingUnits: number;
  /**
   * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
   */
  billingMethod: PlanBillingMethod;
  /**
   * Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit.
   */
  maxPurchase: number | null;
};

/**
 * Display text for showing this item in pricing pages.
 */
export type PlanItemDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

/**
 * When rolled over units expire.
 */
export const ExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type ExpiryDurationType = OpenEnum<typeof ExpiryDurationType>;

/**
 * Rollover configuration for unused units. If set, unused included units roll over to the next period.
 */
export type PlanRollover = {
  /**
   * Maximum rollover units. Null for unlimited rollover.
   */
  max: number | null;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: ExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

export type Item = {
  /**
   * The ID of the feature this item configures.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: PlanFeature | undefined;
  /**
   * Number of free units included. For consumable features, balance resets to this number each interval.
   */
  included: number;
  /**
   * Whether the customer has unlimited access to this feature.
   */
  unlimited: boolean;
  /**
   * Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles.
   */
  reset: PlanReset | null;
  /**
   * Pricing configuration for usage beyond included units. Null if feature is entirely free.
   */
  price: PlanItemPrice | null;
  /**
   * Display text for showing this item in pricing pages.
   */
  display?: PlanItemDisplay | undefined;
  /**
   * Rollover configuration for unused units. If set, unused included units roll over to the next period.
   */
  rollover?: PlanRollover | undefined;
};

/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export const PlanDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export type PlanDurationType = OpenEnum<typeof PlanDurationType>;

/**
 * Free trial configuration. If set, new customers can try this plan before being charged.
 */
export type FreeTrial = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial duration ('day', 'month', 'year').
   */
  durationType: PlanDurationType;
  /**
   * Whether a payment method is required to start the trial. If true, customer will be charged after trial ends.
   */
  cardRequired: boolean;
};

/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export const PlanEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export type PlanEnv = OpenEnum<typeof PlanEnv>;

export type Plan = {
  /**
   * Unique identifier for the plan.
   */
  id: string;
  /**
   * Display name of the plan.
   */
  name: string;
  /**
   * Optional description of the plan.
   */
  description: string | null;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group: string | null;
  /**
   * Version number of the plan. Incremented when plan configuration changes.
   */
  version: number;
  /**
   * Whether this is an add-on plan that can be attached alongside a main plan.
   */
  addOn: boolean;
  /**
   * If true, this plan is automatically attached when a customer is created. Used for free plans.
   */
  autoEnable: boolean;
  /**
   * Base recurring price for the plan. Null for free plans or usage-only plans.
   */
  price: PlanPrice | null;
  /**
   * Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature.
   */
  items: Array<Item>;
  /**
   * Free trial configuration. If set, new customers can try this plan before being charged.
   */
  freeTrial?: FreeTrial | undefined;
  /**
   * Unix timestamp (ms) when the plan was created.
   */
  createdAt: number;
  /**
   * Environment this plan belongs to ('sandbox' or 'live').
   */
  env: PlanEnv;
  /**
   * Whether the plan is archived. Archived plans cannot be attached to new customers.
   */
  archived: boolean;
  /**
   * If this is a variant, the ID of the base plan it was created from.
   */
  baseVariantId: string | null;
};

/** @internal */
export const PlanPriceInterval$inboundSchema: z.ZodMiniType<
  PlanPriceInterval,
  unknown
> = openEnums.inboundSchema(PlanPriceInterval);

/** @internal */
export const PlanPriceDisplay$inboundSchema: z.ZodMiniType<
  PlanPriceDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function planPriceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<PlanPriceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanPriceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanPriceDisplay' from JSON`,
  );
}

/** @internal */
export const PlanPrice$inboundSchema: z.ZodMiniType<PlanPrice, unknown> = z
  .pipe(
    z.object({
      amount: types.number(),
      interval: PlanPriceInterval$inboundSchema,
      interval_count: types.optional(types.number()),
      display: types.optional(z.lazy(() => PlanPriceDisplay$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function planPriceFromJSON(
  jsonString: string,
): SafeParseResult<PlanPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanPrice' from JSON`,
  );
}

/** @internal */
export const PlanType$inboundSchema: z.ZodMiniType<PlanType, unknown> =
  openEnums.inboundSchema(PlanType);

/** @internal */
export const PlanFeatureDisplay$inboundSchema: z.ZodMiniType<
  PlanFeatureDisplay,
  unknown
> = z.object({
  singular: types.string(),
  plural: types.string(),
});

export function planFeatureDisplayFromJSON(
  jsonString: string,
): SafeParseResult<PlanFeatureDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanFeatureDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanFeatureDisplay' from JSON`,
  );
}

/** @internal */
export const PlanCreditSchema$inboundSchema: z.ZodMiniType<
  PlanCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function planCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<PlanCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanCreditSchema' from JSON`,
  );
}

/** @internal */
export const PlanFeature$inboundSchema: z.ZodMiniType<PlanFeature, unknown> = z
  .pipe(
    z.object({
      id: types.string(),
      name: z.optional(z.nullable(types.string())),
      type: PlanType$inboundSchema,
      display: z.optional(
        z.nullable(z.lazy(() => PlanFeatureDisplay$inboundSchema)),
      ),
      credit_schema: z.optional(
        z.nullable(z.array(z.lazy(() => PlanCreditSchema$inboundSchema))),
      ),
      archived: z.optional(z.nullable(types.boolean())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "credit_schema": "creditSchema",
      });
    }),
  );

export function planFeatureFromJSON(
  jsonString: string,
): SafeParseResult<PlanFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanFeature' from JSON`,
  );
}

/** @internal */
export const PlanResetInterval$inboundSchema: z.ZodMiniType<
  PlanResetInterval,
  unknown
> = openEnums.inboundSchema(PlanResetInterval);

/** @internal */
export const PlanReset$inboundSchema: z.ZodMiniType<PlanReset, unknown> = z
  .pipe(
    z.object({
      interval: PlanResetInterval$inboundSchema,
      interval_count: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function planResetFromJSON(
  jsonString: string,
): SafeParseResult<PlanReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanReset' from JSON`,
  );
}

/** @internal */
export const PlanTo$inboundSchema: z.ZodMiniType<PlanTo, unknown> = smartUnion([
  types.number(),
  types.string(),
]);

export function planToFromJSON(
  jsonString: string,
): SafeParseResult<PlanTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanTo' from JSON`,
  );
}

/** @internal */
export const PlanTier$inboundSchema: z.ZodMiniType<PlanTier, unknown> = z
  .object({
    to: smartUnion([types.number(), types.string()]),
    amount: types.number(),
  });

export function planTierFromJSON(
  jsonString: string,
): SafeParseResult<PlanTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanTier' from JSON`,
  );
}

/** @internal */
export const PlanPriceItemInterval$inboundSchema: z.ZodMiniType<
  PlanPriceItemInterval,
  unknown
> = openEnums.inboundSchema(PlanPriceItemInterval);

/** @internal */
export const PlanBillingMethod$inboundSchema: z.ZodMiniType<
  PlanBillingMethod,
  unknown
> = openEnums.inboundSchema(PlanBillingMethod);

/** @internal */
export const PlanItemPrice$inboundSchema: z.ZodMiniType<
  PlanItemPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(z.array(z.lazy(() => PlanTier$inboundSchema))),
    interval: PlanPriceItemInterval$inboundSchema,
    interval_count: types.optional(types.number()),
    billing_units: types.number(),
    billing_method: PlanBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function planItemPriceFromJSON(
  jsonString: string,
): SafeParseResult<PlanItemPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanItemPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanItemPrice' from JSON`,
  );
}

/** @internal */
export const PlanItemDisplay$inboundSchema: z.ZodMiniType<
  PlanItemDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function planItemDisplayFromJSON(
  jsonString: string,
): SafeParseResult<PlanItemDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanItemDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanItemDisplay' from JSON`,
  );
}

/** @internal */
export const ExpiryDurationType$inboundSchema: z.ZodMiniType<
  ExpiryDurationType,
  unknown
> = openEnums.inboundSchema(ExpiryDurationType);

/** @internal */
export const PlanRollover$inboundSchema: z.ZodMiniType<PlanRollover, unknown> =
  z.pipe(
    z.object({
      max: types.nullable(types.number()),
      expiry_duration_type: ExpiryDurationType$inboundSchema,
      expiry_duration_length: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "expiry_duration_type": "expiryDurationType",
        "expiry_duration_length": "expiryDurationLength",
      });
    }),
  );

export function planRolloverFromJSON(
  jsonString: string,
): SafeParseResult<PlanRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanRollover' from JSON`,
  );
}

/** @internal */
export const Item$inboundSchema: z.ZodMiniType<Item, unknown> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => PlanFeature$inboundSchema)),
    included: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => PlanReset$inboundSchema)),
    price: types.nullable(z.lazy(() => PlanItemPrice$inboundSchema)),
    display: types.optional(z.lazy(() => PlanItemDisplay$inboundSchema)),
    rollover: types.optional(z.lazy(() => PlanRollover$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function itemFromJSON(
  jsonString: string,
): SafeParseResult<Item, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Item$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Item' from JSON`,
  );
}

/** @internal */
export const PlanDurationType$inboundSchema: z.ZodMiniType<
  PlanDurationType,
  unknown
> = openEnums.inboundSchema(PlanDurationType);

/** @internal */
export const FreeTrial$inboundSchema: z.ZodMiniType<FreeTrial, unknown> = z
  .pipe(
    z.object({
      duration_length: types.number(),
      duration_type: PlanDurationType$inboundSchema,
      card_required: types.boolean(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "duration_length": "durationLength",
        "duration_type": "durationType",
        "card_required": "cardRequired",
      });
    }),
  );

export function freeTrialFromJSON(
  jsonString: string,
): SafeParseResult<FreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FreeTrial' from JSON`,
  );
}

/** @internal */
export const PlanEnv$inboundSchema: z.ZodMiniType<PlanEnv, unknown> = openEnums
  .inboundSchema(PlanEnv);

/** @internal */
export const Plan$inboundSchema: z.ZodMiniType<Plan, unknown> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    description: types.nullable(types.string()),
    group: types.nullable(types.string()),
    version: types.number(),
    add_on: types.boolean(),
    auto_enable: types.boolean(),
    price: types.nullable(z.lazy(() => PlanPrice$inboundSchema)),
    items: z.array(z.lazy(() => Item$inboundSchema)),
    free_trial: types.optional(z.lazy(() => FreeTrial$inboundSchema)),
    created_at: types.number(),
    env: PlanEnv$inboundSchema,
    archived: types.boolean(),
    base_variant_id: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "add_on": "addOn",
      "auto_enable": "autoEnable",
      "free_trial": "freeTrial",
      "created_at": "createdAt",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function planFromJSON(
  jsonString: string,
): SafeParseResult<Plan, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Plan$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Plan' from JSON`,
  );
}
