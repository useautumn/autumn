/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export const PriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PriceInterval = OpenEnum<typeof PriceInterval>;

export type PlanPrice = {
  amount: number;
  interval: PriceInterval;
  intervalCount?: number | undefined;
};

export const PlanResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PlanResetInterval = OpenEnum<typeof PlanResetInterval>;

export type PlanReset = {
  interval: PlanResetInterval;
  intervalCount?: number | undefined;
};

export type PlanTo = number | string;

export type PlanTier = {
  to: number | string;
  amount: number;
};

export const PriceItemInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PriceItemInterval = OpenEnum<typeof PriceItemInterval>;

export const PlanBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type PlanBillingMethod = OpenEnum<typeof PlanBillingMethod>;

export type ItemPrice = {
  amount?: number | undefined;
  tiers?: Array<PlanTier> | undefined;
  interval: PriceItemInterval;
  intervalCount?: number | undefined;
  billingUnits: number;
  billingMethod: PlanBillingMethod;
  maxPurchase: number | null;
};

export const ExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type ExpiryDurationType = OpenEnum<typeof ExpiryDurationType>;

export type PlanRollover = {
  max: number | null;
  expiryDurationType: ExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export const OnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type OnIncrease = OpenEnum<typeof OnIncrease>;

export const OnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type OnDecrease = OpenEnum<typeof OnDecrease>;

export type Proration = {
  onIncrease?: OnIncrease | undefined;
  onDecrease?: OnDecrease | undefined;
};

export type Item = {
  featureId: string;
  included: number;
  unlimited: boolean;
  reset: PlanReset | null;
  price: ItemPrice | null;
  rollover?: PlanRollover | undefined;
  proration?: Proration | undefined;
};

export const PlanDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type PlanDurationType = OpenEnum<typeof PlanDurationType>;

export type FreeTrial = {
  durationLength: number;
  durationType: PlanDurationType;
  cardRequired: boolean;
};

export const PlanEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
export type PlanEnv = OpenEnum<typeof PlanEnv>;

export const Scenario = {
  Scheduled: "scheduled",
  Active: "active",
  New: "new",
  Renew: "renew",
  Upgrade: "upgrade",
  Downgrade: "downgrade",
  Cancel: "cancel",
  Expired: "expired",
  PastDue: "past_due",
} as const;
export type Scenario = OpenEnum<typeof Scenario>;

export type CustomerEligibility = {
  trialAvailable?: boolean | undefined;
  scenario: Scenario;
};

export type Plan = {
  name: string;
  description: string | null;
  group: string | null;
  version: number;
  addOn: boolean;
  autoEnable: boolean;
  price: PlanPrice | null;
  items: Array<Item>;
  freeTrial?: FreeTrial | undefined;
  env: PlanEnv;
  archived: boolean;
  baseVariantId: string | null;
  customerEligibility?: CustomerEligibility | undefined;
};

/** @internal */
export const PriceInterval$inboundSchema: z.ZodMiniType<
  PriceInterval,
  unknown
> = openEnums.inboundSchema(PriceInterval);

/** @internal */
export const PlanPrice$inboundSchema: z.ZodMiniType<PlanPrice, unknown> = z
  .pipe(
    z.object({
      amount: types.number(),
      interval: PriceInterval$inboundSchema,
      interval_count: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function planPriceFromJSON(
  jsonString: string,
): SafeParseResult<PlanPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanPrice' from JSON`,
  );
}

/** @internal */
export const PlanResetInterval$inboundSchema: z.ZodMiniType<
  PlanResetInterval,
  unknown
> = openEnums.inboundSchema(PlanResetInterval);

/** @internal */
export const PlanReset$inboundSchema: z.ZodMiniType<PlanReset, unknown> = z
  .pipe(
    z.object({
      interval: PlanResetInterval$inboundSchema,
      interval_count: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function planResetFromJSON(
  jsonString: string,
): SafeParseResult<PlanReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanReset' from JSON`,
  );
}

/** @internal */
export const PlanTo$inboundSchema: z.ZodMiniType<PlanTo, unknown> = smartUnion([
  types.number(),
  types.string(),
]);

export function planToFromJSON(
  jsonString: string,
): SafeParseResult<PlanTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanTo' from JSON`,
  );
}

/** @internal */
export const PlanTier$inboundSchema: z.ZodMiniType<PlanTier, unknown> = z
  .object({
    to: smartUnion([types.number(), types.string()]),
    amount: types.number(),
  });

export function planTierFromJSON(
  jsonString: string,
): SafeParseResult<PlanTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanTier' from JSON`,
  );
}

/** @internal */
export const PriceItemInterval$inboundSchema: z.ZodMiniType<
  PriceItemInterval,
  unknown
> = openEnums.inboundSchema(PriceItemInterval);

/** @internal */
export const PlanBillingMethod$inboundSchema: z.ZodMiniType<
  PlanBillingMethod,
  unknown
> = openEnums.inboundSchema(PlanBillingMethod);

/** @internal */
export const ItemPrice$inboundSchema: z.ZodMiniType<ItemPrice, unknown> = z
  .pipe(
    z.object({
      amount: types.optional(types.number()),
      tiers: types.optional(z.array(z.lazy(() => PlanTier$inboundSchema))),
      interval: PriceItemInterval$inboundSchema,
      interval_count: types.optional(types.number()),
      billing_units: types.number(),
      billing_method: PlanBillingMethod$inboundSchema,
      max_purchase: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
        "billing_units": "billingUnits",
        "billing_method": "billingMethod",
        "max_purchase": "maxPurchase",
      });
    }),
  );

export function itemPriceFromJSON(
  jsonString: string,
): SafeParseResult<ItemPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ItemPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ItemPrice' from JSON`,
  );
}

/** @internal */
export const ExpiryDurationType$inboundSchema: z.ZodMiniType<
  ExpiryDurationType,
  unknown
> = openEnums.inboundSchema(ExpiryDurationType);

/** @internal */
export const PlanRollover$inboundSchema: z.ZodMiniType<PlanRollover, unknown> =
  z.pipe(
    z.object({
      max: types.nullable(types.number()),
      expiry_duration_type: ExpiryDurationType$inboundSchema,
      expiry_duration_length: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "expiry_duration_type": "expiryDurationType",
        "expiry_duration_length": "expiryDurationLength",
      });
    }),
  );

export function planRolloverFromJSON(
  jsonString: string,
): SafeParseResult<PlanRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanRollover' from JSON`,
  );
}

/** @internal */
export const OnIncrease$inboundSchema: z.ZodMiniType<OnIncrease, unknown> =
  openEnums.inboundSchema(OnIncrease);

/** @internal */
export const OnDecrease$inboundSchema: z.ZodMiniType<OnDecrease, unknown> =
  openEnums.inboundSchema(OnDecrease);

/** @internal */
export const Proration$inboundSchema: z.ZodMiniType<Proration, unknown> = z
  .pipe(
    z.object({
      on_increase: types.optional(OnIncrease$inboundSchema),
      on_decrease: types.optional(OnDecrease$inboundSchema),
    }),
    z.transform((v) => {
      return remap$(v, {
        "on_increase": "onIncrease",
        "on_decrease": "onDecrease",
      });
    }),
  );

export function prorationFromJSON(
  jsonString: string,
): SafeParseResult<Proration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Proration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Proration' from JSON`,
  );
}

/** @internal */
export const Item$inboundSchema: z.ZodMiniType<Item, unknown> = z.pipe(
  z.object({
    feature_id: types.string(),
    included: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => PlanReset$inboundSchema)),
    price: types.nullable(z.lazy(() => ItemPrice$inboundSchema)),
    rollover: types.optional(z.lazy(() => PlanRollover$inboundSchema)),
    proration: types.optional(z.lazy(() => Proration$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function itemFromJSON(
  jsonString: string,
): SafeParseResult<Item, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Item$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Item' from JSON`,
  );
}

/** @internal */
export const PlanDurationType$inboundSchema: z.ZodMiniType<
  PlanDurationType,
  unknown
> = openEnums.inboundSchema(PlanDurationType);

/** @internal */
export const FreeTrial$inboundSchema: z.ZodMiniType<FreeTrial, unknown> = z
  .pipe(
    z.object({
      duration_length: types.number(),
      duration_type: PlanDurationType$inboundSchema,
      card_required: types.boolean(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "duration_length": "durationLength",
        "duration_type": "durationType",
        "card_required": "cardRequired",
      });
    }),
  );

export function freeTrialFromJSON(
  jsonString: string,
): SafeParseResult<FreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FreeTrial' from JSON`,
  );
}

/** @internal */
export const PlanEnv$inboundSchema: z.ZodMiniType<PlanEnv, unknown> = openEnums
  .inboundSchema(PlanEnv);

/** @internal */
export const Scenario$inboundSchema: z.ZodMiniType<Scenario, unknown> =
  openEnums.inboundSchema(Scenario);

/** @internal */
export const CustomerEligibility$inboundSchema: z.ZodMiniType<
  CustomerEligibility,
  unknown
> = z.pipe(
  z.object({
    trial_available: types.optional(types.boolean()),
    scenario: Scenario$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "trial_available": "trialAvailable",
    });
  }),
);

export function customerEligibilityFromJSON(
  jsonString: string,
): SafeParseResult<CustomerEligibility, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerEligibility$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerEligibility' from JSON`,
  );
}

/** @internal */
export const Plan$inboundSchema: z.ZodMiniType<Plan, unknown> = z.pipe(
  z.object({
    name: types.string(),
    description: types.nullable(types.string()),
    group: types.nullable(types.string()),
    version: types.number(),
    add_on: types.boolean(),
    auto_enable: types.boolean(),
    price: types.nullable(z.lazy(() => PlanPrice$inboundSchema)),
    items: z.array(z.lazy(() => Item$inboundSchema)),
    free_trial: types.optional(z.lazy(() => FreeTrial$inboundSchema)),
    env: PlanEnv$inboundSchema,
    archived: types.boolean(),
    base_variant_id: types.nullable(types.string()),
    customer_eligibility: types.optional(z.lazy(() =>
      CustomerEligibility$inboundSchema
    )),
  }),
  z.transform((v) => {
    return remap$(v, {
      "add_on": "addOn",
      "auto_enable": "autoEnable",
      "free_trial": "freeTrial",
      "base_variant_id": "baseVariantId",
      "customer_eligibility": "customerEligibility",
    });
  }),
);

export function planFromJSON(
  jsonString: string,
): SafeParseResult<Plan, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Plan$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Plan' from JSON`,
  );
}
