/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type GetPlanGlobals = {
  xApiVersion?: string | undefined;
};

export type GetPlanParams = {
  /**
   * The ID of the plan to retrieve.
   */
  planId: string;
  /**
   * The version of the plan to get. Defaults to the latest version.
   */
  version?: number | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const GetPlanPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type GetPlanPriceInterval = OpenEnum<typeof GetPlanPriceInterval>;

/**
 * Display text for showing this price in pricing pages.
 */
export type GetPlanPriceDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

export type GetPlanPrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: GetPlanPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Display text for showing this price in pricing pages.
   */
  display?: GetPlanPriceDisplay | undefined;
};

/**
 * The type of the feature
 */
export const GetPlanType = {
  Static: "static",
  Boolean: "boolean",
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature
 */
export type GetPlanType = OpenEnum<typeof GetPlanType>;

export type GetPlanFeatureDisplay = {
  /**
   * The singular display name for the feature.
   */
  singular: string;
  /**
   * The plural display name for the feature.
   */
  plural: string;
};

export type GetPlanCreditSchema = {
  /**
   * The ID of the metered feature (should be a single_use feature).
   */
  meteredFeatureId: string;
  /**
   * The credit cost of the metered feature.
   */
  creditCost: number;
};

/**
 * The full feature object if expanded.
 */
export type GetPlanFeature = {
  /**
   * The ID of the feature, used to refer to it in other API calls like /track or /check.
   */
  id: string;
  /**
   * The name of the feature.
   */
  name?: string | null | undefined;
  /**
   * The type of the feature
   */
  type: GetPlanType;
  /**
   * Singular and plural display names for the feature.
   */
  display?: GetPlanFeatureDisplay | null | undefined;
  /**
   * Credit cost schema for credit system features.
   */
  creditSchema?: Array<GetPlanCreditSchema> | null | undefined;
  /**
   * Whether or not the feature is archived.
   */
  archived?: boolean | null | undefined;
};

/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export const GetPlanResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export type GetPlanResetInterval = OpenEnum<typeof GetPlanResetInterval>;

export type GetPlanReset = {
  /**
   * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
   */
  interval: GetPlanResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type GetPlanTo = number | string;

export type GetPlanTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const GetPlanTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type GetPlanTierBehavior = OpenEnum<typeof GetPlanTierBehavior>;

/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export const GetPlanPriceItemInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export type GetPlanPriceItemInterval = OpenEnum<
  typeof GetPlanPriceItemInterval
>;

/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export const GetPlanBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export type GetPlanBillingMethod = OpenEnum<typeof GetPlanBillingMethod>;

export type GetPlanItemPrice = {
  /**
   * Price per billing_units after included usage is consumed. Mutually exclusive with tiers.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration. Each tier's 'to' INCLUDES the included amount. Either 'tiers' or 'amount' is required.
   */
  tiers?: Array<GetPlanTier> | undefined;
  tierBehavior?: GetPlanTierBehavior | undefined;
  /**
   * Billing interval for this price. For consumable features, should match reset.interval.
   */
  interval: GetPlanPriceItemInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200).
   */
  billingUnits: number;
  /**
   * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
   */
  billingMethod: GetPlanBillingMethod;
  /**
   * Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit.
   */
  maxPurchase: number | null;
};

/**
 * Display text for showing this item in pricing pages.
 */
export type GetPlanItemDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

/**
 * When rolled over units expire.
 */
export const GetPlanExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type GetPlanExpiryDurationType = OpenEnum<
  typeof GetPlanExpiryDurationType
>;

/**
 * Rollover configuration for unused units. If set, unused included units roll over to the next period.
 */
export type GetPlanRollover = {
  /**
   * Maximum rollover units. Null for unlimited rollover.
   */
  max: number | null;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: GetPlanExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

export type GetPlanItem = {
  /**
   * The ID of the feature this item configures.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: GetPlanFeature | undefined;
  /**
   * Number of free units included. For consumable features, balance resets to this number each interval.
   */
  included: number;
  /**
   * Whether the customer has unlimited access to this feature.
   */
  unlimited: boolean;
  /**
   * Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles.
   */
  reset: GetPlanReset | null;
  /**
   * Pricing configuration for usage beyond included units. Null if feature is entirely free.
   */
  price: GetPlanItemPrice | null;
  /**
   * Display text for showing this item in pricing pages.
   */
  display?: GetPlanItemDisplay | undefined;
  /**
   * Rollover configuration for unused units. If set, unused included units roll over to the next period.
   */
  rollover?: GetPlanRollover | undefined;
};

/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export const GetPlanDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export type GetPlanDurationType = OpenEnum<typeof GetPlanDurationType>;

/**
 * Free trial configuration. If set, new customers can try this plan before being charged.
 */
export type GetPlanFreeTrial = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial duration ('day', 'month', 'year').
   */
  durationType: GetPlanDurationType;
  /**
   * Whether a payment method is required to start the trial. If true, customer will be charged after trial ends.
   */
  cardRequired: boolean;
};

/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export const GetPlanEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export type GetPlanEnv = OpenEnum<typeof GetPlanEnv>;

/**
 * The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade).
 */
export const GetPlanScenario = {
  Scheduled: "scheduled",
  Active: "active",
  New: "new",
  Renew: "renew",
  Upgrade: "upgrade",
  Downgrade: "downgrade",
  Cancel: "cancel",
  Expired: "expired",
  PastDue: "past_due",
} as const;
/**
 * The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade).
 */
export type GetPlanScenario = OpenEnum<typeof GetPlanScenario>;

export type GetPlanCustomerEligibility = {
  /**
   * Whether a free trial is available for this customer.
   */
  trialAvailable?: boolean | undefined;
  /**
   * The attach scenario for this customer (e.g. new_subscription, upgrade, downgrade).
   */
  scenario: GetPlanScenario;
};

/**
 * A plan defines a set of features, pricing, and entitlements that can be attached to customers.
 */
export type GetPlanResponse = {
  /**
   * Unique identifier for the plan.
   */
  id: string;
  /**
   * Display name of the plan.
   */
  name: string;
  /**
   * Optional description of the plan.
   */
  description: string | null;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group: string | null;
  /**
   * Version number of the plan. Incremented when plan configuration changes.
   */
  version: number;
  /**
   * Whether this is an add-on plan that can be attached alongside a main plan.
   */
  addOn: boolean;
  /**
   * If true, this plan is automatically attached when a customer is created. Used for free plans.
   */
  autoEnable: boolean;
  /**
   * Base recurring price for the plan. Null for free plans or usage-only plans.
   */
  price: GetPlanPrice | null;
  /**
   * Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature.
   */
  items: Array<GetPlanItem>;
  /**
   * Free trial configuration. If set, new customers can try this plan before being charged.
   */
  freeTrial?: GetPlanFreeTrial | undefined;
  /**
   * Unix timestamp (ms) when the plan was created.
   */
  createdAt: number;
  /**
   * Environment this plan belongs to ('sandbox' or 'live').
   */
  env: GetPlanEnv;
  /**
   * Whether the plan is archived. Archived plans cannot be attached to new customers.
   */
  archived: boolean;
  /**
   * If this is a variant, the ID of the base plan it was created from.
   */
  baseVariantId: string | null;
  customerEligibility?: GetPlanCustomerEligibility | undefined;
};

/** @internal */
export type GetPlanParams$Outbound = {
  plan_id: string;
  version?: number | undefined;
};

/** @internal */
export const GetPlanParams$outboundSchema: z.ZodMiniType<
  GetPlanParams$Outbound,
  GetPlanParams
> = z.pipe(
  z.object({
    planId: z.string(),
    version: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      planId: "plan_id",
    });
  }),
);

export function getPlanParamsToJSON(getPlanParams: GetPlanParams): string {
  return JSON.stringify(GetPlanParams$outboundSchema.parse(getPlanParams));
}

/** @internal */
export const GetPlanPriceInterval$inboundSchema: z.ZodMiniType<
  GetPlanPriceInterval,
  unknown
> = openEnums.inboundSchema(GetPlanPriceInterval);

/** @internal */
export const GetPlanPriceDisplay$inboundSchema: z.ZodMiniType<
  GetPlanPriceDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function getPlanPriceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanPriceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanPriceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanPriceDisplay' from JSON`,
  );
}

/** @internal */
export const GetPlanPrice$inboundSchema: z.ZodMiniType<GetPlanPrice, unknown> =
  z.pipe(
    z.object({
      amount: types.number(),
      interval: GetPlanPriceInterval$inboundSchema,
      interval_count: types.optional(types.number()),
      display: types.optional(z.lazy(() => GetPlanPriceDisplay$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function getPlanPriceFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanPrice' from JSON`,
  );
}

/** @internal */
export const GetPlanType$inboundSchema: z.ZodMiniType<GetPlanType, unknown> =
  openEnums.inboundSchema(GetPlanType);

/** @internal */
export const GetPlanFeatureDisplay$inboundSchema: z.ZodMiniType<
  GetPlanFeatureDisplay,
  unknown
> = z.object({
  singular: types.string(),
  plural: types.string(),
});

export function getPlanFeatureDisplayFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanFeatureDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanFeatureDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanFeatureDisplay' from JSON`,
  );
}

/** @internal */
export const GetPlanCreditSchema$inboundSchema: z.ZodMiniType<
  GetPlanCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function getPlanCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanCreditSchema' from JSON`,
  );
}

/** @internal */
export const GetPlanFeature$inboundSchema: z.ZodMiniType<
  GetPlanFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: z.optional(z.nullable(types.string())),
    type: GetPlanType$inboundSchema,
    display: z.optional(
      z.nullable(z.lazy(() => GetPlanFeatureDisplay$inboundSchema)),
    ),
    credit_schema: z.optional(
      z.nullable(z.array(z.lazy(() => GetPlanCreditSchema$inboundSchema))),
    ),
    archived: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "credit_schema": "creditSchema",
    });
  }),
);

export function getPlanFeatureFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanFeature' from JSON`,
  );
}

/** @internal */
export const GetPlanResetInterval$inboundSchema: z.ZodMiniType<
  GetPlanResetInterval,
  unknown
> = openEnums.inboundSchema(GetPlanResetInterval);

/** @internal */
export const GetPlanReset$inboundSchema: z.ZodMiniType<GetPlanReset, unknown> =
  z.pipe(
    z.object({
      interval: GetPlanResetInterval$inboundSchema,
      interval_count: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "interval_count": "intervalCount",
      });
    }),
  );

export function getPlanResetFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanReset' from JSON`,
  );
}

/** @internal */
export const GetPlanTo$inboundSchema: z.ZodMiniType<GetPlanTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function getPlanToFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanTo' from JSON`,
  );
}

/** @internal */
export const GetPlanTier$inboundSchema: z.ZodMiniType<GetPlanTier, unknown> = z
  .pipe(
    z.object({
      to: smartUnion([types.number(), types.string()]),
      amount: types.number(),
      flat_amount: z.optional(z.nullable(types.number())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "flat_amount": "flatAmount",
      });
    }),
  );

export function getPlanTierFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanTier' from JSON`,
  );
}

/** @internal */
export const GetPlanTierBehavior$inboundSchema: z.ZodMiniType<
  GetPlanTierBehavior,
  unknown
> = openEnums.inboundSchema(GetPlanTierBehavior);

/** @internal */
export const GetPlanPriceItemInterval$inboundSchema: z.ZodMiniType<
  GetPlanPriceItemInterval,
  unknown
> = openEnums.inboundSchema(GetPlanPriceItemInterval);

/** @internal */
export const GetPlanBillingMethod$inboundSchema: z.ZodMiniType<
  GetPlanBillingMethod,
  unknown
> = openEnums.inboundSchema(GetPlanBillingMethod);

/** @internal */
export const GetPlanItemPrice$inboundSchema: z.ZodMiniType<
  GetPlanItemPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(z.array(z.lazy(() => GetPlanTier$inboundSchema))),
    tier_behavior: types.optional(GetPlanTierBehavior$inboundSchema),
    interval: GetPlanPriceItemInterval$inboundSchema,
    interval_count: types.optional(types.number()),
    billing_units: types.number(),
    billing_method: GetPlanBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tier_behavior": "tierBehavior",
      "interval_count": "intervalCount",
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function getPlanItemPriceFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanItemPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanItemPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanItemPrice' from JSON`,
  );
}

/** @internal */
export const GetPlanItemDisplay$inboundSchema: z.ZodMiniType<
  GetPlanItemDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function getPlanItemDisplayFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanItemDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanItemDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanItemDisplay' from JSON`,
  );
}

/** @internal */
export const GetPlanExpiryDurationType$inboundSchema: z.ZodMiniType<
  GetPlanExpiryDurationType,
  unknown
> = openEnums.inboundSchema(GetPlanExpiryDurationType);

/** @internal */
export const GetPlanRollover$inboundSchema: z.ZodMiniType<
  GetPlanRollover,
  unknown
> = z.pipe(
  z.object({
    max: types.nullable(types.number()),
    expiry_duration_type: GetPlanExpiryDurationType$inboundSchema,
    expiry_duration_length: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expiry_duration_type": "expiryDurationType",
      "expiry_duration_length": "expiryDurationLength",
    });
  }),
);

export function getPlanRolloverFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanRollover' from JSON`,
  );
}

/** @internal */
export const GetPlanItem$inboundSchema: z.ZodMiniType<GetPlanItem, unknown> = z
  .pipe(
    z.object({
      feature_id: types.string(),
      feature: types.optional(z.lazy(() => GetPlanFeature$inboundSchema)),
      included: types.number(),
      unlimited: types.boolean(),
      reset: types.nullable(z.lazy(() => GetPlanReset$inboundSchema)),
      price: types.nullable(z.lazy(() => GetPlanItemPrice$inboundSchema)),
      display: types.optional(z.lazy(() => GetPlanItemDisplay$inboundSchema)),
      rollover: types.optional(z.lazy(() => GetPlanRollover$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "feature_id": "featureId",
      });
    }),
  );

export function getPlanItemFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanItem' from JSON`,
  );
}

/** @internal */
export const GetPlanDurationType$inboundSchema: z.ZodMiniType<
  GetPlanDurationType,
  unknown
> = openEnums.inboundSchema(GetPlanDurationType);

/** @internal */
export const GetPlanFreeTrial$inboundSchema: z.ZodMiniType<
  GetPlanFreeTrial,
  unknown
> = z.pipe(
  z.object({
    duration_length: types.number(),
    duration_type: GetPlanDurationType$inboundSchema,
    card_required: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "duration_length": "durationLength",
      "duration_type": "durationType",
      "card_required": "cardRequired",
    });
  }),
);

export function getPlanFreeTrialFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanFreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanFreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanFreeTrial' from JSON`,
  );
}

/** @internal */
export const GetPlanEnv$inboundSchema: z.ZodMiniType<GetPlanEnv, unknown> =
  openEnums.inboundSchema(GetPlanEnv);

/** @internal */
export const GetPlanScenario$inboundSchema: z.ZodMiniType<
  GetPlanScenario,
  unknown
> = openEnums.inboundSchema(GetPlanScenario);

/** @internal */
export const GetPlanCustomerEligibility$inboundSchema: z.ZodMiniType<
  GetPlanCustomerEligibility,
  unknown
> = z.pipe(
  z.object({
    trial_available: types.optional(types.boolean()),
    scenario: GetPlanScenario$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "trial_available": "trialAvailable",
    });
  }),
);

export function getPlanCustomerEligibilityFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanCustomerEligibility, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanCustomerEligibility$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanCustomerEligibility' from JSON`,
  );
}

/** @internal */
export const GetPlanResponse$inboundSchema: z.ZodMiniType<
  GetPlanResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    description: types.nullable(types.string()),
    group: types.nullable(types.string()),
    version: types.number(),
    add_on: types.boolean(),
    auto_enable: types.boolean(),
    price: types.nullable(z.lazy(() => GetPlanPrice$inboundSchema)),
    items: z.array(z.lazy(() => GetPlanItem$inboundSchema)),
    free_trial: types.optional(z.lazy(() => GetPlanFreeTrial$inboundSchema)),
    created_at: types.number(),
    env: GetPlanEnv$inboundSchema,
    archived: types.boolean(),
    base_variant_id: types.nullable(types.string()),
    customer_eligibility: types.optional(
      z.lazy(() => GetPlanCustomerEligibility$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "add_on": "addOn",
      "auto_enable": "autoEnable",
      "free_trial": "freeTrial",
      "created_at": "createdAt",
      "base_variant_id": "baseVariantId",
      "customer_eligibility": "customerEligibility",
    });
  }),
);

export function getPlanResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetPlanResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPlanResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPlanResponse' from JSON`,
  );
}
