/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type CreateFeatureGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
 */
export const CreateFeatureTypeRequest = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
 */
export type CreateFeatureTypeRequest = ClosedEnum<
  typeof CreateFeatureTypeRequest
>;

/**
 * Singular and plural display names for the feature in your user interface.
 */
export type CreateFeatureDisplayRequest = {
  singular: string;
  plural: string;
};

export type CreateFeatureCreditSchemaRequest = {
  meteredFeatureId: string;
  creditCost: number;
};

export type CreateFeatureParams = {
  /**
   * The name of the feature.
   */
  name: string;
  /**
   * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
   */
  type: CreateFeatureTypeRequest;
  /**
   * Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
   */
  consumable?: boolean | undefined;
  /**
   * Singular and plural display names for the feature in your user interface.
   */
  display?: CreateFeatureDisplayRequest | undefined;
  /**
   * A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
   */
  creditSchema?: Array<CreateFeatureCreditSchemaRequest> | undefined;
  eventNames?: Array<string> | undefined;
  /**
   * The ID of the feature to create.
   */
  featureId: string;
};

/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export const CreateFeatureTypeResponse = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export type CreateFeatureTypeResponse = OpenEnum<
  typeof CreateFeatureTypeResponse
>;

export type CreateFeatureCreditSchemaResponse = {
  /**
   * ID of the metered feature that draws from this credit system.
   */
  meteredFeatureId: string;
  /**
   * Credits consumed per unit of the metered feature.
   */
  creditCost: number;
};

/**
 * Display names for the feature in billing UI and customer-facing components.
 */
export type CreateFeatureDisplayResponse = {
  /**
   * Singular form for UI display (e.g., 'API call', 'seat').
   */
  singular?: string | null | undefined;
  /**
   * Plural form for UI display (e.g., 'API calls', 'seats').
   */
  plural?: string | null | undefined;
};

/**
 * OK
 */
export type CreateFeatureResponse = {
  /**
   * The unique identifier for this feature, used in /check and /track calls.
   */
  id: string;
  /**
   * Human-readable name displayed in the dashboard and billing UI.
   */
  name: string;
  /**
   * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
   */
  type: CreateFeatureTypeResponse;
  /**
   * For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage).
   */
  consumable: boolean;
  /**
   * Event names that trigger this feature's balance. Allows multiple features to respond to a single event.
   */
  eventNames?: Array<string> | undefined;
  /**
   * For credit_system features: maps metered features to their credit costs.
   */
  creditSchema?: Array<CreateFeatureCreditSchemaResponse> | undefined;
  /**
   * Display names for the feature in billing UI and customer-facing components.
   */
  display?: CreateFeatureDisplayResponse | undefined;
  /**
   * Whether the feature is archived and hidden from the dashboard.
   */
  archived: boolean;
};

/** @internal */
export const CreateFeatureTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreateFeatureTypeRequest
> = z.enum(CreateFeatureTypeRequest);

/** @internal */
export type CreateFeatureDisplayRequest$Outbound = {
  singular: string;
  plural: string;
};

/** @internal */
export const CreateFeatureDisplayRequest$outboundSchema: z.ZodMiniType<
  CreateFeatureDisplayRequest$Outbound,
  CreateFeatureDisplayRequest
> = z.object({
  singular: z.string(),
  plural: z.string(),
});

export function createFeatureDisplayRequestToJSON(
  createFeatureDisplayRequest: CreateFeatureDisplayRequest,
): string {
  return JSON.stringify(
    CreateFeatureDisplayRequest$outboundSchema.parse(
      createFeatureDisplayRequest,
    ),
  );
}

/** @internal */
export type CreateFeatureCreditSchemaRequest$Outbound = {
  metered_feature_id: string;
  credit_cost: number;
};

/** @internal */
export const CreateFeatureCreditSchemaRequest$outboundSchema: z.ZodMiniType<
  CreateFeatureCreditSchemaRequest$Outbound,
  CreateFeatureCreditSchemaRequest
> = z.pipe(
  z.object({
    meteredFeatureId: z.string(),
    creditCost: z.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      meteredFeatureId: "metered_feature_id",
      creditCost: "credit_cost",
    });
  }),
);

export function createFeatureCreditSchemaRequestToJSON(
  createFeatureCreditSchemaRequest: CreateFeatureCreditSchemaRequest,
): string {
  return JSON.stringify(
    CreateFeatureCreditSchemaRequest$outboundSchema.parse(
      createFeatureCreditSchemaRequest,
    ),
  );
}

/** @internal */
export type CreateFeatureParams$Outbound = {
  name: string;
  type: string;
  consumable?: boolean | undefined;
  display?: CreateFeatureDisplayRequest$Outbound | undefined;
  credit_schema?: Array<CreateFeatureCreditSchemaRequest$Outbound> | undefined;
  event_names?: Array<string> | undefined;
  feature_id: string;
};

/** @internal */
export const CreateFeatureParams$outboundSchema: z.ZodMiniType<
  CreateFeatureParams$Outbound,
  CreateFeatureParams
> = z.pipe(
  z.object({
    name: z.string(),
    type: CreateFeatureTypeRequest$outboundSchema,
    consumable: z.optional(z.boolean()),
    display: z.optional(
      z.lazy(() => CreateFeatureDisplayRequest$outboundSchema),
    ),
    creditSchema: z.optional(
      z.array(z.lazy(() => CreateFeatureCreditSchemaRequest$outboundSchema)),
    ),
    eventNames: z.optional(z.array(z.string())),
    featureId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      creditSchema: "credit_schema",
      eventNames: "event_names",
      featureId: "feature_id",
    });
  }),
);

export function createFeatureParamsToJSON(
  createFeatureParams: CreateFeatureParams,
): string {
  return JSON.stringify(
    CreateFeatureParams$outboundSchema.parse(createFeatureParams),
  );
}

/** @internal */
export const CreateFeatureTypeResponse$inboundSchema: z.ZodMiniType<
  CreateFeatureTypeResponse,
  unknown
> = openEnums.inboundSchema(CreateFeatureTypeResponse);

/** @internal */
export const CreateFeatureCreditSchemaResponse$inboundSchema: z.ZodMiniType<
  CreateFeatureCreditSchemaResponse,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function createFeatureCreditSchemaResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateFeatureCreditSchemaResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateFeatureCreditSchemaResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateFeatureCreditSchemaResponse' from JSON`,
  );
}

/** @internal */
export const CreateFeatureDisplayResponse$inboundSchema: z.ZodMiniType<
  CreateFeatureDisplayResponse,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function createFeatureDisplayResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateFeatureDisplayResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateFeatureDisplayResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateFeatureDisplayResponse' from JSON`,
  );
}

/** @internal */
export const CreateFeatureResponse$inboundSchema: z.ZodMiniType<
  CreateFeatureResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: CreateFeatureTypeResponse$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => CreateFeatureCreditSchemaResponse$inboundSchema)),
    ),
    display: types.optional(
      z.lazy(() => CreateFeatureDisplayResponse$inboundSchema),
    ),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function createFeatureResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateFeatureResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateFeatureResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateFeatureResponse' from JSON`,
  );
}
