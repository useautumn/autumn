/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type AggregateEventsGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Feature ID(s) to aggregate events for
 */
export type AggregateEventsFeatureId = string | Array<string>;

/**
 * Time range to aggregate events for. Either range or custom_range must be provided
 */
export const Range = {
  TwentyFourh: "24h",
  Sevend: "7d",
  Thirtyd: "30d",
  Ninetyd: "90d",
  LastCycle: "last_cycle",
  Onebc: "1bc",
  Threebc: "3bc",
} as const;
/**
 * Time range to aggregate events for. Either range or custom_range must be provided
 */
export type Range = ClosedEnum<typeof Range>;

/**
 * Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day
 */
export const BinSize = {
  Day: "day",
  Hour: "hour",
  Month: "month",
} as const;
/**
 * Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day
 */
export type BinSize = ClosedEnum<typeof BinSize>;

/**
 * Custom time range to aggregate events for. If provided, range must not be provided
 */
export type AggregateEventsCustomRange = {
  start: number;
  end: number;
};

export type EventsAggregateParams = {
  /**
   * Customer ID to aggregate events for
   */
  customerId: string;
  /**
   * Feature ID(s) to aggregate events for
   */
  featureId: string | Array<string>;
  /**
   * Property to group events by. If provided, each key in the response will be an object with distinct groups as the keys
   */
  groupBy?: string | undefined;
  /**
   * Time range to aggregate events for. Either range or custom_range must be provided
   */
  range?: Range | undefined;
  /**
   * Size of the time bins to aggregate events for. Defaults to hour if range is 24h, otherwise day
   */
  binSize?: BinSize | undefined;
  /**
   * Custom time range to aggregate events for. If provided, range must not be provided
   */
  customRange?: AggregateEventsCustomRange | undefined;
};

export type AggregateEventsList = {
  /**
   * Unix timestamp (epoch ms) for this time period
   */
  period: number;
  /**
   * Aggregated values per feature: { [featureId]: number }
   */
  values: { [k: string]: number };
  /**
   * Values broken down by group (only present when group_by is used): { [featureId]: { [groupValue]: number } }
   */
  groupedValues?: { [k: string]: { [k: string]: number } } | undefined;
};

export type Total = {
  /**
   * Number of events for this feature
   */
  count: number;
  /**
   * Sum of event values for this feature
   */
  sum: number;
};

/**
 * OK
 */
export type AggregateEventsResponse = {
  /**
   * Array of time periods with aggregated values
   */
  list: Array<AggregateEventsList>;
  /**
   * Total aggregations per feature. Keys are feature IDs, values contain count and sum.
   */
  total: { [k: string]: Total };
};

/** @internal */
export type AggregateEventsFeatureId$Outbound = string | Array<string>;

/** @internal */
export const AggregateEventsFeatureId$outboundSchema: z.ZodMiniType<
  AggregateEventsFeatureId$Outbound,
  AggregateEventsFeatureId
> = smartUnion([z.string(), z.array(z.string())]);

export function aggregateEventsFeatureIdToJSON(
  aggregateEventsFeatureId: AggregateEventsFeatureId,
): string {
  return JSON.stringify(
    AggregateEventsFeatureId$outboundSchema.parse(aggregateEventsFeatureId),
  );
}

/** @internal */
export const Range$outboundSchema: z.ZodMiniEnum<typeof Range> = z.enum(Range);

/** @internal */
export const BinSize$outboundSchema: z.ZodMiniEnum<typeof BinSize> = z.enum(
  BinSize,
);

/** @internal */
export type AggregateEventsCustomRange$Outbound = {
  start: number;
  end: number;
};

/** @internal */
export const AggregateEventsCustomRange$outboundSchema: z.ZodMiniType<
  AggregateEventsCustomRange$Outbound,
  AggregateEventsCustomRange
> = z.object({
  start: z.number(),
  end: z.number(),
});

export function aggregateEventsCustomRangeToJSON(
  aggregateEventsCustomRange: AggregateEventsCustomRange,
): string {
  return JSON.stringify(
    AggregateEventsCustomRange$outboundSchema.parse(aggregateEventsCustomRange),
  );
}

/** @internal */
export type EventsAggregateParams$Outbound = {
  customer_id: string;
  feature_id: string | Array<string>;
  group_by?: string | undefined;
  range?: string | undefined;
  bin_size: string;
  custom_range?: AggregateEventsCustomRange$Outbound | undefined;
};

/** @internal */
export const EventsAggregateParams$outboundSchema: z.ZodMiniType<
  EventsAggregateParams$Outbound,
  EventsAggregateParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: smartUnion([z.string(), z.array(z.string())]),
    groupBy: z.optional(z.string()),
    range: z.optional(Range$outboundSchema),
    binSize: z._default(BinSize$outboundSchema, "day"),
    customRange: z.optional(
      z.lazy(() => AggregateEventsCustomRange$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      groupBy: "group_by",
      binSize: "bin_size",
      customRange: "custom_range",
    });
  }),
);

export function eventsAggregateParamsToJSON(
  eventsAggregateParams: EventsAggregateParams,
): string {
  return JSON.stringify(
    EventsAggregateParams$outboundSchema.parse(eventsAggregateParams),
  );
}

/** @internal */
export const AggregateEventsList$inboundSchema: z.ZodMiniType<
  AggregateEventsList,
  unknown
> = z.pipe(
  z.object({
    period: types.number(),
    values: z.record(z.string(), types.number()),
    grouped_values: types.optional(
      z.record(z.string(), z.record(z.string(), types.number())),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "grouped_values": "groupedValues",
    });
  }),
);

export function aggregateEventsListFromJSON(
  jsonString: string,
): SafeParseResult<AggregateEventsList, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AggregateEventsList$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateEventsList' from JSON`,
  );
}

/** @internal */
export const Total$inboundSchema: z.ZodMiniType<Total, unknown> = z.object({
  count: types.number(),
  sum: types.number(),
});

export function totalFromJSON(
  jsonString: string,
): SafeParseResult<Total, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Total$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Total' from JSON`,
  );
}

/** @internal */
export const AggregateEventsResponse$inboundSchema: z.ZodMiniType<
  AggregateEventsResponse,
  unknown
> = z.object({
  list: z.array(z.lazy(() => AggregateEventsList$inboundSchema)),
  total: z.record(z.string(), z.lazy(() => Total$inboundSchema)),
});

export function aggregateEventsResponseFromJSON(
  jsonString: string,
): SafeParseResult<AggregateEventsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AggregateEventsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateEventsResponse' from JSON`,
  );
}
