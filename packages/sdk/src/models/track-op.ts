/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type TrackGlobals = {
  xApiVersion?: string | undefined;
};

export type TrackParams = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the feature to track usage for. Required if event_name is not provided.
   */
  featureId?: string | undefined;
  /**
   * The ID of the entity for entity-scoped balances (e.g., per-seat limits).
   */
  entityId?: string | undefined;
  /**
   * Event name to track usage for. Use instead of feature_id when multiple features should be tracked from a single event.
   */
  eventName?: string | undefined;
  /**
   * The amount of usage to record. Defaults to 1. Use negative values to credit balance (e.g., when removing a seat).
   */
  value?: number | undefined;
  /**
   * Additional properties to attach to this usage event.
   */
  properties?: { [k: string]: any } | undefined;
};

export const TrackBalanceType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type TrackBalanceType = OpenEnum<typeof TrackBalanceType>;

export type TrackBalanceCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type TrackBalanceDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type TrackBalanceFeature = {
  id: string;
  name: string;
  type: TrackBalanceType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<TrackBalanceCreditSchema> | undefined;
  display?: TrackBalanceDisplay | undefined;
  archived: boolean;
};

export const TrackBalanceIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type TrackBalanceIntervalEnum = OpenEnum<
  typeof TrackBalanceIntervalEnum
>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type TrackBalanceIntervalUnion = TrackBalanceIntervalEnum | string;

export type TrackBalanceReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: TrackBalanceIntervalEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type TrackBalanceTo = number | string;

export type TrackBalanceTier = {
  to: number | string;
  amount: number;
};

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const TrackBalanceBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type TrackBalanceBillingMethod = OpenEnum<
  typeof TrackBalanceBillingMethod
>;

export type TrackBalancePrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<TrackBalanceTier> | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: TrackBalanceBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type TrackBalanceBreakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: TrackBalanceReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: TrackBalancePrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type TrackBalanceRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type TrackBalance = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: TrackBalanceFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<TrackBalanceBreakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<TrackBalanceRollover> | undefined;
};

export const TrackBalancesType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type TrackBalancesType = OpenEnum<typeof TrackBalancesType>;

export type TrackBalancesCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type TrackBalancesDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type TrackBalancesFeature = {
  id: string;
  name: string;
  type: TrackBalancesType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<TrackBalancesCreditSchema> | undefined;
  display?: TrackBalancesDisplay | undefined;
  archived: boolean;
};

export const TrackIntervalBalancesEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type TrackIntervalBalancesEnum = OpenEnum<
  typeof TrackIntervalBalancesEnum
>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type TrackBalancesIntervalUnion = TrackIntervalBalancesEnum | string;

export type TrackBalancesReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: TrackIntervalBalancesEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type TrackBalancesTo = number | string;

export type TrackBalancesTier = {
  to: number | string;
  amount: number;
};

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const TrackBalancesBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type TrackBalancesBillingMethod = OpenEnum<
  typeof TrackBalancesBillingMethod
>;

export type TrackBalancesPrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<TrackBalancesTier> | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: TrackBalancesBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type TrackBalancesBreakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: TrackBalancesReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: TrackBalancesPrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type TrackBalancesRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type TrackBalances = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: TrackBalancesFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<TrackBalancesBreakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<TrackBalancesRollover> | undefined;
};

/**
 * OK
 */
export type TrackResponse = {
  /**
   * The ID of the customer whose usage was tracked.
   */
  customerId: string;
  /**
   * The ID of the entity, if entity-scoped tracking was performed.
   */
  entityId?: string | undefined;
  /**
   * The event name that was tracked, if event_name was used instead of feature_id.
   */
  eventName?: string | undefined;
  /**
   * The amount of usage that was recorded.
   */
  value: number;
  /**
   * The updated balance for the tracked feature. Null if tracking by event_name that affects multiple features.
   */
  balance: TrackBalance | null;
  /**
   * Map of feature_id to updated balance when tracking by event_name affects multiple features.
   */
  balances?: { [k: string]: TrackBalances } | undefined;
};

/** @internal */
export type TrackParams$Outbound = {
  customer_id: string;
  feature_id?: string | undefined;
  entity_id?: string | undefined;
  event_name?: string | undefined;
  value?: number | undefined;
  properties?: { [k: string]: any } | undefined;
};

/** @internal */
export const TrackParams$outboundSchema: z.ZodMiniType<
  TrackParams$Outbound,
  TrackParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: z.optional(z.string()),
    entityId: z.optional(z.string()),
    eventName: z.optional(z.string()),
    value: z.optional(z.number()),
    properties: z.optional(z.record(z.string(), z.any())),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      entityId: "entity_id",
      eventName: "event_name",
    });
  }),
);

export function trackParamsToJSON(trackParams: TrackParams): string {
  return JSON.stringify(TrackParams$outboundSchema.parse(trackParams));
}

/** @internal */
export const TrackBalanceType$inboundSchema: z.ZodMiniType<
  TrackBalanceType,
  unknown
> = openEnums.inboundSchema(TrackBalanceType);

/** @internal */
export const TrackBalanceCreditSchema$inboundSchema: z.ZodMiniType<
  TrackBalanceCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function trackBalanceCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceCreditSchema' from JSON`,
  );
}

/** @internal */
export const TrackBalanceDisplay$inboundSchema: z.ZodMiniType<
  TrackBalanceDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function trackBalanceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceDisplay' from JSON`,
  );
}

/** @internal */
export const TrackBalanceFeature$inboundSchema: z.ZodMiniType<
  TrackBalanceFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: TrackBalanceType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => TrackBalanceCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => TrackBalanceDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function trackBalanceFeatureFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceFeature' from JSON`,
  );
}

/** @internal */
export const TrackBalanceIntervalEnum$inboundSchema: z.ZodMiniType<
  TrackBalanceIntervalEnum,
  unknown
> = openEnums.inboundSchema(TrackBalanceIntervalEnum);

/** @internal */
export const TrackBalanceIntervalUnion$inboundSchema: z.ZodMiniType<
  TrackBalanceIntervalUnion,
  unknown
> = smartUnion([TrackBalanceIntervalEnum$inboundSchema, types.string()]);

export function trackBalanceIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceIntervalUnion' from JSON`,
  );
}

/** @internal */
export const TrackBalanceReset$inboundSchema: z.ZodMiniType<
  TrackBalanceReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      TrackBalanceIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function trackBalanceResetFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceReset' from JSON`,
  );
}

/** @internal */
export const TrackBalanceTo$inboundSchema: z.ZodMiniType<
  TrackBalanceTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function trackBalanceToFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceTo' from JSON`,
  );
}

/** @internal */
export const TrackBalanceTier$inboundSchema: z.ZodMiniType<
  TrackBalanceTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function trackBalanceTierFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceTier' from JSON`,
  );
}

/** @internal */
export const TrackBalanceBillingMethod$inboundSchema: z.ZodMiniType<
  TrackBalanceBillingMethod,
  unknown
> = openEnums.inboundSchema(TrackBalanceBillingMethod);

/** @internal */
export const TrackBalancePrice$inboundSchema: z.ZodMiniType<
  TrackBalancePrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => TrackBalanceTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: TrackBalanceBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function trackBalancePriceFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancePrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancePrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancePrice' from JSON`,
  );
}

/** @internal */
export const TrackBalanceBreakdown$inboundSchema: z.ZodMiniType<
  TrackBalanceBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => TrackBalanceReset$inboundSchema)),
    price: types.nullable(z.lazy(() => TrackBalancePrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function trackBalanceBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceBreakdown' from JSON`,
  );
}

/** @internal */
export const TrackBalanceRollover$inboundSchema: z.ZodMiniType<
  TrackBalanceRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function trackBalanceRolloverFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalanceRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalanceRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalanceRollover' from JSON`,
  );
}

/** @internal */
export const TrackBalance$inboundSchema: z.ZodMiniType<TrackBalance, unknown> =
  z.pipe(
    z.object({
      feature_id: types.string(),
      feature: types.optional(z.lazy(() => TrackBalanceFeature$inboundSchema)),
      granted: types.number(),
      remaining: types.number(),
      usage: types.number(),
      unlimited: types.boolean(),
      overage_allowed: types.boolean(),
      max_purchase: types.nullable(types.number()),
      next_reset_at: types.nullable(types.number()),
      breakdown: types.optional(
        z.array(z.lazy(() => TrackBalanceBreakdown$inboundSchema)),
      ),
      rollovers: types.optional(
        z.array(z.lazy(() => TrackBalanceRollover$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "feature_id": "featureId",
        "overage_allowed": "overageAllowed",
        "max_purchase": "maxPurchase",
        "next_reset_at": "nextResetAt",
      });
    }),
  );

export function trackBalanceFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalance' from JSON`,
  );
}

/** @internal */
export const TrackBalancesType$inboundSchema: z.ZodMiniType<
  TrackBalancesType,
  unknown
> = openEnums.inboundSchema(TrackBalancesType);

/** @internal */
export const TrackBalancesCreditSchema$inboundSchema: z.ZodMiniType<
  TrackBalancesCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function trackBalancesCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesCreditSchema' from JSON`,
  );
}

/** @internal */
export const TrackBalancesDisplay$inboundSchema: z.ZodMiniType<
  TrackBalancesDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function trackBalancesDisplayFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesDisplay' from JSON`,
  );
}

/** @internal */
export const TrackBalancesFeature$inboundSchema: z.ZodMiniType<
  TrackBalancesFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: TrackBalancesType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => TrackBalancesCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => TrackBalancesDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function trackBalancesFeatureFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesFeature' from JSON`,
  );
}

/** @internal */
export const TrackIntervalBalancesEnum$inboundSchema: z.ZodMiniType<
  TrackIntervalBalancesEnum,
  unknown
> = openEnums.inboundSchema(TrackIntervalBalancesEnum);

/** @internal */
export const TrackBalancesIntervalUnion$inboundSchema: z.ZodMiniType<
  TrackBalancesIntervalUnion,
  unknown
> = smartUnion([TrackIntervalBalancesEnum$inboundSchema, types.string()]);

export function trackBalancesIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesIntervalUnion' from JSON`,
  );
}

/** @internal */
export const TrackBalancesReset$inboundSchema: z.ZodMiniType<
  TrackBalancesReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      TrackIntervalBalancesEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function trackBalancesResetFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesReset' from JSON`,
  );
}

/** @internal */
export const TrackBalancesTo$inboundSchema: z.ZodMiniType<
  TrackBalancesTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function trackBalancesToFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesTo' from JSON`,
  );
}

/** @internal */
export const TrackBalancesTier$inboundSchema: z.ZodMiniType<
  TrackBalancesTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function trackBalancesTierFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesTier' from JSON`,
  );
}

/** @internal */
export const TrackBalancesBillingMethod$inboundSchema: z.ZodMiniType<
  TrackBalancesBillingMethod,
  unknown
> = openEnums.inboundSchema(TrackBalancesBillingMethod);

/** @internal */
export const TrackBalancesPrice$inboundSchema: z.ZodMiniType<
  TrackBalancesPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => TrackBalancesTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: TrackBalancesBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function trackBalancesPriceFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesPrice' from JSON`,
  );
}

/** @internal */
export const TrackBalancesBreakdown$inboundSchema: z.ZodMiniType<
  TrackBalancesBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => TrackBalancesReset$inboundSchema)),
    price: types.nullable(z.lazy(() => TrackBalancesPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function trackBalancesBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesBreakdown' from JSON`,
  );
}

/** @internal */
export const TrackBalancesRollover$inboundSchema: z.ZodMiniType<
  TrackBalancesRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function trackBalancesRolloverFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalancesRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalancesRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalancesRollover' from JSON`,
  );
}

/** @internal */
export const TrackBalances$inboundSchema: z.ZodMiniType<
  TrackBalances,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => TrackBalancesFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => TrackBalancesBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => TrackBalancesRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function trackBalancesFromJSON(
  jsonString: string,
): SafeParseResult<TrackBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackBalances' from JSON`,
  );
}

/** @internal */
export const TrackResponse$inboundSchema: z.ZodMiniType<
  TrackResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    event_name: types.optional(types.string()),
    value: types.number(),
    balance: types.nullable(z.lazy(() => TrackBalance$inboundSchema)),
    balances: types.optional(
      z.record(z.string(), z.lazy(() => TrackBalances$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "event_name": "eventName",
    });
  }),
);

export function trackResponseFromJSON(
  jsonString: string,
): SafeParseResult<TrackResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackResponse' from JSON`,
  );
}
