/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BalancesCheckGlobals = {
  xApiVersion?: string | undefined;
};

export type BalancesCheckRequest = {
  /**
   * ID which you provided when creating the customer
   */
  customerId: string;
  /**
   * ID of the feature to check access to.
   */
  featureId: string;
  /**
   * If using entity balances (eg, seats), the entity ID to check access for.
   */
  entityId?: string | undefined;
  /**
   * If you know the amount of the feature the end user is consuming in advance. If their balance is below this quantity, allowed will be false.
   */
  requiredBalance?: number | undefined;
  properties?: { [k: string]: any } | undefined;
  /**
   * If true, a usage event will be recorded together with checking access. The required_balance field will be used as the usage value.
   */
  sendEvent?: boolean | undefined;
  /**
   * If true, the response will include a preview object, which can be used to display information such as a paywall or upgrade confirmation.
   */
  withPreview?: boolean | undefined;
};

export const BalancesCheckBalanceType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type BalancesCheckBalanceType = OpenEnum<
  typeof BalancesCheckBalanceType
>;

export type BalancesCheckCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type BalancesCheckBalanceDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type BalancesCheckFeature = {
  id: string;
  name: string;
  type: BalancesCheckBalanceType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<BalancesCheckCreditSchema> | undefined;
  display?: BalancesCheckBalanceDisplay | undefined;
  archived: boolean;
};

export const BalancesCheckBalanceIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BalancesCheckBalanceIntervalEnum = OpenEnum<
  typeof BalancesCheckBalanceIntervalEnum
>;

export type BalancesCheckIntervalUnion =
  | BalancesCheckBalanceIntervalEnum
  | string;

export type BalancesCheckReset = {
  interval: BalancesCheckBalanceIntervalEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type BalancesCheckBalanceTo = number | string;

export type BalancesCheckTier = {
  to: number | string;
  amount: number;
};

export const BalancesCheckBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BalancesCheckBillingMethod = OpenEnum<
  typeof BalancesCheckBillingMethod
>;

export type BalancesCheckPrice = {
  amount?: number | undefined;
  tiers?: Array<BalancesCheckTier> | undefined;
  billingUnits: number;
  billingMethod: BalancesCheckBillingMethod;
  maxPurchase: number | null;
};

export type BalancesCheckBreakdown = {
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: BalancesCheckReset | null;
  price: BalancesCheckPrice | null;
  expiresAt: number | null;
};

export type BalancesCheckBalanceRollover = {
  balance: number;
  expiresAt: number;
};

export type BalancesCheckBalance = {
  featureId: string;
  feature?: BalancesCheckFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<BalancesCheckBreakdown> | undefined;
  rollovers?: Array<BalancesCheckBalanceRollover> | undefined;
};

export const BalancesCheckScenario = {
  UsageLimit: "usage_limit",
  FeatureFlag: "feature_flag",
} as const;
export type BalancesCheckScenario = OpenEnum<typeof BalancesCheckScenario>;

/**
 * The environment of the product
 */
export const BalancesCheckEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment of the product
 */
export type BalancesCheckEnv = OpenEnum<typeof BalancesCheckEnv>;

export const ProductType = {
  Feature: "feature",
  PricedFeature: "priced_feature",
  Price: "price",
} as const;
export type ProductType = OpenEnum<typeof ProductType>;

export const FeatureType = {
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  Boolean: "boolean",
  Static: "static",
} as const;
export type FeatureType = OpenEnum<typeof FeatureType>;

export type IncludedUsage = number | string;

export const ProductInterval = {
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type ProductInterval = OpenEnum<typeof ProductInterval>;

/**
 * The maximum amount of usage for this tier.
 */
export type TiersTo = number | string;

export type Tiers = {
  /**
   * The maximum amount of usage for this tier.
   */
  to: number | string;
  /**
   * The price of the product item for this tier.
   */
  amount: number;
};

export const UsageModel = {
  Prepaid: "prepaid",
  PayPerUse: "pay_per_use",
} as const;
export type UsageModel = OpenEnum<typeof UsageModel>;

export type ProductDisplay = {
  primaryText: string;
  secondaryText?: string | null | undefined;
};

export const RolloverDuration = {
  Month: "month",
  Forever: "forever",
} as const;
export type RolloverDuration = OpenEnum<typeof RolloverDuration>;

export type ConfigRollover = {
  max: number | null;
  duration: RolloverDuration;
  length: number;
};

export const BalancesCheckOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type BalancesCheckOnIncrease = OpenEnum<typeof BalancesCheckOnIncrease>;

export const BalancesCheckOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type BalancesCheckOnDecrease = OpenEnum<typeof BalancesCheckOnDecrease>;

export type Config = {
  rollover?: ConfigRollover | null | undefined;
  onIncrease?: BalancesCheckOnIncrease | null | undefined;
  onDecrease?: BalancesCheckOnDecrease | null | undefined;
};

/**
 * Product item defining features and pricing within a product
 */
export type BalancesCheckItem = {
  /**
   * The type of the product item
   */
  type?: ProductType | null | undefined;
  /**
   * The feature ID of the product item. If the item is a fixed price, should be `null`
   */
  featureId?: string | null | undefined;
  /**
   * Single use features are used once and then depleted, like API calls or credits. Continuous use features are those being used on an ongoing-basis, like storage or seats.
   */
  featureType?: FeatureType | null | undefined;
  /**
   * The amount of usage included for this feature.
   */
  includedUsage?: number | string | null | undefined;
  /**
   * The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off.
   */
  interval?: ProductInterval | null | undefined;
  /**
   * The interval count of the product item.
   */
  intervalCount?: number | null | undefined;
  /**
   * The price of the product item. Should be `null` if tiered pricing is set.
   */
  price?: number | null | undefined;
  /**
   * Tiered pricing for the product item. Not applicable for fixed price items.
   */
  tiers?: Array<Tiers> | null | undefined;
  /**
   * Whether the feature should be prepaid upfront or billed for how much they use end of billing period.
   */
  usageModel?: UsageModel | null | undefined;
  /**
   * The amount per billing unit (eg. $9 / 250 units)
   */
  billingUnits?: number | null | undefined;
  /**
   * Whether the usage should be reset when the product is enabled.
   */
  resetUsageWhenEnabled?: boolean | null | undefined;
  /**
   * The entity feature ID of the product item if applicable.
   */
  entityFeatureId?: string | null | undefined;
  /**
   * The display of the product item.
   */
  display?: ProductDisplay | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer has prepaid for.
   */
  quantity?: number | null | undefined;
  /**
   * Used in customer context. Quantity of the feature the customer will prepay for in the next cycle.
   */
  nextCycleQuantity?: number | null | undefined;
  /**
   * Configuration for rollover and proration behavior of the feature.
   */
  config?: Config | null | undefined;
};

/**
 * The duration type of the free trial
 */
export const FreeTrialDuration = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * The duration type of the free trial
 */
export type FreeTrialDuration = OpenEnum<typeof FreeTrialDuration>;

export type BalancesCheckFreeTrial = {
  /**
   * The duration type of the free trial
   */
  duration: FreeTrialDuration;
  /**
   * The length of the duration type specified
   */
  length: number;
  /**
   * Whether the free trial is limited to one per customer fingerprint
   */
  uniqueFingerprint: boolean;
  /**
   * Whether the free trial requires a card. If false, the customer can attach the product without going through a checkout flow or having a card on file.
   */
  cardRequired: boolean;
  /**
   * Used in customer context. Whether the free trial is available for the customer if they were to attach the product.
   */
  trialAvailable: boolean | null;
};

/**
 * Scenario for when this product is used in attach flows
 */
export const ProductScenario = {
  Scheduled: "scheduled",
  Active: "active",
  New: "new",
  Renew: "renew",
  Upgrade: "upgrade",
  Downgrade: "downgrade",
  Cancel: "cancel",
  Expired: "expired",
  PastDue: "past_due",
} as const;
/**
 * Scenario for when this product is used in attach flows
 */
export type ProductScenario = OpenEnum<typeof ProductScenario>;

export type Properties = {
  /**
   * True if the product has no base price or usage prices
   */
  isFree: boolean;
  /**
   * True if the product only contains a one-time price
   */
  isOneOff: boolean;
  /**
   * The billing interval group for recurring products (e.g., 'monthly', 'yearly')
   */
  intervalGroup?: string | null | undefined;
  /**
   * True if the product includes a free trial
   */
  hasTrial?: boolean | null | undefined;
  /**
   * True if the product can be updated after creation (only applicable if there are prepaid recurring prices)
   */
  updateable?: boolean | null | undefined;
};

export type Product = {
  /**
   * The ID of the product you set when creating the product
   */
  id: string;
  /**
   * The name of the product
   */
  name: string;
  /**
   * Product group which this product belongs to
   */
  group: string | null;
  /**
   * The environment of the product
   */
  env: BalancesCheckEnv;
  /**
   * Whether the product is an add-on and can be purchased alongside other products
   */
  isAddOn: boolean;
  /**
   * Whether the product is the default product
   */
  isDefault: boolean;
  /**
   * Whether this product has been archived and is no longer available
   */
  archived: boolean;
  /**
   * The current version of the product
   */
  version: number;
  /**
   * The timestamp of when the product was created in milliseconds since epoch
   */
  createdAt: number;
  /**
   * Array of product items that define the product's features and pricing
   */
  items: Array<BalancesCheckItem>;
  /**
   * Free trial configuration for this product, if available
   */
  freeTrial: BalancesCheckFreeTrial | null;
  /**
   * ID of the base variant this product is derived from
   */
  baseVariantId: string | null;
  /**
   * Scenario for when this product is used in attach flows
   */
  scenario?: ProductScenario | undefined;
  properties?: Properties | undefined;
};

export type Preview = {
  scenario: BalancesCheckScenario;
  title: string;
  message: string;
  featureId: string;
  featureName: string;
  products: Array<Product>;
};

/**
 * OK
 */
export type BalancesCheckResponse = {
  allowed: boolean;
  customerId: string;
  entityId?: string | null | undefined;
  requiredBalance?: number | undefined;
  balance: BalancesCheckBalance | null;
  preview?: Preview | undefined;
};

/** @internal */
export type BalancesCheckRequest$Outbound = {
  customer_id: string;
  feature_id: string;
  entity_id?: string | undefined;
  required_balance?: number | undefined;
  properties?: { [k: string]: any } | undefined;
  send_event?: boolean | undefined;
  with_preview?: boolean | undefined;
};

/** @internal */
export const BalancesCheckRequest$outboundSchema: z.ZodMiniType<
  BalancesCheckRequest$Outbound,
  BalancesCheckRequest
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: z.string(),
    entityId: z.optional(z.string()),
    requiredBalance: z.optional(z.number()),
    properties: z.optional(z.record(z.string(), z.any())),
    sendEvent: z.optional(z.boolean()),
    withPreview: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      entityId: "entity_id",
      requiredBalance: "required_balance",
      sendEvent: "send_event",
      withPreview: "with_preview",
    });
  }),
);

export function balancesCheckRequestToJSON(
  balancesCheckRequest: BalancesCheckRequest,
): string {
  return JSON.stringify(
    BalancesCheckRequest$outboundSchema.parse(balancesCheckRequest),
  );
}

/** @internal */
export const BalancesCheckBalanceType$inboundSchema: z.ZodMiniType<
  BalancesCheckBalanceType,
  unknown
> = openEnums.inboundSchema(BalancesCheckBalanceType);

/** @internal */
export const BalancesCheckCreditSchema$inboundSchema: z.ZodMiniType<
  BalancesCheckCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function balancesCheckCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckCreditSchema' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBalanceDisplay$inboundSchema: z.ZodMiniType<
  BalancesCheckBalanceDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function balancesCheckBalanceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckBalanceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckBalanceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckBalanceDisplay' from JSON`,
  );
}

/** @internal */
export const BalancesCheckFeature$inboundSchema: z.ZodMiniType<
  BalancesCheckFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: BalancesCheckBalanceType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => BalancesCheckCreditSchema$inboundSchema)),
    ),
    display: types.optional(
      z.lazy(() => BalancesCheckBalanceDisplay$inboundSchema),
    ),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function balancesCheckFeatureFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckFeature' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBalanceIntervalEnum$inboundSchema: z.ZodMiniType<
  BalancesCheckBalanceIntervalEnum,
  unknown
> = openEnums.inboundSchema(BalancesCheckBalanceIntervalEnum);

/** @internal */
export const BalancesCheckIntervalUnion$inboundSchema: z.ZodMiniType<
  BalancesCheckIntervalUnion,
  unknown
> = smartUnion([
  BalancesCheckBalanceIntervalEnum$inboundSchema,
  types.string(),
]);

export function balancesCheckIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckIntervalUnion' from JSON`,
  );
}

/** @internal */
export const BalancesCheckReset$inboundSchema: z.ZodMiniType<
  BalancesCheckReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      BalancesCheckBalanceIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function balancesCheckResetFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckReset' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBalanceTo$inboundSchema: z.ZodMiniType<
  BalancesCheckBalanceTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function balancesCheckBalanceToFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckBalanceTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckBalanceTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckBalanceTo' from JSON`,
  );
}

/** @internal */
export const BalancesCheckTier$inboundSchema: z.ZodMiniType<
  BalancesCheckTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function balancesCheckTierFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckTier' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBillingMethod$inboundSchema: z.ZodMiniType<
  BalancesCheckBillingMethod,
  unknown
> = openEnums.inboundSchema(BalancesCheckBillingMethod);

/** @internal */
export const BalancesCheckPrice$inboundSchema: z.ZodMiniType<
  BalancesCheckPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => BalancesCheckTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: BalancesCheckBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function balancesCheckPriceFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckPrice' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBreakdown$inboundSchema: z.ZodMiniType<
  BalancesCheckBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => BalancesCheckReset$inboundSchema)),
    price: types.nullable(z.lazy(() => BalancesCheckPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesCheckBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckBreakdown' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBalanceRollover$inboundSchema: z.ZodMiniType<
  BalancesCheckBalanceRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesCheckBalanceRolloverFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckBalanceRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckBalanceRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckBalanceRollover' from JSON`,
  );
}

/** @internal */
export const BalancesCheckBalance$inboundSchema: z.ZodMiniType<
  BalancesCheckBalance,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => BalancesCheckFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => BalancesCheckBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => BalancesCheckBalanceRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function balancesCheckBalanceFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckBalance' from JSON`,
  );
}

/** @internal */
export const BalancesCheckScenario$inboundSchema: z.ZodMiniType<
  BalancesCheckScenario,
  unknown
> = openEnums.inboundSchema(BalancesCheckScenario);

/** @internal */
export const BalancesCheckEnv$inboundSchema: z.ZodMiniType<
  BalancesCheckEnv,
  unknown
> = openEnums.inboundSchema(BalancesCheckEnv);

/** @internal */
export const ProductType$inboundSchema: z.ZodMiniType<ProductType, unknown> =
  openEnums.inboundSchema(ProductType);

/** @internal */
export const FeatureType$inboundSchema: z.ZodMiniType<FeatureType, unknown> =
  openEnums.inboundSchema(FeatureType);

/** @internal */
export const IncludedUsage$inboundSchema: z.ZodMiniType<
  IncludedUsage,
  unknown
> = smartUnion([types.number(), types.string()]);

export function includedUsageFromJSON(
  jsonString: string,
): SafeParseResult<IncludedUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncludedUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncludedUsage' from JSON`,
  );
}

/** @internal */
export const ProductInterval$inboundSchema: z.ZodMiniType<
  ProductInterval,
  unknown
> = openEnums.inboundSchema(ProductInterval);

/** @internal */
export const TiersTo$inboundSchema: z.ZodMiniType<TiersTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function tiersToFromJSON(
  jsonString: string,
): SafeParseResult<TiersTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TiersTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TiersTo' from JSON`,
  );
}

/** @internal */
export const Tiers$inboundSchema: z.ZodMiniType<Tiers, unknown> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function tiersFromJSON(
  jsonString: string,
): SafeParseResult<Tiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tiers' from JSON`,
  );
}

/** @internal */
export const UsageModel$inboundSchema: z.ZodMiniType<UsageModel, unknown> =
  openEnums.inboundSchema(UsageModel);

/** @internal */
export const ProductDisplay$inboundSchema: z.ZodMiniType<
  ProductDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function productDisplayFromJSON(
  jsonString: string,
): SafeParseResult<ProductDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductDisplay' from JSON`,
  );
}

/** @internal */
export const RolloverDuration$inboundSchema: z.ZodMiniType<
  RolloverDuration,
  unknown
> = openEnums.inboundSchema(RolloverDuration);

/** @internal */
export const ConfigRollover$inboundSchema: z.ZodMiniType<
  ConfigRollover,
  unknown
> = z.object({
  max: types.nullable(types.number()),
  duration: z._default(RolloverDuration$inboundSchema, "month"),
  length: types.number(),
});

export function configRolloverFromJSON(
  jsonString: string,
): SafeParseResult<ConfigRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConfigRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConfigRollover' from JSON`,
  );
}

/** @internal */
export const BalancesCheckOnIncrease$inboundSchema: z.ZodMiniType<
  BalancesCheckOnIncrease,
  unknown
> = openEnums.inboundSchema(BalancesCheckOnIncrease);

/** @internal */
export const BalancesCheckOnDecrease$inboundSchema: z.ZodMiniType<
  BalancesCheckOnDecrease,
  unknown
> = openEnums.inboundSchema(BalancesCheckOnDecrease);

/** @internal */
export const Config$inboundSchema: z.ZodMiniType<Config, unknown> = z.pipe(
  z.object({
    rollover: z.optional(
      z.nullable(z.lazy(() => ConfigRollover$inboundSchema)),
    ),
    on_increase: z.optional(z.nullable(BalancesCheckOnIncrease$inboundSchema)),
    on_decrease: z.optional(z.nullable(BalancesCheckOnDecrease$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "on_increase": "onIncrease",
      "on_decrease": "onDecrease",
    });
  }),
);

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const BalancesCheckItem$inboundSchema: z.ZodMiniType<
  BalancesCheckItem,
  unknown
> = z.pipe(
  z.object({
    type: z.optional(z.nullable(ProductType$inboundSchema)),
    feature_id: z.optional(z.nullable(types.string())),
    feature_type: z.optional(z.nullable(FeatureType$inboundSchema)),
    included_usage: z.optional(
      z.nullable(smartUnion([types.number(), types.string()])),
    ),
    interval: z.optional(z.nullable(ProductInterval$inboundSchema)),
    interval_count: z.optional(z.nullable(types.number())),
    price: z.optional(z.nullable(types.number())),
    tiers: z.optional(z.nullable(z.array(z.lazy(() => Tiers$inboundSchema)))),
    usage_model: z.optional(z.nullable(UsageModel$inboundSchema)),
    billing_units: z.optional(z.nullable(types.number())),
    reset_usage_when_enabled: z.optional(z.nullable(types.boolean())),
    entity_feature_id: z.optional(z.nullable(types.string())),
    display: z.optional(z.nullable(z.lazy(() => ProductDisplay$inboundSchema))),
    quantity: z.optional(z.nullable(types.number())),
    next_cycle_quantity: z.optional(z.nullable(types.number())),
    config: z.optional(z.nullable(z.lazy(() => Config$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "feature_type": "featureType",
      "included_usage": "includedUsage",
      "interval_count": "intervalCount",
      "usage_model": "usageModel",
      "billing_units": "billingUnits",
      "reset_usage_when_enabled": "resetUsageWhenEnabled",
      "entity_feature_id": "entityFeatureId",
      "next_cycle_quantity": "nextCycleQuantity",
    });
  }),
);

export function balancesCheckItemFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckItem' from JSON`,
  );
}

/** @internal */
export const FreeTrialDuration$inboundSchema: z.ZodMiniType<
  FreeTrialDuration,
  unknown
> = openEnums.inboundSchema(FreeTrialDuration);

/** @internal */
export const BalancesCheckFreeTrial$inboundSchema: z.ZodMiniType<
  BalancesCheckFreeTrial,
  unknown
> = z.pipe(
  z.object({
    duration: FreeTrialDuration$inboundSchema,
    length: types.number(),
    unique_fingerprint: types.boolean(),
    card_required: types.boolean(),
    trial_available: z.nullable(z._default(types.boolean(), true)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unique_fingerprint": "uniqueFingerprint",
      "card_required": "cardRequired",
      "trial_available": "trialAvailable",
    });
  }),
);

export function balancesCheckFreeTrialFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckFreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckFreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckFreeTrial' from JSON`,
  );
}

/** @internal */
export const ProductScenario$inboundSchema: z.ZodMiniType<
  ProductScenario,
  unknown
> = openEnums.inboundSchema(ProductScenario);

/** @internal */
export const Properties$inboundSchema: z.ZodMiniType<Properties, unknown> = z
  .pipe(
    z.object({
      is_free: types.boolean(),
      is_one_off: types.boolean(),
      interval_group: z.optional(z.nullable(types.string())),
      has_trial: z.optional(z.nullable(types.boolean())),
      updateable: z.optional(z.nullable(types.boolean())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_free": "isFree",
        "is_one_off": "isOneOff",
        "interval_group": "intervalGroup",
        "has_trial": "hasTrial",
      });
    }),
  );

export function propertiesFromJSON(
  jsonString: string,
): SafeParseResult<Properties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Properties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Properties' from JSON`,
  );
}

/** @internal */
export const Product$inboundSchema: z.ZodMiniType<Product, unknown> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    group: types.nullable(types.string()),
    env: BalancesCheckEnv$inboundSchema,
    is_add_on: types.boolean(),
    is_default: types.boolean(),
    archived: types.boolean(),
    version: types.number(),
    created_at: types.number(),
    items: z.array(z.lazy(() => BalancesCheckItem$inboundSchema)),
    free_trial: types.nullable(z.lazy(() =>
      BalancesCheckFreeTrial$inboundSchema
    )),
    base_variant_id: types.nullable(types.string()),
    scenario: types.optional(ProductScenario$inboundSchema),
    properties: types.optional(z.lazy(() => Properties$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_add_on": "isAddOn",
      "is_default": "isDefault",
      "created_at": "createdAt",
      "free_trial": "freeTrial",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function productFromJSON(
  jsonString: string,
): SafeParseResult<Product, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Product$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Product' from JSON`,
  );
}

/** @internal */
export const Preview$inboundSchema: z.ZodMiniType<Preview, unknown> = z.pipe(
  z.object({
    scenario: BalancesCheckScenario$inboundSchema,
    title: types.string(),
    message: types.string(),
    feature_id: types.string(),
    feature_name: types.string(),
    products: z.array(z.lazy(() => Product$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "feature_name": "featureName",
    });
  }),
);

export function previewFromJSON(
  jsonString: string,
): SafeParseResult<Preview, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Preview$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Preview' from JSON`,
  );
}

/** @internal */
export const BalancesCheckResponse$inboundSchema: z.ZodMiniType<
  BalancesCheckResponse,
  unknown
> = z.pipe(
  z.object({
    allowed: types.boolean(),
    customer_id: types.string(),
    entity_id: z.optional(z.nullable(types.string())),
    required_balance: types.optional(types.number()),
    balance: types.nullable(z.lazy(() => BalancesCheckBalance$inboundSchema)),
    preview: types.optional(z.lazy(() => Preview$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "required_balance": "requiredBalance",
    });
  }),
);

export function balancesCheckResponseFromJSON(
  jsonString: string,
): SafeParseResult<BalancesCheckResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesCheckResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesCheckResponse' from JSON`,
  );
}
