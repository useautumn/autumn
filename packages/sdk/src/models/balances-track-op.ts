/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BalancesTrackGlobals = {
  xApiVersion?: string | undefined;
};

export type BalancesTrackRequest = {
  /**
   * ID which you provided when creating the customer
   */
  customerId: string;
  /**
   * ID of the feature to track usage for. Required if event_name is not provided. Use this for direct feature tracking.
   */
  featureId?: string | undefined;
  /**
   * An [event name](/features/tracking-usage#using-event-names) can be used in place of feature_id. This can be used if multiple features are tracked in the same event.
   */
  eventName?: string | undefined;
  /**
   * The amount of usage to record. Defaults to 1. Can be negative to increase the balance (e.g., when removing a seat).
   */
  value?: number | undefined;
  /**
   * Additional properties to attach to this usage event.
   */
  properties?: { [k: string]: any } | undefined;
  /**
   * Unique key to prevent duplicate event recording. Use this to safely retry requests without creating duplicate usage records.
   */
  idempotencyKey?: string | undefined;
  /**
   * If using [entity balances](/features/feature-entities) (eg, seats), the entity ID to track usage for.
   */
  entityId?: string | undefined;
};

export const BalancesTrackBalanceType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type BalancesTrackBalanceType = OpenEnum<
  typeof BalancesTrackBalanceType
>;

export type BalancesTrackBalanceCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type BalancesTrackBalanceDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type BalancesTrackBalanceFeature = {
  id: string;
  name: string;
  type: BalancesTrackBalanceType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<BalancesTrackBalanceCreditSchema> | undefined;
  display?: BalancesTrackBalanceDisplay | undefined;
  archived: boolean;
};

export const BalancesTrackBalanceIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BalancesTrackBalanceIntervalEnum = OpenEnum<
  typeof BalancesTrackBalanceIntervalEnum
>;

export type BalancesTrackBalanceIntervalUnion =
  | BalancesTrackBalanceIntervalEnum
  | string;

export type BalancesTrackBalanceReset = {
  interval: BalancesTrackBalanceIntervalEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type BalancesTrackBalanceTo = number | string;

export type BalancesTrackBalanceTier = {
  to: number | string;
  amount: number;
};

export const BalancesTrackBalanceBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BalancesTrackBalanceBillingMethod = OpenEnum<
  typeof BalancesTrackBalanceBillingMethod
>;

export type BalancesTrackBalancePrice = {
  amount?: number | undefined;
  tiers?: Array<BalancesTrackBalanceTier> | undefined;
  billingUnits: number;
  billingMethod: BalancesTrackBalanceBillingMethod;
  maxPurchase: number | null;
};

export type BalancesTrackBalanceBreakdown = {
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: BalancesTrackBalanceReset | null;
  price: BalancesTrackBalancePrice | null;
  expiresAt: number | null;
};

export type BalancesTrackBalanceRollover = {
  balance: number;
  expiresAt: number;
};

export type BalancesTrackBalance = {
  featureId: string;
  feature?: BalancesTrackBalanceFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<BalancesTrackBalanceBreakdown> | undefined;
  rollovers?: Array<BalancesTrackBalanceRollover> | undefined;
};

export const BalancesTrackType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type BalancesTrackType = OpenEnum<typeof BalancesTrackType>;

export type BalancesTrackCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type BalancesTrackDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type BalancesTrackFeature = {
  id: string;
  name: string;
  type: BalancesTrackType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<BalancesTrackCreditSchema> | undefined;
  display?: BalancesTrackDisplay | undefined;
  archived: boolean;
};

export const BalancesTrackIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BalancesTrackIntervalEnum = OpenEnum<
  typeof BalancesTrackIntervalEnum
>;

export type BalancesTrackIntervalUnion = BalancesTrackIntervalEnum | string;

export type BalancesTrackReset = {
  interval: BalancesTrackIntervalEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type BalancesTrackTo = number | string;

export type BalancesTrackTier = {
  to: number | string;
  amount: number;
};

export const BalancesTrackBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BalancesTrackBillingMethod = OpenEnum<
  typeof BalancesTrackBillingMethod
>;

export type BalancesTrackPrice = {
  amount?: number | undefined;
  tiers?: Array<BalancesTrackTier> | undefined;
  billingUnits: number;
  billingMethod: BalancesTrackBillingMethod;
  maxPurchase: number | null;
};

export type BalancesTrackBreakdown = {
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: BalancesTrackReset | null;
  price: BalancesTrackPrice | null;
  expiresAt: number | null;
};

export type BalancesTrackRollover = {
  balance: number;
  expiresAt: number;
};

export type BalancesTrackBalances = {
  featureId: string;
  feature?: BalancesTrackFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<BalancesTrackBreakdown> | undefined;
  rollovers?: Array<BalancesTrackRollover> | undefined;
};

/**
 * OK
 */
export type BalancesTrackResponse = {
  /**
   * The ID of the customer
   */
  customerId: string;
  /**
   * The ID of the entity (if provided)
   */
  entityId?: string | undefined;
  /**
   * The name of the event
   */
  eventName?: string | undefined;
  value: number;
  balance: BalancesTrackBalance | null;
  balances?: { [k: string]: BalancesTrackBalances } | undefined;
};

/** @internal */
export type BalancesTrackRequest$Outbound = {
  customer_id: string;
  feature_id?: string | undefined;
  event_name?: string | undefined;
  value?: number | undefined;
  properties?: { [k: string]: any } | undefined;
  idempotency_key?: string | undefined;
  entity_id?: string | undefined;
};

/** @internal */
export const BalancesTrackRequest$outboundSchema: z.ZodMiniType<
  BalancesTrackRequest$Outbound,
  BalancesTrackRequest
> = z.pipe(
  z.object({
    customerId: z.string(),
    featureId: z.optional(z.string()),
    eventName: z.optional(z.string()),
    value: z.optional(z.number()),
    properties: z.optional(z.record(z.string(), z.any())),
    idempotencyKey: z.optional(z.string()),
    entityId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      featureId: "feature_id",
      eventName: "event_name",
      idempotencyKey: "idempotency_key",
      entityId: "entity_id",
    });
  }),
);

export function balancesTrackRequestToJSON(
  balancesTrackRequest: BalancesTrackRequest,
): string {
  return JSON.stringify(
    BalancesTrackRequest$outboundSchema.parse(balancesTrackRequest),
  );
}

/** @internal */
export const BalancesTrackBalanceType$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceType,
  unknown
> = openEnums.inboundSchema(BalancesTrackBalanceType);

/** @internal */
export const BalancesTrackBalanceCreditSchema$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function balancesTrackBalanceCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceCreditSchema' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceDisplay$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function balancesTrackBalanceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceDisplay' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceFeature$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: BalancesTrackBalanceType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => BalancesTrackBalanceCreditSchema$inboundSchema)),
    ),
    display: types.optional(
      z.lazy(() => BalancesTrackBalanceDisplay$inboundSchema),
    ),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function balancesTrackBalanceFeatureFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceFeature' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceIntervalEnum$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceIntervalEnum,
  unknown
> = openEnums.inboundSchema(BalancesTrackBalanceIntervalEnum);

/** @internal */
export const BalancesTrackBalanceIntervalUnion$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceIntervalUnion,
  unknown
> = smartUnion([
  BalancesTrackBalanceIntervalEnum$inboundSchema,
  types.string(),
]);

export function balancesTrackBalanceIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceIntervalUnion' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceReset$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      BalancesTrackBalanceIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function balancesTrackBalanceResetFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceReset' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceTo$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function balancesTrackBalanceToFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceTo' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceTier$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function balancesTrackBalanceTierFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceTier' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceBillingMethod$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceBillingMethod,
  unknown
> = openEnums.inboundSchema(BalancesTrackBalanceBillingMethod);

/** @internal */
export const BalancesTrackBalancePrice$inboundSchema: z.ZodMiniType<
  BalancesTrackBalancePrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => BalancesTrackBalanceTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: BalancesTrackBalanceBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function balancesTrackBalancePriceFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalancePrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalancePrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalancePrice' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceBreakdown$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(
      z.lazy(() => BalancesTrackBalanceReset$inboundSchema),
    ),
    price: types.nullable(
      z.lazy(() => BalancesTrackBalancePrice$inboundSchema),
    ),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesTrackBalanceBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceBreakdown' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalanceRollover$inboundSchema: z.ZodMiniType<
  BalancesTrackBalanceRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesTrackBalanceRolloverFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalanceRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalanceRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalanceRollover' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalance$inboundSchema: z.ZodMiniType<
  BalancesTrackBalance,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(
      z.lazy(() => BalancesTrackBalanceFeature$inboundSchema),
    ),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => BalancesTrackBalanceBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => BalancesTrackBalanceRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function balancesTrackBalanceFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalance' from JSON`,
  );
}

/** @internal */
export const BalancesTrackType$inboundSchema: z.ZodMiniType<
  BalancesTrackType,
  unknown
> = openEnums.inboundSchema(BalancesTrackType);

/** @internal */
export const BalancesTrackCreditSchema$inboundSchema: z.ZodMiniType<
  BalancesTrackCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function balancesTrackCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackCreditSchema' from JSON`,
  );
}

/** @internal */
export const BalancesTrackDisplay$inboundSchema: z.ZodMiniType<
  BalancesTrackDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function balancesTrackDisplayFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackDisplay' from JSON`,
  );
}

/** @internal */
export const BalancesTrackFeature$inboundSchema: z.ZodMiniType<
  BalancesTrackFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: BalancesTrackType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => BalancesTrackCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => BalancesTrackDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function balancesTrackFeatureFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackFeature' from JSON`,
  );
}

/** @internal */
export const BalancesTrackIntervalEnum$inboundSchema: z.ZodMiniType<
  BalancesTrackIntervalEnum,
  unknown
> = openEnums.inboundSchema(BalancesTrackIntervalEnum);

/** @internal */
export const BalancesTrackIntervalUnion$inboundSchema: z.ZodMiniType<
  BalancesTrackIntervalUnion,
  unknown
> = smartUnion([BalancesTrackIntervalEnum$inboundSchema, types.string()]);

export function balancesTrackIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackIntervalUnion' from JSON`,
  );
}

/** @internal */
export const BalancesTrackReset$inboundSchema: z.ZodMiniType<
  BalancesTrackReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      BalancesTrackIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function balancesTrackResetFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackReset' from JSON`,
  );
}

/** @internal */
export const BalancesTrackTo$inboundSchema: z.ZodMiniType<
  BalancesTrackTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function balancesTrackToFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackTo' from JSON`,
  );
}

/** @internal */
export const BalancesTrackTier$inboundSchema: z.ZodMiniType<
  BalancesTrackTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function balancesTrackTierFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackTier' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBillingMethod$inboundSchema: z.ZodMiniType<
  BalancesTrackBillingMethod,
  unknown
> = openEnums.inboundSchema(BalancesTrackBillingMethod);

/** @internal */
export const BalancesTrackPrice$inboundSchema: z.ZodMiniType<
  BalancesTrackPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => BalancesTrackTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: BalancesTrackBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function balancesTrackPriceFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackPrice' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBreakdown$inboundSchema: z.ZodMiniType<
  BalancesTrackBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => BalancesTrackReset$inboundSchema)),
    price: types.nullable(z.lazy(() => BalancesTrackPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesTrackBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBreakdown' from JSON`,
  );
}

/** @internal */
export const BalancesTrackRollover$inboundSchema: z.ZodMiniType<
  BalancesTrackRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function balancesTrackRolloverFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackRollover' from JSON`,
  );
}

/** @internal */
export const BalancesTrackBalances$inboundSchema: z.ZodMiniType<
  BalancesTrackBalances,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => BalancesTrackFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => BalancesTrackBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => BalancesTrackRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function balancesTrackBalancesFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackBalances' from JSON`,
  );
}

/** @internal */
export const BalancesTrackResponse$inboundSchema: z.ZodMiniType<
  BalancesTrackResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    event_name: types.optional(types.string()),
    value: types.number(),
    balance: types.nullable(z.lazy(() => BalancesTrackBalance$inboundSchema)),
    balances: types.optional(
      z.record(z.string(), z.lazy(() => BalancesTrackBalances$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "event_name": "eventName",
    });
  }),
);

export function balancesTrackResponseFromJSON(
  jsonString: string,
): SafeParseResult<BalancesTrackResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalancesTrackResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalancesTrackResponse' from JSON`,
  );
}
