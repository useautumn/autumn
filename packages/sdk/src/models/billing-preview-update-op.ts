/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingPreviewUpdateGlobals = {
  xApiVersion?: string | undefined;
};

export type BillingPreviewUpdateFeatureQuantities = {
  featureId: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

export const BillingPreviewUpdateDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type BillingPreviewUpdateDurationType = ClosedEnum<
  typeof BillingPreviewUpdateDurationType
>;

export type BillingPreviewUpdateFreeTrial = {
  durationLength: number;
  durationType?: BillingPreviewUpdateDurationType | undefined;
  cardRequired?: boolean | undefined;
};

export const BillingPreviewUpdatePriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewUpdatePriceInterval = ClosedEnum<
  typeof BillingPreviewUpdatePriceInterval
>;

export type BillingPreviewUpdatePrice = {
  amount: number;
  interval: BillingPreviewUpdatePriceInterval;
  intervalCount?: number | undefined;
};

export const BillingPreviewUpdateResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewUpdateResetInterval = ClosedEnum<
  typeof BillingPreviewUpdateResetInterval
>;

export type BillingPreviewUpdateReset = {
  interval: BillingPreviewUpdateResetInterval;
  intervalCount?: number | undefined;
};

export type BillingPreviewUpdateTo = number | string;

export type BillingPreviewUpdateTier = {
  to: number | string;
  amount: number;
};

export const BillingPreviewUpdateItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewUpdateItemPriceInterval = ClosedEnum<
  typeof BillingPreviewUpdateItemPriceInterval
>;

export const BillingPreviewUpdateBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BillingPreviewUpdateBillingMethod = ClosedEnum<
  typeof BillingPreviewUpdateBillingMethod
>;

export type BillingPreviewUpdateItemPrice = {
  amount?: number | undefined;
  tiers?: Array<BillingPreviewUpdateTier> | undefined;
  interval: BillingPreviewUpdateItemPriceInterval;
  intervalCount?: number | undefined;
  billingUnits?: number | undefined;
  billingMethod: BillingPreviewUpdateBillingMethod;
  maxPurchase?: number | undefined;
};

export const BillingPreviewUpdateOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type BillingPreviewUpdateOnIncrease = ClosedEnum<
  typeof BillingPreviewUpdateOnIncrease
>;

export const BillingPreviewUpdateOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type BillingPreviewUpdateOnDecrease = ClosedEnum<
  typeof BillingPreviewUpdateOnDecrease
>;

export type BillingPreviewUpdateProration = {
  onIncrease: BillingPreviewUpdateOnIncrease;
  onDecrease: BillingPreviewUpdateOnDecrease;
};

export const BillingPreviewUpdateExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type BillingPreviewUpdateExpiryDurationType = ClosedEnum<
  typeof BillingPreviewUpdateExpiryDurationType
>;

export type BillingPreviewUpdateRollover = {
  max?: number | undefined;
  expiryDurationType: BillingPreviewUpdateExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export type BillingPreviewUpdateItem = {
  featureId: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingPreviewUpdateReset | undefined;
  price?: BillingPreviewUpdateItemPrice | undefined;
  proration?: BillingPreviewUpdateProration | undefined;
  rollover?: BillingPreviewUpdateRollover | undefined;
};

/**
 * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
 */
export type BillingPreviewUpdateCustomize = {
  price?: BillingPreviewUpdatePrice | null | undefined;
  items?: Array<BillingPreviewUpdateItem> | undefined;
};

export type BillingPreviewUpdateInvoiceMode = {
  enabled: boolean;
  enablePlanImmediately?: boolean | undefined;
  finalize?: boolean | undefined;
};

export const BillingPreviewUpdateCancelAction = {
  CancelImmediately: "cancel_immediately",
  CancelEndOfCycle: "cancel_end_of_cycle",
  Uncancel: "uncancel",
} as const;
export type BillingPreviewUpdateCancelAction = ClosedEnum<
  typeof BillingPreviewUpdateCancelAction
>;

export const BillingPreviewUpdateBillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
export type BillingPreviewUpdateBillingBehavior = ClosedEnum<
  typeof BillingPreviewUpdateBillingBehavior
>;

export type BillingPreviewUpdateRequest = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | null | undefined;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?:
    | Array<BillingPreviewUpdateFeatureQuantities>
    | null
    | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  freeTrial?: BillingPreviewUpdateFreeTrial | null | undefined;
  /**
   * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
   */
  customize?: BillingPreviewUpdateCustomize | undefined;
  planId?: string | undefined;
  invoiceMode?: BillingPreviewUpdateInvoiceMode | undefined;
  cancelAction?: BillingPreviewUpdateCancelAction | undefined;
  billingBehavior?: BillingPreviewUpdateBillingBehavior | undefined;
};

export type BillingPreviewUpdateDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type BillingPreviewUpdateEffectivePeriod = {
  start: number;
  end: number;
};

export type BillingPreviewUpdateLineItem = {
  title: string;
  description: string;
  amount: number;
  discounts?: Array<BillingPreviewUpdateDiscount> | undefined;
  planId: string;
  totalQuantity: number;
  paidQuantity: number;
  deferredForTrial?: boolean | undefined;
  effectivePeriod?: BillingPreviewUpdateEffectivePeriod | undefined;
  isBase?: boolean | undefined;
};

export type BillingPreviewUpdateNextCycleDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type BillingPreviewUpdateNextCycleEffectivePeriod = {
  start: number;
  end: number;
};

export type BillingPreviewUpdateNextCycleLineItem = {
  title: string;
  description: string;
  amount: number;
  discounts?: Array<BillingPreviewUpdateNextCycleDiscount> | undefined;
  planId: string;
  totalQuantity: number;
  paidQuantity: number;
  deferredForTrial?: boolean | undefined;
  effectivePeriod?: BillingPreviewUpdateNextCycleEffectivePeriod | undefined;
  isBase?: boolean | undefined;
};

export type BillingPreviewUpdateNextCycle = {
  startsAt: number;
  total: number;
  lineItems: Array<BillingPreviewUpdateNextCycleLineItem>;
};

/**
 * OK
 */
export type BillingPreviewUpdateResponse = {
  customerId: string;
  lineItems: Array<BillingPreviewUpdateLineItem>;
  total: number;
  currency: string;
  periodStart?: number | undefined;
  periodEnd?: number | undefined;
  nextCycle?: BillingPreviewUpdateNextCycle | undefined;
};

/** @internal */
export type BillingPreviewUpdateFeatureQuantities$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingPreviewUpdateFeatureQuantities$outboundSchema:
  z.ZodMiniType<
    BillingPreviewUpdateFeatureQuantities$Outbound,
    BillingPreviewUpdateFeatureQuantities
  > = z.pipe(
    z.object({
      featureId: z.string(),
      quantity: z.optional(z.number()),
      adjustable: z.optional(z.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        featureId: "feature_id",
      });
    }),
  );

export function billingPreviewUpdateFeatureQuantitiesToJSON(
  billingPreviewUpdateFeatureQuantities: BillingPreviewUpdateFeatureQuantities,
): string {
  return JSON.stringify(
    BillingPreviewUpdateFeatureQuantities$outboundSchema.parse(
      billingPreviewUpdateFeatureQuantities,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdateDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateDurationType
> = z.enum(BillingPreviewUpdateDurationType);

/** @internal */
export type BillingPreviewUpdateFreeTrial$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingPreviewUpdateFreeTrial$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateFreeTrial$Outbound,
  BillingPreviewUpdateFreeTrial
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(
      BillingPreviewUpdateDurationType$outboundSchema,
      "month",
    ),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingPreviewUpdateFreeTrialToJSON(
  billingPreviewUpdateFreeTrial: BillingPreviewUpdateFreeTrial,
): string {
  return JSON.stringify(
    BillingPreviewUpdateFreeTrial$outboundSchema.parse(
      billingPreviewUpdateFreeTrial,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdatePriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdatePriceInterval
> = z.enum(BillingPreviewUpdatePriceInterval);

/** @internal */
export type BillingPreviewUpdatePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingPreviewUpdatePrice$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdatePrice$Outbound,
  BillingPreviewUpdatePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingPreviewUpdatePriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingPreviewUpdatePriceToJSON(
  billingPreviewUpdatePrice: BillingPreviewUpdatePrice,
): string {
  return JSON.stringify(
    BillingPreviewUpdatePrice$outboundSchema.parse(billingPreviewUpdatePrice),
  );
}

/** @internal */
export const BillingPreviewUpdateResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateResetInterval
> = z.enum(BillingPreviewUpdateResetInterval);

/** @internal */
export type BillingPreviewUpdateReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingPreviewUpdateReset$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateReset$Outbound,
  BillingPreviewUpdateReset
> = z.pipe(
  z.object({
    interval: BillingPreviewUpdateResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingPreviewUpdateResetToJSON(
  billingPreviewUpdateReset: BillingPreviewUpdateReset,
): string {
  return JSON.stringify(
    BillingPreviewUpdateReset$outboundSchema.parse(billingPreviewUpdateReset),
  );
}

/** @internal */
export type BillingPreviewUpdateTo$Outbound = number | string;

/** @internal */
export const BillingPreviewUpdateTo$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateTo$Outbound,
  BillingPreviewUpdateTo
> = smartUnion([z.number(), z.string()]);

export function billingPreviewUpdateToToJSON(
  billingPreviewUpdateTo: BillingPreviewUpdateTo,
): string {
  return JSON.stringify(
    BillingPreviewUpdateTo$outboundSchema.parse(billingPreviewUpdateTo),
  );
}

/** @internal */
export type BillingPreviewUpdateTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingPreviewUpdateTier$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateTier$Outbound,
  BillingPreviewUpdateTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingPreviewUpdateTierToJSON(
  billingPreviewUpdateTier: BillingPreviewUpdateTier,
): string {
  return JSON.stringify(
    BillingPreviewUpdateTier$outboundSchema.parse(billingPreviewUpdateTier),
  );
}

/** @internal */
export const BillingPreviewUpdateItemPriceInterval$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewUpdateItemPriceInterval> = z.enum(
    BillingPreviewUpdateItemPriceInterval,
  );

/** @internal */
export const BillingPreviewUpdateBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateBillingMethod
> = z.enum(BillingPreviewUpdateBillingMethod);

/** @internal */
export type BillingPreviewUpdateItemPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingPreviewUpdateTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingPreviewUpdateItemPrice$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateItemPrice$Outbound,
  BillingPreviewUpdateItemPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(
      z.array(z.lazy(() => BillingPreviewUpdateTier$outboundSchema)),
    ),
    interval: BillingPreviewUpdateItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingPreviewUpdateBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingPreviewUpdateItemPriceToJSON(
  billingPreviewUpdateItemPrice: BillingPreviewUpdateItemPrice,
): string {
  return JSON.stringify(
    BillingPreviewUpdateItemPrice$outboundSchema.parse(
      billingPreviewUpdateItemPrice,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdateOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateOnIncrease
> = z.enum(BillingPreviewUpdateOnIncrease);

/** @internal */
export const BillingPreviewUpdateOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateOnDecrease
> = z.enum(BillingPreviewUpdateOnDecrease);

/** @internal */
export type BillingPreviewUpdateProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingPreviewUpdateProration$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateProration$Outbound,
  BillingPreviewUpdateProration
> = z.pipe(
  z.object({
    onIncrease: BillingPreviewUpdateOnIncrease$outboundSchema,
    onDecrease: BillingPreviewUpdateOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingPreviewUpdateProrationToJSON(
  billingPreviewUpdateProration: BillingPreviewUpdateProration,
): string {
  return JSON.stringify(
    BillingPreviewUpdateProration$outboundSchema.parse(
      billingPreviewUpdateProration,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdateExpiryDurationType$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewUpdateExpiryDurationType> = z.enum(
    BillingPreviewUpdateExpiryDurationType,
  );

/** @internal */
export type BillingPreviewUpdateRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingPreviewUpdateRollover$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateRollover$Outbound,
  BillingPreviewUpdateRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingPreviewUpdateExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingPreviewUpdateRolloverToJSON(
  billingPreviewUpdateRollover: BillingPreviewUpdateRollover,
): string {
  return JSON.stringify(
    BillingPreviewUpdateRollover$outboundSchema.parse(
      billingPreviewUpdateRollover,
    ),
  );
}

/** @internal */
export type BillingPreviewUpdateItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingPreviewUpdateReset$Outbound | undefined;
  price?: BillingPreviewUpdateItemPrice$Outbound | undefined;
  proration?: BillingPreviewUpdateProration$Outbound | undefined;
  rollover?: BillingPreviewUpdateRollover$Outbound | undefined;
};

/** @internal */
export const BillingPreviewUpdateItem$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateItem$Outbound,
  BillingPreviewUpdateItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => BillingPreviewUpdateReset$outboundSchema)),
    price: z.optional(
      z.lazy(() => BillingPreviewUpdateItemPrice$outboundSchema),
    ),
    proration: z.optional(
      z.lazy(() => BillingPreviewUpdateProration$outboundSchema),
    ),
    rollover: z.optional(
      z.lazy(() => BillingPreviewUpdateRollover$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingPreviewUpdateItemToJSON(
  billingPreviewUpdateItem: BillingPreviewUpdateItem,
): string {
  return JSON.stringify(
    BillingPreviewUpdateItem$outboundSchema.parse(billingPreviewUpdateItem),
  );
}

/** @internal */
export type BillingPreviewUpdateCustomize$Outbound = {
  price?: BillingPreviewUpdatePrice$Outbound | null | undefined;
  items?: Array<BillingPreviewUpdateItem$Outbound> | undefined;
};

/** @internal */
export const BillingPreviewUpdateCustomize$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateCustomize$Outbound,
  BillingPreviewUpdateCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => BillingPreviewUpdatePrice$outboundSchema)),
  ),
  items: z.optional(
    z.array(z.lazy(() => BillingPreviewUpdateItem$outboundSchema)),
  ),
});

export function billingPreviewUpdateCustomizeToJSON(
  billingPreviewUpdateCustomize: BillingPreviewUpdateCustomize,
): string {
  return JSON.stringify(
    BillingPreviewUpdateCustomize$outboundSchema.parse(
      billingPreviewUpdateCustomize,
    ),
  );
}

/** @internal */
export type BillingPreviewUpdateInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const BillingPreviewUpdateInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateInvoiceMode$Outbound,
  BillingPreviewUpdateInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function billingPreviewUpdateInvoiceModeToJSON(
  billingPreviewUpdateInvoiceMode: BillingPreviewUpdateInvoiceMode,
): string {
  return JSON.stringify(
    BillingPreviewUpdateInvoiceMode$outboundSchema.parse(
      billingPreviewUpdateInvoiceMode,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdateCancelAction$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateCancelAction
> = z.enum(BillingPreviewUpdateCancelAction);

/** @internal */
export const BillingPreviewUpdateBillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewUpdateBillingBehavior
> = z.enum(BillingPreviewUpdateBillingBehavior);

/** @internal */
export type BillingPreviewUpdateRequest$Outbound = {
  customer_id: string;
  entity_id?: string | null | undefined;
  feature_quantities?:
    | Array<BillingPreviewUpdateFeatureQuantities$Outbound>
    | null
    | undefined;
  version?: number | undefined;
  free_trial?: BillingPreviewUpdateFreeTrial$Outbound | null | undefined;
  customize?: BillingPreviewUpdateCustomize$Outbound | undefined;
  plan_id?: string | undefined;
  invoice_mode?: BillingPreviewUpdateInvoiceMode$Outbound | undefined;
  cancel_action?: string | undefined;
  billing_behavior?: string | undefined;
};

/** @internal */
export const BillingPreviewUpdateRequest$outboundSchema: z.ZodMiniType<
  BillingPreviewUpdateRequest$Outbound,
  BillingPreviewUpdateRequest
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.nullable(z.string())),
    featureQuantities: z.optional(z.nullable(z.array(z.lazy(() =>
      BillingPreviewUpdateFeatureQuantities$outboundSchema
    )))),
    version: z.optional(z.number()),
    freeTrial: z.optional(z.nullable(z.lazy(() =>
      BillingPreviewUpdateFreeTrial$outboundSchema
    ))),
    customize: z.optional(z.lazy(() =>
      BillingPreviewUpdateCustomize$outboundSchema
    )),
    planId: z.optional(z.string()),
    invoiceMode: z.optional(z.lazy(() =>
      BillingPreviewUpdateInvoiceMode$outboundSchema
    )),
    cancelAction: z.optional(BillingPreviewUpdateCancelAction$outboundSchema),
    billingBehavior: z.optional(
      BillingPreviewUpdateBillingBehavior$outboundSchema,
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      featureQuantities: "feature_quantities",
      freeTrial: "free_trial",
      planId: "plan_id",
      invoiceMode: "invoice_mode",
      cancelAction: "cancel_action",
      billingBehavior: "billing_behavior",
    });
  }),
);

export function billingPreviewUpdateRequestToJSON(
  billingPreviewUpdateRequest: BillingPreviewUpdateRequest,
): string {
  return JSON.stringify(
    BillingPreviewUpdateRequest$outboundSchema.parse(
      billingPreviewUpdateRequest,
    ),
  );
}

/** @internal */
export const BillingPreviewUpdateDiscount$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function billingPreviewUpdateDiscountFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewUpdateDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateDiscount' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateEffectivePeriod$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateEffectivePeriod,
  unknown
> = z.object({
  start: types.number(),
  end: types.number(),
});

export function billingPreviewUpdateEffectivePeriodFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateEffectivePeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewUpdateEffectivePeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateEffectivePeriod' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateLineItem$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateLineItem,
  unknown
> = z.pipe(
  z.object({
    title: types.string(),
    description: types.string(),
    amount: types.number(),
    discounts: types.optional(
      z.array(z.lazy(() => BillingPreviewUpdateDiscount$inboundSchema)),
    ),
    plan_id: types.string(),
    total_quantity: types.number(),
    paid_quantity: types.number(),
    deferred_for_trial: types.optional(types.boolean()),
    effective_period: types.optional(
      z.lazy(() => BillingPreviewUpdateEffectivePeriod$inboundSchema),
    ),
    is_base: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "total_quantity": "totalQuantity",
      "paid_quantity": "paidQuantity",
      "deferred_for_trial": "deferredForTrial",
      "effective_period": "effectivePeriod",
      "is_base": "isBase",
    });
  }),
);

export function billingPreviewUpdateLineItemFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewUpdateLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateLineItem' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateNextCycleDiscount$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateNextCycleDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function billingPreviewUpdateNextCycleDiscountFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateNextCycleDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewUpdateNextCycleDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateNextCycleDiscount' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateNextCycleEffectivePeriod$inboundSchema:
  z.ZodMiniType<BillingPreviewUpdateNextCycleEffectivePeriod, unknown> = z
    .object({
      start: types.number(),
      end: types.number(),
    });

export function billingPreviewUpdateNextCycleEffectivePeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  BillingPreviewUpdateNextCycleEffectivePeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewUpdateNextCycleEffectivePeriod$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BillingPreviewUpdateNextCycleEffectivePeriod' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateNextCycleLineItem$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateNextCycleLineItem,
  unknown
> = z.pipe(
  z.object({
    title: types.string(),
    description: types.string(),
    amount: types.number(),
    discounts: types.optional(
      z.array(
        z.lazy(() => BillingPreviewUpdateNextCycleDiscount$inboundSchema),
      ),
    ),
    plan_id: types.string(),
    total_quantity: types.number(),
    paid_quantity: types.number(),
    deferred_for_trial: types.optional(types.boolean()),
    effective_period: types.optional(
      z.lazy(() => BillingPreviewUpdateNextCycleEffectivePeriod$inboundSchema),
    ),
    is_base: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "total_quantity": "totalQuantity",
      "paid_quantity": "paidQuantity",
      "deferred_for_trial": "deferredForTrial",
      "effective_period": "effectivePeriod",
      "is_base": "isBase",
    });
  }),
);

export function billingPreviewUpdateNextCycleLineItemFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateNextCycleLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewUpdateNextCycleLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateNextCycleLineItem' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateNextCycle$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
    line_items: z.array(
      z.lazy(() => BillingPreviewUpdateNextCycleLineItem$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
      "line_items": "lineItems",
    });
  }),
);

export function billingPreviewUpdateNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewUpdateNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateNextCycle' from JSON`,
  );
}

/** @internal */
export const BillingPreviewUpdateResponse$inboundSchema: z.ZodMiniType<
  BillingPreviewUpdateResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(
      z.lazy(() => BillingPreviewUpdateLineItem$inboundSchema),
    ),
    total: types.number(),
    currency: types.string(),
    period_start: types.optional(types.number()),
    period_end: types.optional(types.number()),
    next_cycle: types.optional(
      z.lazy(() => BillingPreviewUpdateNextCycle$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "period_start": "periodStart",
      "period_end": "periodEnd",
      "next_cycle": "nextCycle",
    });
  }),
);

export function billingPreviewUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewUpdateResponse' from JSON`,
  );
}
