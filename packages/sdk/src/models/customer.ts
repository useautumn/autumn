/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

/**
 * The environment this customer was created in.
 */
export const CustomerEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment this customer was created in.
 */
export type CustomerEnv = OpenEnum<typeof CustomerEnv>;

/**
 * Current status of the subscription.
 */
export const Status = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Current status of the subscription.
 */
export type Status = OpenEnum<typeof Status>;

export type Subscription = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the subscribed plan.
   */
  planId: string;
  /**
   * Whether the plan was automatically enabled for the customer.
   */
  autoEnable: boolean;
  /**
   * Whether this is an add-on plan rather than a base subscription.
   */
  addOn: boolean;
  /**
   * Current status of the subscription.
   */
  status: Status;
  /**
   * Whether the subscription has overdue payments.
   */
  pastDue: boolean;
  /**
   * Timestamp when the subscription was canceled, or null if not canceled.
   */
  canceledAt: number | null;
  /**
   * Timestamp when the subscription will expire, or null if no expiry set.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the trial period ends, or null if not on trial.
   */
  trialEndsAt: number | null;
  /**
   * Timestamp when the subscription started.
   */
  startedAt: number;
  /**
   * Start timestamp of the current billing period.
   */
  currentPeriodStart: number | null;
  /**
   * End timestamp of the current billing period.
   */
  currentPeriodEnd: number | null;
  /**
   * Number of units of this subscription (for per-seat plans).
   */
  quantity: number;
};

export type Purchase = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the purchased plan.
   */
  planId: string;
  /**
   * Timestamp when the purchase expires, or null for lifetime access.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the purchase was made.
   */
  startedAt: number;
  /**
   * Number of units purchased.
   */
  quantity: number;
};

export const CustomerBalancesType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type CustomerBalancesType = OpenEnum<typeof CustomerBalancesType>;

export type CustomerCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type CustomerDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type CustomerFeature = {
  id: string;
  name: string;
  type: CustomerBalancesType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<CustomerCreditSchema> | undefined;
  display?: CustomerDisplay | undefined;
  archived: boolean;
};

export const CustomerIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type CustomerIntervalEnum = OpenEnum<typeof CustomerIntervalEnum>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type CustomerIntervalUnion = CustomerIntervalEnum | string;

export type CustomerReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: CustomerIntervalEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type CustomerTo = number | string;

export type CustomerTier = {
  to: number | string;
  amount: number;
};

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const CustomerBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type CustomerBillingMethod = OpenEnum<typeof CustomerBillingMethod>;

export type CustomerPrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<CustomerTier> | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: CustomerBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type Breakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: CustomerReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: CustomerPrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type CustomerRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type Balances = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: CustomerFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<Breakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<CustomerRollover> | undefined;
};

export type Invoice = {
  /**
   * Array of plan IDs included in this invoice
   */
  planIds: Array<string>;
  /**
   * The Stripe invoice ID
   */
  stripeId: string;
  /**
   * The status of the invoice
   */
  status: string;
  /**
   * The total amount of the invoice
   */
  total: number;
  /**
   * The currency code for the invoice
   */
  currency: string;
  /**
   * Timestamp when the invoice was created
   */
  createdAt: number;
  /**
   * URL to the Stripe-hosted invoice page
   */
  hostedInvoiceUrl?: string | null | undefined;
};

/**
 * The environment (sandbox/live)
 */
export const EntityEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment (sandbox/live)
 */
export type EntityEnv = OpenEnum<typeof EntityEnv>;

export type Entity = {
  autumnId?: string | undefined;
  /**
   * The unique identifier of the entity
   */
  id: string | null;
  /**
   * The name of the entity
   */
  name: string | null;
  /**
   * The customer ID this entity belongs to
   */
  customerId?: string | null | undefined;
  /**
   * The feature ID this entity belongs to
   */
  featureId?: string | null | undefined;
  /**
   * Unix timestamp when the entity was created
   */
  createdAt: number;
  /**
   * The environment (sandbox/live)
   */
  env: EntityEnv;
};

export type TrialsUsed = {
  planId: string;
  customerId: string;
  fingerprint?: string | null | undefined;
};

/**
 * The type of reward
 */
export const RewardsType = {
  PercentageDiscount: "percentage_discount",
  FixedDiscount: "fixed_discount",
  FreeProduct: "free_product",
  InvoiceCredits: "invoice_credits",
} as const;
/**
 * The type of reward
 */
export type RewardsType = OpenEnum<typeof RewardsType>;

/**
 * How long the discount lasts
 */
export const CustomerDurationType = {
  OneOff: "one_off",
  Months: "months",
  Forever: "forever",
} as const;
/**
 * How long the discount lasts
 */
export type CustomerDurationType = OpenEnum<typeof CustomerDurationType>;

export type Discount = {
  /**
   * The unique identifier for this discount
   */
  id: string;
  /**
   * The name of the discount or coupon
   */
  name: string;
  /**
   * The type of reward
   */
  type: RewardsType;
  /**
   * The discount value (percentage or fixed amount)
   */
  discountValue: number;
  /**
   * How long the discount lasts
   */
  durationType: CustomerDurationType;
  /**
   * Number of billing periods the discount applies for repeating durations
   */
  durationValue?: number | null | undefined;
  /**
   * The currency code for fixed amount discounts
   */
  currency?: string | null | undefined;
  /**
   * Timestamp when the discount becomes active
   */
  start?: number | null | undefined;
  /**
   * Timestamp when the discount expires
   */
  end?: number | null | undefined;
  /**
   * The Stripe subscription ID this discount is applied to
   */
  subscriptionId?: string | null | undefined;
  /**
   * Total amount saved from this discount
   */
  totalDiscountAmount?: number | null | undefined;
};

export type Rewards = {
  /**
   * Array of active discounts applied to the customer
   */
  discounts: Array<Discount>;
};

export type ReferralCustomer = {
  id: string;
  name?: string | null | undefined;
  email?: string | null | undefined;
};

export type Referral = {
  programId: string;
  customer: ReferralCustomer;
  rewardApplied: boolean;
  createdAt: number;
};

export type Customer = {
  /**
   * Your unique identifier for the customer.
   */
  id: string | null;
  /**
   * The name of the customer.
   */
  name: string | null;
  /**
   * The email address of the customer.
   */
  email: string | null;
  /**
   * Timestamp of customer creation in milliseconds since epoch.
   */
  createdAt: number;
  /**
   * A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID.
   */
  fingerprint: string | null;
  /**
   * Stripe customer ID.
   */
  stripeId: string | null;
  /**
   * The environment this customer was created in.
   */
  env: CustomerEnv;
  /**
   * The metadata for the customer.
   */
  metadata: { [k: string]: any };
  /**
   * Whether to send email receipts to the customer.
   */
  sendEmailReceipts: boolean;
  /**
   * Active and scheduled recurring plans that this customer has attached.
   */
  subscriptions: Array<Subscription>;
  /**
   * One-time purchases made by the customer.
   */
  purchases: Array<Purchase>;
  /**
   * Feature balances keyed by feature ID, showing usage limits and remaining amounts.
   */
  balances: { [k: string]: Balances };
  invoices?: Array<Invoice> | undefined;
  entities?: Array<Entity> | undefined;
  trialsUsed?: Array<TrialsUsed> | undefined;
  rewards?: Rewards | null | undefined;
  referrals?: Array<Referral> | undefined;
  paymentMethod?: any | null | undefined;
};

/** @internal */
export const CustomerEnv$inboundSchema: z.ZodMiniType<CustomerEnv, unknown> =
  openEnums.inboundSchema(CustomerEnv);

/** @internal */
export const Status$inboundSchema: z.ZodMiniType<Status, unknown> = openEnums
  .inboundSchema(Status);

/** @internal */
export const Subscription$inboundSchema: z.ZodMiniType<Subscription, unknown> =
  z.pipe(
    z.object({
      plan: types.optional(Plan$inboundSchema),
      plan_id: types.string(),
      auto_enable: types.boolean(),
      add_on: types.boolean(),
      status: Status$inboundSchema,
      past_due: types.boolean(),
      canceled_at: types.nullable(types.number()),
      expires_at: types.nullable(types.number()),
      trial_ends_at: types.nullable(types.number()),
      started_at: types.number(),
      current_period_start: types.nullable(types.number()),
      current_period_end: types.nullable(types.number()),
      quantity: types.number(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "plan_id": "planId",
        "auto_enable": "autoEnable",
        "add_on": "addOn",
        "past_due": "pastDue",
        "canceled_at": "canceledAt",
        "expires_at": "expiresAt",
        "trial_ends_at": "trialEndsAt",
        "started_at": "startedAt",
        "current_period_start": "currentPeriodStart",
        "current_period_end": "currentPeriodEnd",
      });
    }),
  );

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}

/** @internal */
export const Purchase$inboundSchema: z.ZodMiniType<Purchase, unknown> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function purchaseFromJSON(
  jsonString: string,
): SafeParseResult<Purchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Purchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Purchase' from JSON`,
  );
}

/** @internal */
export const CustomerBalancesType$inboundSchema: z.ZodMiniType<
  CustomerBalancesType,
  unknown
> = openEnums.inboundSchema(CustomerBalancesType);

/** @internal */
export const CustomerCreditSchema$inboundSchema: z.ZodMiniType<
  CustomerCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function customerCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CustomerCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerCreditSchema' from JSON`,
  );
}

/** @internal */
export const CustomerDisplay$inboundSchema: z.ZodMiniType<
  CustomerDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function customerDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CustomerDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerDisplay' from JSON`,
  );
}

/** @internal */
export const CustomerFeature$inboundSchema: z.ZodMiniType<
  CustomerFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: CustomerBalancesType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => CustomerCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => CustomerDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function customerFeatureFromJSON(
  jsonString: string,
): SafeParseResult<CustomerFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerFeature' from JSON`,
  );
}

/** @internal */
export const CustomerIntervalEnum$inboundSchema: z.ZodMiniType<
  CustomerIntervalEnum,
  unknown
> = openEnums.inboundSchema(CustomerIntervalEnum);

/** @internal */
export const CustomerIntervalUnion$inboundSchema: z.ZodMiniType<
  CustomerIntervalUnion,
  unknown
> = smartUnion([CustomerIntervalEnum$inboundSchema, types.string()]);

export function customerIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<CustomerIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerIntervalUnion' from JSON`,
  );
}

/** @internal */
export const CustomerReset$inboundSchema: z.ZodMiniType<
  CustomerReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([CustomerIntervalEnum$inboundSchema, types.string()]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function customerResetFromJSON(
  jsonString: string,
): SafeParseResult<CustomerReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerReset' from JSON`,
  );
}

/** @internal */
export const CustomerTo$inboundSchema: z.ZodMiniType<CustomerTo, unknown> =
  smartUnion([types.number(), types.string()]);

export function customerToFromJSON(
  jsonString: string,
): SafeParseResult<CustomerTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerTo' from JSON`,
  );
}

/** @internal */
export const CustomerTier$inboundSchema: z.ZodMiniType<CustomerTier, unknown> =
  z.object({
    to: smartUnion([types.number(), types.string()]),
    amount: types.number(),
  });

export function customerTierFromJSON(
  jsonString: string,
): SafeParseResult<CustomerTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerTier' from JSON`,
  );
}

/** @internal */
export const CustomerBillingMethod$inboundSchema: z.ZodMiniType<
  CustomerBillingMethod,
  unknown
> = openEnums.inboundSchema(CustomerBillingMethod);

/** @internal */
export const CustomerPrice$inboundSchema: z.ZodMiniType<
  CustomerPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(z.array(z.lazy(() => CustomerTier$inboundSchema))),
    billing_units: types.number(),
    billing_method: CustomerBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function customerPriceFromJSON(
  jsonString: string,
): SafeParseResult<CustomerPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerPrice' from JSON`,
  );
}

/** @internal */
export const Breakdown$inboundSchema: z.ZodMiniType<Breakdown, unknown> = z
  .pipe(
    z.object({
      id: z._default(types.string(), ""),
      plan_id: types.nullable(types.string()),
      included_grant: types.number(),
      prepaid_grant: types.number(),
      remaining: types.number(),
      usage: types.number(),
      unlimited: types.boolean(),
      reset: types.nullable(z.lazy(() => CustomerReset$inboundSchema)),
      price: types.nullable(z.lazy(() => CustomerPrice$inboundSchema)),
      expires_at: types.nullable(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "plan_id": "planId",
        "included_grant": "includedGrant",
        "prepaid_grant": "prepaidGrant",
        "expires_at": "expiresAt",
      });
    }),
  );

export function breakdownFromJSON(
  jsonString: string,
): SafeParseResult<Breakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Breakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Breakdown' from JSON`,
  );
}

/** @internal */
export const CustomerRollover$inboundSchema: z.ZodMiniType<
  CustomerRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function customerRolloverFromJSON(
  jsonString: string,
): SafeParseResult<CustomerRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerRollover' from JSON`,
  );
}

/** @internal */
export const Balances$inboundSchema: z.ZodMiniType<Balances, unknown> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => CustomerFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(z.array(z.lazy(() => Breakdown$inboundSchema))),
    rollovers: types.optional(z.array(z.lazy(() =>
      CustomerRollover$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function balancesFromJSON(
  jsonString: string,
): SafeParseResult<Balances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Balances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Balances' from JSON`,
  );
}

/** @internal */
export const Invoice$inboundSchema: z.ZodMiniType<Invoice, unknown> = z.pipe(
  z.object({
    plan_ids: z.array(types.string()),
    stripe_id: types.string(),
    status: types.string(),
    total: types.number(),
    currency: types.string(),
    created_at: types.number(),
    hosted_invoice_url: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_ids": "planIds",
      "stripe_id": "stripeId",
      "created_at": "createdAt",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function invoiceFromJSON(
  jsonString: string,
): SafeParseResult<Invoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Invoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Invoice' from JSON`,
  );
}

/** @internal */
export const EntityEnv$inboundSchema: z.ZodMiniType<EntityEnv, unknown> =
  openEnums.inboundSchema(EntityEnv);

/** @internal */
export const Entity$inboundSchema: z.ZodMiniType<Entity, unknown> = z.pipe(
  z.object({
    autumn_id: types.optional(types.string()),
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    customer_id: z.optional(z.nullable(types.string())),
    feature_id: z.optional(z.nullable(types.string())),
    created_at: types.number(),
    env: EntityEnv$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "autumn_id": "autumnId",
      "customer_id": "customerId",
      "feature_id": "featureId",
      "created_at": "createdAt",
    });
  }),
);

export function entityFromJSON(
  jsonString: string,
): SafeParseResult<Entity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entity' from JSON`,
  );
}

/** @internal */
export const TrialsUsed$inboundSchema: z.ZodMiniType<TrialsUsed, unknown> = z
  .pipe(
    z.object({
      plan_id: types.string(),
      customer_id: types.string(),
      fingerprint: z.optional(z.nullable(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "plan_id": "planId",
        "customer_id": "customerId",
      });
    }),
  );

export function trialsUsedFromJSON(
  jsonString: string,
): SafeParseResult<TrialsUsed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrialsUsed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrialsUsed' from JSON`,
  );
}

/** @internal */
export const RewardsType$inboundSchema: z.ZodMiniType<RewardsType, unknown> =
  openEnums.inboundSchema(RewardsType);

/** @internal */
export const CustomerDurationType$inboundSchema: z.ZodMiniType<
  CustomerDurationType,
  unknown
> = openEnums.inboundSchema(CustomerDurationType);

/** @internal */
export const Discount$inboundSchema: z.ZodMiniType<Discount, unknown> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: RewardsType$inboundSchema,
    discount_value: types.number(),
    duration_type: CustomerDurationType$inboundSchema,
    duration_value: z.optional(z.nullable(types.number())),
    currency: z.optional(z.nullable(types.string())),
    start: z.optional(z.nullable(types.number())),
    end: z.optional(z.nullable(types.number())),
    subscription_id: z.optional(z.nullable(types.string())),
    total_discount_amount: z.optional(z.nullable(types.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "discount_value": "discountValue",
      "duration_type": "durationType",
      "duration_value": "durationValue",
      "subscription_id": "subscriptionId",
      "total_discount_amount": "totalDiscountAmount",
    });
  }),
);

export function discountFromJSON(
  jsonString: string,
): SafeParseResult<Discount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Discount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Discount' from JSON`,
  );
}

/** @internal */
export const Rewards$inboundSchema: z.ZodMiniType<Rewards, unknown> = z.object({
  discounts: z.array(z.lazy(() => Discount$inboundSchema)),
});

export function rewardsFromJSON(
  jsonString: string,
): SafeParseResult<Rewards, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rewards$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rewards' from JSON`,
  );
}

/** @internal */
export const ReferralCustomer$inboundSchema: z.ZodMiniType<
  ReferralCustomer,
  unknown
> = z.object({
  id: types.string(),
  name: z.optional(z.nullable(types.string())),
  email: z.optional(z.nullable(types.string())),
});

export function referralCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ReferralCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReferralCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReferralCustomer' from JSON`,
  );
}

/** @internal */
export const Referral$inboundSchema: z.ZodMiniType<Referral, unknown> = z.pipe(
  z.object({
    program_id: types.string(),
    customer: z.lazy(() => ReferralCustomer$inboundSchema),
    reward_applied: types.boolean(),
    created_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "program_id": "programId",
      "reward_applied": "rewardApplied",
      "created_at": "createdAt",
    });
  }),
);

export function referralFromJSON(
  jsonString: string,
): SafeParseResult<Referral, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Referral$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Referral' from JSON`,
  );
}

/** @internal */
export const Customer$inboundSchema: z.ZodMiniType<Customer, unknown> = z.pipe(
  z.object({
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    email: types.nullable(types.string()),
    created_at: types.number(),
    fingerprint: types.nullable(types.string()),
    stripe_id: types.nullable(types.string()),
    env: CustomerEnv$inboundSchema,
    metadata: z.record(z.string(), z.any()),
    send_email_receipts: types.boolean(),
    subscriptions: z.array(z.lazy(() => Subscription$inboundSchema)),
    purchases: z.array(z.lazy(() => Purchase$inboundSchema)),
    balances: z.record(z.string(), z.lazy(() => Balances$inboundSchema)),
    invoices: types.optional(z.array(z.lazy(() => Invoice$inboundSchema))),
    entities: types.optional(z.array(z.lazy(() => Entity$inboundSchema))),
    trials_used: types.optional(
      z.array(z.lazy(() => TrialsUsed$inboundSchema)),
    ),
    rewards: z.optional(z.nullable(z.lazy(() => Rewards$inboundSchema))),
    referrals: types.optional(z.array(z.lazy(() => Referral$inboundSchema))),
    payment_method: z.optional(z.nullable(z.any())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "stripe_id": "stripeId",
      "send_email_receipts": "sendEmailReceipts",
      "trials_used": "trialsUsed",
      "payment_method": "paymentMethod",
    });
  }),
);

export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}
