/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import {
  CustomerData,
  CustomerData$Outbound,
  CustomerData$outboundSchema,
} from "./customer-data.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type MultiAttachGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const MultiAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type MultiAttachPriceInterval = ClosedEnum<
  typeof MultiAttachPriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type MultiAttachBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: MultiAttachPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const MultiAttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type MultiAttachResetInterval = ClosedEnum<
  typeof MultiAttachResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type MultiAttachReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: MultiAttachResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type MultiAttachTo = number | string;

export type MultiAttachTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const MultiAttachTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type MultiAttachTierBehavior = ClosedEnum<
  typeof MultiAttachTierBehavior
>;

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const MultiAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type MultiAttachItemPriceInterval = ClosedEnum<
  typeof MultiAttachItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const MultiAttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type MultiAttachBillingMethod = ClosedEnum<
  typeof MultiAttachBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type MultiAttachPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing.  Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<MultiAttachTier> | undefined;
  tierBehavior?: MultiAttachTierBehavior | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: MultiAttachItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: MultiAttachBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const MultiAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type MultiAttachOnIncrease = ClosedEnum<typeof MultiAttachOnIncrease>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const MultiAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type MultiAttachOnDecrease = ClosedEnum<typeof MultiAttachOnDecrease>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type MultiAttachProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: MultiAttachOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: MultiAttachOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const MultiAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type MultiAttachExpiryDurationType = ClosedEnum<
  typeof MultiAttachExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type MultiAttachRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: MultiAttachExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type MultiAttachPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: MultiAttachReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: MultiAttachPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: MultiAttachProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: MultiAttachRollover | undefined;
};

/**
 * Customize the plan to attach. Can override the price or items.
 */
export type MultiAttachCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: MultiAttachBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<MultiAttachPlanItem> | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type MultiAttachFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

export type MultiAttachPlan = {
  /**
   * The ID of the plan to attach.
   */
  planId: string;
  /**
   * Customize the plan to attach. Can override the price or items.
   */
  customize?: MultiAttachCustomize | undefined;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature.
   */
  featureQuantities?: Array<MultiAttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const MultiAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type MultiAttachDurationType = ClosedEnum<
  typeof MultiAttachDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type MultiAttachFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: MultiAttachDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
 */
export type MultiAttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type MultiAttachAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

/**
 * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
 */
export const MultiAttachRedirectMode = {
  Always: "always",
  IfRequired: "if_required",
  Never: "never",
} as const;
/**
 * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
 */
export type MultiAttachRedirectMode = ClosedEnum<
  typeof MultiAttachRedirectMode
>;

export type MultiAttachEntityData = {
  /**
   * The feature ID that this entity is associated with
   */
  featureId: string;
  /**
   * Name of the entity
   */
  name?: string | undefined;
};

export type MultiAttachParams = {
  /**
   * The ID of the customer to attach the plans to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plans to.
   */
  entityId?: string | undefined;
  /**
   * The list of plans to attach to the customer.
   */
  plans: Array<MultiAttachPlan>;
  /**
   * Free trial configuration applied to all plans. Pass an object to set a custom trial, or null to remove any trial.
   */
  freeTrial?: MultiAttachFreeTrialParams | null | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately.
   */
  invoiceMode?: MultiAttachInvoiceMode | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<MultiAttachAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Additional parameters to pass into the creation of the Stripe checkout session.
   */
  checkoutSessionParams?: { [k: string]: any } | undefined;
  /**
   * Controls when to return a checkout URL. 'always' returns a URL even if payment succeeds, 'if_required' only when payment action is needed, 'never' disables redirects.
   */
  redirectMode?: MultiAttachRedirectMode | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * Customer details to set when creating a customer
   */
  customerData?: CustomerData | undefined;
  entityData?: MultiAttachEntityData | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type MultiAttachInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const MultiAttachCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type MultiAttachCode = OpenEnum<typeof MultiAttachCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type MultiAttachRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: MultiAttachCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type MultiAttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: MultiAttachInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: MultiAttachRequiredAction | undefined;
};

/** @internal */
export const MultiAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachPriceInterval
> = z.enum(MultiAttachPriceInterval);

/** @internal */
export type MultiAttachBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const MultiAttachBasePrice$outboundSchema: z.ZodMiniType<
  MultiAttachBasePrice$Outbound,
  MultiAttachBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: MultiAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function multiAttachBasePriceToJSON(
  multiAttachBasePrice: MultiAttachBasePrice,
): string {
  return JSON.stringify(
    MultiAttachBasePrice$outboundSchema.parse(multiAttachBasePrice),
  );
}

/** @internal */
export const MultiAttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachResetInterval
> = z.enum(MultiAttachResetInterval);

/** @internal */
export type MultiAttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const MultiAttachReset$outboundSchema: z.ZodMiniType<
  MultiAttachReset$Outbound,
  MultiAttachReset
> = z.pipe(
  z.object({
    interval: MultiAttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function multiAttachResetToJSON(
  multiAttachReset: MultiAttachReset,
): string {
  return JSON.stringify(
    MultiAttachReset$outboundSchema.parse(multiAttachReset),
  );
}

/** @internal */
export type MultiAttachTo$Outbound = number | string;

/** @internal */
export const MultiAttachTo$outboundSchema: z.ZodMiniType<
  MultiAttachTo$Outbound,
  MultiAttachTo
> = smartUnion([z.number(), z.string()]);

export function multiAttachToToJSON(multiAttachTo: MultiAttachTo): string {
  return JSON.stringify(MultiAttachTo$outboundSchema.parse(multiAttachTo));
}

/** @internal */
export type MultiAttachTier$Outbound = {
  to: number | string;
  amount: number;
  flat_amount?: number | null | undefined;
};

/** @internal */
export const MultiAttachTier$outboundSchema: z.ZodMiniType<
  MultiAttachTier$Outbound,
  MultiAttachTier
> = z.pipe(
  z.object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
    flatAmount: z.optional(z.nullable(z.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      flatAmount: "flat_amount",
    });
  }),
);

export function multiAttachTierToJSON(
  multiAttachTier: MultiAttachTier,
): string {
  return JSON.stringify(MultiAttachTier$outboundSchema.parse(multiAttachTier));
}

/** @internal */
export const MultiAttachTierBehavior$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachTierBehavior
> = z.enum(MultiAttachTierBehavior);

/** @internal */
export const MultiAttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachItemPriceInterval
> = z.enum(MultiAttachItemPriceInterval);

/** @internal */
export const MultiAttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachBillingMethod
> = z.enum(MultiAttachBillingMethod);

/** @internal */
export type MultiAttachPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<MultiAttachTier$Outbound> | undefined;
  tier_behavior?: string | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const MultiAttachPrice$outboundSchema: z.ZodMiniType<
  MultiAttachPrice$Outbound,
  MultiAttachPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => MultiAttachTier$outboundSchema))),
    tierBehavior: z.optional(MultiAttachTierBehavior$outboundSchema),
    interval: MultiAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: MultiAttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      tierBehavior: "tier_behavior",
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function multiAttachPriceToJSON(
  multiAttachPrice: MultiAttachPrice,
): string {
  return JSON.stringify(
    MultiAttachPrice$outboundSchema.parse(multiAttachPrice),
  );
}

/** @internal */
export const MultiAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachOnIncrease
> = z.enum(MultiAttachOnIncrease);

/** @internal */
export const MultiAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachOnDecrease
> = z.enum(MultiAttachOnDecrease);

/** @internal */
export type MultiAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const MultiAttachProration$outboundSchema: z.ZodMiniType<
  MultiAttachProration$Outbound,
  MultiAttachProration
> = z.pipe(
  z.object({
    onIncrease: MultiAttachOnIncrease$outboundSchema,
    onDecrease: MultiAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function multiAttachProrationToJSON(
  multiAttachProration: MultiAttachProration,
): string {
  return JSON.stringify(
    MultiAttachProration$outboundSchema.parse(multiAttachProration),
  );
}

/** @internal */
export const MultiAttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachExpiryDurationType
> = z.enum(MultiAttachExpiryDurationType);

/** @internal */
export type MultiAttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const MultiAttachRollover$outboundSchema: z.ZodMiniType<
  MultiAttachRollover$Outbound,
  MultiAttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: MultiAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function multiAttachRolloverToJSON(
  multiAttachRollover: MultiAttachRollover,
): string {
  return JSON.stringify(
    MultiAttachRollover$outboundSchema.parse(multiAttachRollover),
  );
}

/** @internal */
export type MultiAttachPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: MultiAttachReset$Outbound | undefined;
  price?: MultiAttachPrice$Outbound | undefined;
  proration?: MultiAttachProration$Outbound | undefined;
  rollover?: MultiAttachRollover$Outbound | undefined;
};

/** @internal */
export const MultiAttachPlanItem$outboundSchema: z.ZodMiniType<
  MultiAttachPlanItem$Outbound,
  MultiAttachPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => MultiAttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => MultiAttachPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => MultiAttachProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => MultiAttachRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function multiAttachPlanItemToJSON(
  multiAttachPlanItem: MultiAttachPlanItem,
): string {
  return JSON.stringify(
    MultiAttachPlanItem$outboundSchema.parse(multiAttachPlanItem),
  );
}

/** @internal */
export type MultiAttachCustomize$Outbound = {
  price?: MultiAttachBasePrice$Outbound | null | undefined;
  items?: Array<MultiAttachPlanItem$Outbound> | undefined;
};

/** @internal */
export const MultiAttachCustomize$outboundSchema: z.ZodMiniType<
  MultiAttachCustomize$Outbound,
  MultiAttachCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => MultiAttachBasePrice$outboundSchema)),
  ),
  items: z.optional(z.array(z.lazy(() => MultiAttachPlanItem$outboundSchema))),
});

export function multiAttachCustomizeToJSON(
  multiAttachCustomize: MultiAttachCustomize,
): string {
  return JSON.stringify(
    MultiAttachCustomize$outboundSchema.parse(multiAttachCustomize),
  );
}

/** @internal */
export type MultiAttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const MultiAttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  MultiAttachFeatureQuantity$Outbound,
  MultiAttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function multiAttachFeatureQuantityToJSON(
  multiAttachFeatureQuantity: MultiAttachFeatureQuantity,
): string {
  return JSON.stringify(
    MultiAttachFeatureQuantity$outboundSchema.parse(multiAttachFeatureQuantity),
  );
}

/** @internal */
export type MultiAttachPlan$Outbound = {
  plan_id: string;
  customize?: MultiAttachCustomize$Outbound | undefined;
  feature_quantities?: Array<MultiAttachFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
};

/** @internal */
export const MultiAttachPlan$outboundSchema: z.ZodMiniType<
  MultiAttachPlan$Outbound,
  MultiAttachPlan
> = z.pipe(
  z.object({
    planId: z.string(),
    customize: z.optional(z.lazy(() => MultiAttachCustomize$outboundSchema)),
    featureQuantities: z.optional(
      z.array(z.lazy(() => MultiAttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      planId: "plan_id",
      featureQuantities: "feature_quantities",
    });
  }),
);

export function multiAttachPlanToJSON(
  multiAttachPlan: MultiAttachPlan,
): string {
  return JSON.stringify(MultiAttachPlan$outboundSchema.parse(multiAttachPlan));
}

/** @internal */
export const MultiAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachDurationType
> = z.enum(MultiAttachDurationType);

/** @internal */
export type MultiAttachFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const MultiAttachFreeTrialParams$outboundSchema: z.ZodMiniType<
  MultiAttachFreeTrialParams$Outbound,
  MultiAttachFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(MultiAttachDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function multiAttachFreeTrialParamsToJSON(
  multiAttachFreeTrialParams: MultiAttachFreeTrialParams,
): string {
  return JSON.stringify(
    MultiAttachFreeTrialParams$outboundSchema.parse(multiAttachFreeTrialParams),
  );
}

/** @internal */
export type MultiAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const MultiAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  MultiAttachInvoiceMode$Outbound,
  MultiAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function multiAttachInvoiceModeToJSON(
  multiAttachInvoiceMode: MultiAttachInvoiceMode,
): string {
  return JSON.stringify(
    MultiAttachInvoiceMode$outboundSchema.parse(multiAttachInvoiceMode),
  );
}

/** @internal */
export type MultiAttachAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const MultiAttachAttachDiscount$outboundSchema: z.ZodMiniType<
  MultiAttachAttachDiscount$Outbound,
  MultiAttachAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function multiAttachAttachDiscountToJSON(
  multiAttachAttachDiscount: MultiAttachAttachDiscount,
): string {
  return JSON.stringify(
    MultiAttachAttachDiscount$outboundSchema.parse(multiAttachAttachDiscount),
  );
}

/** @internal */
export const MultiAttachRedirectMode$outboundSchema: z.ZodMiniEnum<
  typeof MultiAttachRedirectMode
> = z.enum(MultiAttachRedirectMode);

/** @internal */
export type MultiAttachEntityData$Outbound = {
  feature_id: string;
  name?: string | undefined;
};

/** @internal */
export const MultiAttachEntityData$outboundSchema: z.ZodMiniType<
  MultiAttachEntityData$Outbound,
  MultiAttachEntityData
> = z.pipe(
  z.object({
    featureId: z.string(),
    name: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function multiAttachEntityDataToJSON(
  multiAttachEntityData: MultiAttachEntityData,
): string {
  return JSON.stringify(
    MultiAttachEntityData$outboundSchema.parse(multiAttachEntityData),
  );
}

/** @internal */
export type MultiAttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plans: Array<MultiAttachPlan$Outbound>;
  free_trial?: MultiAttachFreeTrialParams$Outbound | null | undefined;
  invoice_mode?: MultiAttachInvoiceMode$Outbound | undefined;
  discounts?: Array<MultiAttachAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  checkout_session_params?: { [k: string]: any } | undefined;
  redirect_mode: string;
  new_billing_subscription?: boolean | undefined;
  customer_data?: CustomerData$Outbound | undefined;
  entity_data?: MultiAttachEntityData$Outbound | undefined;
};

/** @internal */
export const MultiAttachParams$outboundSchema: z.ZodMiniType<
  MultiAttachParams$Outbound,
  MultiAttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    plans: z.array(z.lazy(() => MultiAttachPlan$outboundSchema)),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => MultiAttachFreeTrialParams$outboundSchema)),
    ),
    invoiceMode: z.optional(
      z.lazy(() => MultiAttachInvoiceMode$outboundSchema),
    ),
    discounts: z.optional(
      z.array(z.lazy(() => MultiAttachAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    checkoutSessionParams: z.optional(z.record(z.string(), z.any())),
    redirectMode: z._default(
      MultiAttachRedirectMode$outboundSchema,
      "if_required",
    ),
    newBillingSubscription: z.optional(z.boolean()),
    customerData: z.optional(CustomerData$outboundSchema),
    entityData: z.optional(z.lazy(() => MultiAttachEntityData$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      freeTrial: "free_trial",
      invoiceMode: "invoice_mode",
      successUrl: "success_url",
      checkoutSessionParams: "checkout_session_params",
      redirectMode: "redirect_mode",
      newBillingSubscription: "new_billing_subscription",
      customerData: "customer_data",
      entityData: "entity_data",
    });
  }),
);

export function multiAttachParamsToJSON(
  multiAttachParams: MultiAttachParams,
): string {
  return JSON.stringify(
    MultiAttachParams$outboundSchema.parse(multiAttachParams),
  );
}

/** @internal */
export const MultiAttachInvoice$inboundSchema: z.ZodMiniType<
  MultiAttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function multiAttachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<MultiAttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MultiAttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MultiAttachInvoice' from JSON`,
  );
}

/** @internal */
export const MultiAttachCode$inboundSchema: z.ZodMiniType<
  MultiAttachCode,
  unknown
> = openEnums.inboundSchema(MultiAttachCode);

/** @internal */
export const MultiAttachRequiredAction$inboundSchema: z.ZodMiniType<
  MultiAttachRequiredAction,
  unknown
> = z.object({
  code: MultiAttachCode$inboundSchema,
  reason: types.string(),
});

export function multiAttachRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<MultiAttachRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MultiAttachRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MultiAttachRequiredAction' from JSON`,
  );
}

/** @internal */
export const MultiAttachResponse$inboundSchema: z.ZodMiniType<
  MultiAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => MultiAttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => MultiAttachRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function multiAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<MultiAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MultiAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MultiAttachResponse' from JSON`,
  );
}
