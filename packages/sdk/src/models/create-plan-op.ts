/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type CreatePlanGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const CreatePlanPriceIntervalRequest = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type CreatePlanPriceIntervalRequest = ClosedEnum<
  typeof CreatePlanPriceIntervalRequest
>;

/**
 * Base recurring price for the plan. Omit for free or usage-only plans.
 */
export type CreatePlanPriceRequest = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: CreatePlanPriceIntervalRequest;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const CreatePlanResetIntervalRequest = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type CreatePlanResetIntervalRequest = ClosedEnum<
  typeof CreatePlanResetIntervalRequest
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type CreatePlanResetRequest = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: CreatePlanResetIntervalRequest;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type CreatePlanToRequest = number | string;

export type CreatePlanTierRequest = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const CreatePlanItemPriceIntervalRequest = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type CreatePlanItemPriceIntervalRequest = ClosedEnum<
  typeof CreatePlanItemPriceIntervalRequest
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const CreatePlanBillingMethodRequest = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type CreatePlanBillingMethodRequest = ClosedEnum<
  typeof CreatePlanBillingMethodRequest
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type CreatePlanItemPriceRequest = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<CreatePlanTierRequest> | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: CreatePlanItemPriceIntervalRequest;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: CreatePlanBillingMethodRequest;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const CreatePlanOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type CreatePlanOnIncrease = ClosedEnum<typeof CreatePlanOnIncrease>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const CreatePlanOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type CreatePlanOnDecrease = ClosedEnum<typeof CreatePlanOnDecrease>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type CreatePlanProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: CreatePlanOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: CreatePlanOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const CreatePlanExpiryDurationTypeRequest = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type CreatePlanExpiryDurationTypeRequest = ClosedEnum<
  typeof CreatePlanExpiryDurationTypeRequest
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type CreatePlanRolloverRequest = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: CreatePlanExpiryDurationTypeRequest;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type CreatePlanPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: CreatePlanResetRequest | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: CreatePlanItemPriceRequest | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: CreatePlanProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: CreatePlanRolloverRequest | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const CreatePlanDurationTypeRequest = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type CreatePlanDurationTypeRequest = ClosedEnum<
  typeof CreatePlanDurationTypeRequest
>;

/**
 * Free trial configuration. Customers can try this plan before being charged.
 */
export type FreeTrialRequest = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: CreatePlanDurationTypeRequest | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

export type CreatePlanParams = {
  /**
   * The ID of the plan to create.
   */
  planId: string;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group?: string | undefined;
  /**
   * Display name of the plan.
   */
  name: string;
  /**
   * Optional description of the plan.
   */
  description?: string | null | undefined;
  /**
   * If true, this plan can be attached alongside other plans. Otherwise, attaching replaces existing plans in the same group.
   */
  addOn?: boolean | undefined;
  /**
   * If true, plan is automatically attached when a customer is created. Use for free tiers.
   */
  autoEnable?: boolean | undefined;
  /**
   * Base recurring price for the plan. Omit for free or usage-only plans.
   */
  price?: CreatePlanPriceRequest | undefined;
  /**
   * Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
   */
  items?: Array<CreatePlanPlanItem> | undefined;
  /**
   * Free trial configuration. Customers can try this plan before being charged.
   */
  freeTrial?: FreeTrialRequest | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const CreatePlanPriceIntervalResponse = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type CreatePlanPriceIntervalResponse = OpenEnum<
  typeof CreatePlanPriceIntervalResponse
>;

/**
 * Display text for showing this price in pricing pages.
 */
export type CreatePlanPriceDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

export type CreatePlanPriceResponse = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: CreatePlanPriceIntervalResponse;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Display text for showing this price in pricing pages.
   */
  display?: CreatePlanPriceDisplay | undefined;
};

/**
 * The type of the feature
 */
export const CreatePlanType = {
  Static: "static",
  Boolean: "boolean",
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature
 */
export type CreatePlanType = OpenEnum<typeof CreatePlanType>;

export type CreatePlanFeatureDisplay = {
  /**
   * The singular display name for the feature.
   */
  singular: string;
  /**
   * The plural display name for the feature.
   */
  plural: string;
};

export type CreatePlanCreditSchema = {
  /**
   * The ID of the metered feature (should be a single_use feature).
   */
  meteredFeatureId: string;
  /**
   * The credit cost of the metered feature.
   */
  creditCost: number;
};

/**
 * The full feature object if expanded.
 */
export type CreatePlanFeature = {
  /**
   * The ID of the feature, used to refer to it in other API calls like /track or /check.
   */
  id: string;
  /**
   * The name of the feature.
   */
  name?: string | null | undefined;
  /**
   * The type of the feature
   */
  type: CreatePlanType;
  /**
   * Singular and plural display names for the feature.
   */
  display?: CreatePlanFeatureDisplay | null | undefined;
  /**
   * Credit cost schema for credit system features.
   */
  creditSchema?: Array<CreatePlanCreditSchema> | null | undefined;
  /**
   * Whether or not the feature is archived.
   */
  archived?: boolean | null | undefined;
};

/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export const CreatePlanResetIntervalResponse = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export type CreatePlanResetIntervalResponse = OpenEnum<
  typeof CreatePlanResetIntervalResponse
>;

export type CreatePlanResetResponse = {
  /**
   * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
   */
  interval: CreatePlanResetIntervalResponse;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type CreatePlanToResponse = number | string;

export type CreatePlanTierResponse = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export const CreatePlanPriceItemIntervalResponse = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export type CreatePlanPriceItemIntervalResponse = OpenEnum<
  typeof CreatePlanPriceItemIntervalResponse
>;

/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export const CreatePlanBillingMethodResponse = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export type CreatePlanBillingMethodResponse = OpenEnum<
  typeof CreatePlanBillingMethodResponse
>;

export type CreatePlanItemPriceResponse = {
  /**
   * Price per billing_units after included usage is consumed. Mutually exclusive with tiers.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required.
   */
  tiers?: Array<CreatePlanTierResponse> | undefined;
  /**
   * Billing interval for this price. For consumable features, should match reset.interval.
   */
  interval: CreatePlanPriceItemIntervalResponse;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200).
   */
  billingUnits: number;
  /**
   * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
   */
  billingMethod: CreatePlanBillingMethodResponse;
  /**
   * Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit.
   */
  maxPurchase: number | null;
};

/**
 * Display text for showing this item in pricing pages.
 */
export type CreatePlanItemDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

/**
 * When rolled over units expire.
 */
export const CreatePlanExpiryDurationTypeResponse = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type CreatePlanExpiryDurationTypeResponse = OpenEnum<
  typeof CreatePlanExpiryDurationTypeResponse
>;

/**
 * Rollover configuration for unused units. If set, unused included units roll over to the next period.
 */
export type CreatePlanRolloverResponse = {
  /**
   * Maximum rollover units. Null for unlimited rollover.
   */
  max: number | null;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: CreatePlanExpiryDurationTypeResponse;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

export type CreatePlanItem = {
  /**
   * The ID of the feature this item configures.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: CreatePlanFeature | undefined;
  /**
   * Number of free units included. For consumable features, balance resets to this number each interval.
   */
  included: number;
  /**
   * Whether the customer has unlimited access to this feature.
   */
  unlimited: boolean;
  /**
   * Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles.
   */
  reset: CreatePlanResetResponse | null;
  /**
   * Pricing configuration for usage beyond included units. Null if feature is entirely free.
   */
  price: CreatePlanItemPriceResponse | null;
  /**
   * Display text for showing this item in pricing pages.
   */
  display?: CreatePlanItemDisplay | undefined;
  /**
   * Rollover configuration for unused units. If set, unused included units roll over to the next period.
   */
  rollover?: CreatePlanRolloverResponse | undefined;
};

/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export const CreatePlanDurationTypeResponse = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export type CreatePlanDurationTypeResponse = OpenEnum<
  typeof CreatePlanDurationTypeResponse
>;

/**
 * Free trial configuration. If set, new customers can try this plan before being charged.
 */
export type CreatePlanFreeTrialResponse = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial duration ('day', 'month', 'year').
   */
  durationType: CreatePlanDurationTypeResponse;
  /**
   * Whether a payment method is required to start the trial. If true, customer will be charged after trial ends.
   */
  cardRequired: boolean;
};

/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export const CreatePlanEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export type CreatePlanEnv = OpenEnum<typeof CreatePlanEnv>;

/**
 * A plan defines a set of features, pricing, and entitlements that can be attached to customers.
 */
export type CreatePlanResponse = {
  /**
   * Unique identifier for the plan.
   */
  id: string;
  /**
   * Display name of the plan.
   */
  name: string;
  /**
   * Optional description of the plan.
   */
  description: string | null;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group: string | null;
  /**
   * Version number of the plan. Incremented when plan configuration changes.
   */
  version: number;
  /**
   * Whether this is an add-on plan that can be attached alongside a main plan.
   */
  addOn: boolean;
  /**
   * If true, this plan is automatically attached when a customer is created. Used for free plans.
   */
  autoEnable: boolean;
  /**
   * Base recurring price for the plan. Null for free plans or usage-only plans.
   */
  price: CreatePlanPriceResponse | null;
  /**
   * Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature.
   */
  items: Array<CreatePlanItem>;
  /**
   * Free trial configuration. If set, new customers can try this plan before being charged.
   */
  freeTrial?: CreatePlanFreeTrialResponse | undefined;
  /**
   * Unix timestamp (ms) when the plan was created.
   */
  createdAt: number;
  /**
   * Environment this plan belongs to ('sandbox' or 'live').
   */
  env: CreatePlanEnv;
  /**
   * Whether the plan is archived. Archived plans cannot be attached to new customers.
   */
  archived: boolean;
  /**
   * If this is a variant, the ID of the base plan it was created from.
   */
  baseVariantId: string | null;
};

/** @internal */
export const CreatePlanPriceIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanPriceIntervalRequest
> = z.enum(CreatePlanPriceIntervalRequest);

/** @internal */
export type CreatePlanPriceRequest$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const CreatePlanPriceRequest$outboundSchema: z.ZodMiniType<
  CreatePlanPriceRequest$Outbound,
  CreatePlanPriceRequest
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: CreatePlanPriceIntervalRequest$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function createPlanPriceRequestToJSON(
  createPlanPriceRequest: CreatePlanPriceRequest,
): string {
  return JSON.stringify(
    CreatePlanPriceRequest$outboundSchema.parse(createPlanPriceRequest),
  );
}

/** @internal */
export const CreatePlanResetIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanResetIntervalRequest
> = z.enum(CreatePlanResetIntervalRequest);

/** @internal */
export type CreatePlanResetRequest$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const CreatePlanResetRequest$outboundSchema: z.ZodMiniType<
  CreatePlanResetRequest$Outbound,
  CreatePlanResetRequest
> = z.pipe(
  z.object({
    interval: CreatePlanResetIntervalRequest$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function createPlanResetRequestToJSON(
  createPlanResetRequest: CreatePlanResetRequest,
): string {
  return JSON.stringify(
    CreatePlanResetRequest$outboundSchema.parse(createPlanResetRequest),
  );
}

/** @internal */
export type CreatePlanToRequest$Outbound = number | string;

/** @internal */
export const CreatePlanToRequest$outboundSchema: z.ZodMiniType<
  CreatePlanToRequest$Outbound,
  CreatePlanToRequest
> = smartUnion([z.number(), z.string()]);

export function createPlanToRequestToJSON(
  createPlanToRequest: CreatePlanToRequest,
): string {
  return JSON.stringify(
    CreatePlanToRequest$outboundSchema.parse(createPlanToRequest),
  );
}

/** @internal */
export type CreatePlanTierRequest$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const CreatePlanTierRequest$outboundSchema: z.ZodMiniType<
  CreatePlanTierRequest$Outbound,
  CreatePlanTierRequest
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function createPlanTierRequestToJSON(
  createPlanTierRequest: CreatePlanTierRequest,
): string {
  return JSON.stringify(
    CreatePlanTierRequest$outboundSchema.parse(createPlanTierRequest),
  );
}

/** @internal */
export const CreatePlanItemPriceIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanItemPriceIntervalRequest
> = z.enum(CreatePlanItemPriceIntervalRequest);

/** @internal */
export const CreatePlanBillingMethodRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanBillingMethodRequest
> = z.enum(CreatePlanBillingMethodRequest);

/** @internal */
export type CreatePlanItemPriceRequest$Outbound = {
  amount?: number | undefined;
  tiers?: Array<CreatePlanTierRequest$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const CreatePlanItemPriceRequest$outboundSchema: z.ZodMiniType<
  CreatePlanItemPriceRequest$Outbound,
  CreatePlanItemPriceRequest
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(
      z.array(z.lazy(() => CreatePlanTierRequest$outboundSchema)),
    ),
    interval: CreatePlanItemPriceIntervalRequest$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: CreatePlanBillingMethodRequest$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function createPlanItemPriceRequestToJSON(
  createPlanItemPriceRequest: CreatePlanItemPriceRequest,
): string {
  return JSON.stringify(
    CreatePlanItemPriceRequest$outboundSchema.parse(createPlanItemPriceRequest),
  );
}

/** @internal */
export const CreatePlanOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanOnIncrease
> = z.enum(CreatePlanOnIncrease);

/** @internal */
export const CreatePlanOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanOnDecrease
> = z.enum(CreatePlanOnDecrease);

/** @internal */
export type CreatePlanProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const CreatePlanProration$outboundSchema: z.ZodMiniType<
  CreatePlanProration$Outbound,
  CreatePlanProration
> = z.pipe(
  z.object({
    onIncrease: CreatePlanOnIncrease$outboundSchema,
    onDecrease: CreatePlanOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function createPlanProrationToJSON(
  createPlanProration: CreatePlanProration,
): string {
  return JSON.stringify(
    CreatePlanProration$outboundSchema.parse(createPlanProration),
  );
}

/** @internal */
export const CreatePlanExpiryDurationTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanExpiryDurationTypeRequest
> = z.enum(CreatePlanExpiryDurationTypeRequest);

/** @internal */
export type CreatePlanRolloverRequest$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const CreatePlanRolloverRequest$outboundSchema: z.ZodMiniType<
  CreatePlanRolloverRequest$Outbound,
  CreatePlanRolloverRequest
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: CreatePlanExpiryDurationTypeRequest$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function createPlanRolloverRequestToJSON(
  createPlanRolloverRequest: CreatePlanRolloverRequest,
): string {
  return JSON.stringify(
    CreatePlanRolloverRequest$outboundSchema.parse(createPlanRolloverRequest),
  );
}

/** @internal */
export type CreatePlanPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: CreatePlanResetRequest$Outbound | undefined;
  price?: CreatePlanItemPriceRequest$Outbound | undefined;
  proration?: CreatePlanProration$Outbound | undefined;
  rollover?: CreatePlanRolloverRequest$Outbound | undefined;
};

/** @internal */
export const CreatePlanPlanItem$outboundSchema: z.ZodMiniType<
  CreatePlanPlanItem$Outbound,
  CreatePlanPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => CreatePlanResetRequest$outboundSchema)),
    price: z.optional(z.lazy(() => CreatePlanItemPriceRequest$outboundSchema)),
    proration: z.optional(z.lazy(() => CreatePlanProration$outboundSchema)),
    rollover: z.optional(
      z.lazy(() => CreatePlanRolloverRequest$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function createPlanPlanItemToJSON(
  createPlanPlanItem: CreatePlanPlanItem,
): string {
  return JSON.stringify(
    CreatePlanPlanItem$outboundSchema.parse(createPlanPlanItem),
  );
}

/** @internal */
export const CreatePlanDurationTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof CreatePlanDurationTypeRequest
> = z.enum(CreatePlanDurationTypeRequest);

/** @internal */
export type FreeTrialRequest$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const FreeTrialRequest$outboundSchema: z.ZodMiniType<
  FreeTrialRequest$Outbound,
  FreeTrialRequest
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(
      CreatePlanDurationTypeRequest$outboundSchema,
      "month",
    ),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function freeTrialRequestToJSON(
  freeTrialRequest: FreeTrialRequest,
): string {
  return JSON.stringify(
    FreeTrialRequest$outboundSchema.parse(freeTrialRequest),
  );
}

/** @internal */
export type CreatePlanParams$Outbound = {
  plan_id: string;
  group: string;
  name: string;
  description?: string | null | undefined;
  add_on: boolean;
  auto_enable: boolean;
  price?: CreatePlanPriceRequest$Outbound | undefined;
  items?: Array<CreatePlanPlanItem$Outbound> | undefined;
  free_trial?: FreeTrialRequest$Outbound | undefined;
};

/** @internal */
export const CreatePlanParams$outboundSchema: z.ZodMiniType<
  CreatePlanParams$Outbound,
  CreatePlanParams
> = z.pipe(
  z.object({
    planId: z.string(),
    group: z._default(z.string(), ""),
    name: z.string(),
    description: z.optional(z.nullable(z.string())),
    addOn: z._default(z.boolean(), false),
    autoEnable: z._default(z.boolean(), false),
    price: z.optional(z.lazy(() => CreatePlanPriceRequest$outboundSchema)),
    items: z.optional(z.array(z.lazy(() => CreatePlanPlanItem$outboundSchema))),
    freeTrial: z.optional(z.lazy(() => FreeTrialRequest$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      planId: "plan_id",
      addOn: "add_on",
      autoEnable: "auto_enable",
      freeTrial: "free_trial",
    });
  }),
);

export function createPlanParamsToJSON(
  createPlanParams: CreatePlanParams,
): string {
  return JSON.stringify(
    CreatePlanParams$outboundSchema.parse(createPlanParams),
  );
}

/** @internal */
export const CreatePlanPriceIntervalResponse$inboundSchema: z.ZodMiniType<
  CreatePlanPriceIntervalResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanPriceIntervalResponse);

/** @internal */
export const CreatePlanPriceDisplay$inboundSchema: z.ZodMiniType<
  CreatePlanPriceDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function createPlanPriceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanPriceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanPriceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanPriceDisplay' from JSON`,
  );
}

/** @internal */
export const CreatePlanPriceResponse$inboundSchema: z.ZodMiniType<
  CreatePlanPriceResponse,
  unknown
> = z.pipe(
  z.object({
    amount: types.number(),
    interval: CreatePlanPriceIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
    display: types.optional(z.lazy(() => CreatePlanPriceDisplay$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
    });
  }),
);

export function createPlanPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanPriceResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanType$inboundSchema: z.ZodMiniType<
  CreatePlanType,
  unknown
> = openEnums.inboundSchema(CreatePlanType);

/** @internal */
export const CreatePlanFeatureDisplay$inboundSchema: z.ZodMiniType<
  CreatePlanFeatureDisplay,
  unknown
> = z.object({
  singular: types.string(),
  plural: types.string(),
});

export function createPlanFeatureDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanFeatureDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanFeatureDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanFeatureDisplay' from JSON`,
  );
}

/** @internal */
export const CreatePlanCreditSchema$inboundSchema: z.ZodMiniType<
  CreatePlanCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function createPlanCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanCreditSchema' from JSON`,
  );
}

/** @internal */
export const CreatePlanFeature$inboundSchema: z.ZodMiniType<
  CreatePlanFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: z.optional(z.nullable(types.string())),
    type: CreatePlanType$inboundSchema,
    display: z.optional(
      z.nullable(z.lazy(() => CreatePlanFeatureDisplay$inboundSchema)),
    ),
    credit_schema: z.optional(
      z.nullable(z.array(z.lazy(() => CreatePlanCreditSchema$inboundSchema))),
    ),
    archived: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "credit_schema": "creditSchema",
    });
  }),
);

export function createPlanFeatureFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanFeature' from JSON`,
  );
}

/** @internal */
export const CreatePlanResetIntervalResponse$inboundSchema: z.ZodMiniType<
  CreatePlanResetIntervalResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanResetIntervalResponse);

/** @internal */
export const CreatePlanResetResponse$inboundSchema: z.ZodMiniType<
  CreatePlanResetResponse,
  unknown
> = z.pipe(
  z.object({
    interval: CreatePlanResetIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
    });
  }),
);

export function createPlanResetResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanResetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanResetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanResetResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanToResponse$inboundSchema: z.ZodMiniType<
  CreatePlanToResponse,
  unknown
> = smartUnion([types.number(), types.string()]);

export function createPlanToResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanToResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanToResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanToResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanTierResponse$inboundSchema: z.ZodMiniType<
  CreatePlanTierResponse,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function createPlanTierResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanTierResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanTierResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanTierResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanPriceItemIntervalResponse$inboundSchema: z.ZodMiniType<
  CreatePlanPriceItemIntervalResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanPriceItemIntervalResponse);

/** @internal */
export const CreatePlanBillingMethodResponse$inboundSchema: z.ZodMiniType<
  CreatePlanBillingMethodResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanBillingMethodResponse);

/** @internal */
export const CreatePlanItemPriceResponse$inboundSchema: z.ZodMiniType<
  CreatePlanItemPriceResponse,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => CreatePlanTierResponse$inboundSchema)),
    ),
    interval: CreatePlanPriceItemIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
    billing_units: types.number(),
    billing_method: CreatePlanBillingMethodResponse$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function createPlanItemPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanItemPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanItemPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanItemPriceResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanItemDisplay$inboundSchema: z.ZodMiniType<
  CreatePlanItemDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function createPlanItemDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanItemDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanItemDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanItemDisplay' from JSON`,
  );
}

/** @internal */
export const CreatePlanExpiryDurationTypeResponse$inboundSchema: z.ZodMiniType<
  CreatePlanExpiryDurationTypeResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanExpiryDurationTypeResponse);

/** @internal */
export const CreatePlanRolloverResponse$inboundSchema: z.ZodMiniType<
  CreatePlanRolloverResponse,
  unknown
> = z.pipe(
  z.object({
    max: types.nullable(types.number()),
    expiry_duration_type: CreatePlanExpiryDurationTypeResponse$inboundSchema,
    expiry_duration_length: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expiry_duration_type": "expiryDurationType",
      "expiry_duration_length": "expiryDurationLength",
    });
  }),
);

export function createPlanRolloverResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanRolloverResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanRolloverResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanRolloverResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanItem$inboundSchema: z.ZodMiniType<
  CreatePlanItem,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => CreatePlanFeature$inboundSchema)),
    included: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => CreatePlanResetResponse$inboundSchema)),
    price: types.nullable(
      z.lazy(() => CreatePlanItemPriceResponse$inboundSchema),
    ),
    display: types.optional(z.lazy(() => CreatePlanItemDisplay$inboundSchema)),
    rollover: types.optional(
      z.lazy(() => CreatePlanRolloverResponse$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function createPlanItemFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanItem' from JSON`,
  );
}

/** @internal */
export const CreatePlanDurationTypeResponse$inboundSchema: z.ZodMiniType<
  CreatePlanDurationTypeResponse,
  unknown
> = openEnums.inboundSchema(CreatePlanDurationTypeResponse);

/** @internal */
export const CreatePlanFreeTrialResponse$inboundSchema: z.ZodMiniType<
  CreatePlanFreeTrialResponse,
  unknown
> = z.pipe(
  z.object({
    duration_length: types.number(),
    duration_type: CreatePlanDurationTypeResponse$inboundSchema,
    card_required: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "duration_length": "durationLength",
      "duration_type": "durationType",
      "card_required": "cardRequired",
    });
  }),
);

export function createPlanFreeTrialResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanFreeTrialResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanFreeTrialResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanFreeTrialResponse' from JSON`,
  );
}

/** @internal */
export const CreatePlanEnv$inboundSchema: z.ZodMiniType<
  CreatePlanEnv,
  unknown
> = openEnums.inboundSchema(CreatePlanEnv);

/** @internal */
export const CreatePlanResponse$inboundSchema: z.ZodMiniType<
  CreatePlanResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    description: types.nullable(types.string()),
    group: types.nullable(types.string()),
    version: types.number(),
    add_on: types.boolean(),
    auto_enable: types.boolean(),
    price: types.nullable(z.lazy(() => CreatePlanPriceResponse$inboundSchema)),
    items: z.array(z.lazy(() => CreatePlanItem$inboundSchema)),
    free_trial: types.optional(
      z.lazy(() => CreatePlanFreeTrialResponse$inboundSchema),
    ),
    created_at: types.number(),
    env: CreatePlanEnv$inboundSchema,
    archived: types.boolean(),
    base_variant_id: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "add_on": "addOn",
      "auto_enable": "autoEnable",
      "free_trial": "freeTrial",
      "created_at": "createdAt",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function createPlanResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePlanResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePlanResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePlanResponse' from JSON`,
  );
}
