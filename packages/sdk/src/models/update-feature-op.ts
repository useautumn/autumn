/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type UpdateFeatureGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
 */
export const UpdateFeatureTypeRequest = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
 */
export type UpdateFeatureTypeRequest = ClosedEnum<
  typeof UpdateFeatureTypeRequest
>;

/**
 * Singular and plural display names for the feature in your user interface.
 */
export type UpdateFeatureDisplayRequest = {
  singular: string;
  plural: string;
};

export type UpdateFeatureCreditSchemaRequest = {
  meteredFeatureId: string;
  creditCost: number;
};

export type UpdateFeatureParams = {
  /**
   * The name of the feature.
   */
  name?: string | undefined;
  /**
   * The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
   */
  type?: UpdateFeatureTypeRequest | undefined;
  /**
   * Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features.
   */
  consumable?: boolean | undefined;
  /**
   * Singular and plural display names for the feature in your user interface.
   */
  display?: UpdateFeatureDisplayRequest | undefined;
  /**
   * A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features.
   */
  creditSchema?: Array<UpdateFeatureCreditSchemaRequest> | undefined;
  eventNames?: Array<string> | undefined;
  /**
   * Whether the feature is archived. Archived features are hidden from the dashboard.
   */
  archived?: boolean | undefined;
  /**
   * The ID of the feature to update.
   */
  featureId: string;
  /**
   * The new ID of the feature. Feature ID can only be updated if it's not being used by any customers.
   */
  newFeatureId?: string | undefined;
};

/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export const UpdateFeatureTypeResponse = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export type UpdateFeatureTypeResponse = OpenEnum<
  typeof UpdateFeatureTypeResponse
>;

export type UpdateFeatureCreditSchemaResponse = {
  /**
   * ID of the metered feature that draws from this credit system.
   */
  meteredFeatureId: string;
  /**
   * Credits consumed per unit of the metered feature.
   */
  creditCost: number;
};

/**
 * Display names for the feature in billing UI and customer-facing components.
 */
export type UpdateFeatureDisplayResponse = {
  /**
   * Singular form for UI display (e.g., 'API call', 'seat').
   */
  singular?: string | null | undefined;
  /**
   * Plural form for UI display (e.g., 'API calls', 'seats').
   */
  plural?: string | null | undefined;
};

/**
 * OK
 */
export type UpdateFeatureResponse = {
  /**
   * The unique identifier for this feature, used in /check and /track calls.
   */
  id: string;
  /**
   * Human-readable name displayed in the dashboard and billing UI.
   */
  name: string;
  /**
   * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
   */
  type: UpdateFeatureTypeResponse;
  /**
   * For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage).
   */
  consumable: boolean;
  /**
   * Event names that trigger this feature's balance. Allows multiple features to respond to a single event.
   */
  eventNames?: Array<string> | undefined;
  /**
   * For credit_system features: maps metered features to their credit costs.
   */
  creditSchema?: Array<UpdateFeatureCreditSchemaResponse> | undefined;
  /**
   * Display names for the feature in billing UI and customer-facing components.
   */
  display?: UpdateFeatureDisplayResponse | undefined;
  /**
   * Whether the feature is archived and hidden from the dashboard.
   */
  archived: boolean;
};

/** @internal */
export const UpdateFeatureTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdateFeatureTypeRequest
> = z.enum(UpdateFeatureTypeRequest);

/** @internal */
export type UpdateFeatureDisplayRequest$Outbound = {
  singular: string;
  plural: string;
};

/** @internal */
export const UpdateFeatureDisplayRequest$outboundSchema: z.ZodMiniType<
  UpdateFeatureDisplayRequest$Outbound,
  UpdateFeatureDisplayRequest
> = z.object({
  singular: z.string(),
  plural: z.string(),
});

export function updateFeatureDisplayRequestToJSON(
  updateFeatureDisplayRequest: UpdateFeatureDisplayRequest,
): string {
  return JSON.stringify(
    UpdateFeatureDisplayRequest$outboundSchema.parse(
      updateFeatureDisplayRequest,
    ),
  );
}

/** @internal */
export type UpdateFeatureCreditSchemaRequest$Outbound = {
  metered_feature_id: string;
  credit_cost: number;
};

/** @internal */
export const UpdateFeatureCreditSchemaRequest$outboundSchema: z.ZodMiniType<
  UpdateFeatureCreditSchemaRequest$Outbound,
  UpdateFeatureCreditSchemaRequest
> = z.pipe(
  z.object({
    meteredFeatureId: z.string(),
    creditCost: z.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      meteredFeatureId: "metered_feature_id",
      creditCost: "credit_cost",
    });
  }),
);

export function updateFeatureCreditSchemaRequestToJSON(
  updateFeatureCreditSchemaRequest: UpdateFeatureCreditSchemaRequest,
): string {
  return JSON.stringify(
    UpdateFeatureCreditSchemaRequest$outboundSchema.parse(
      updateFeatureCreditSchemaRequest,
    ),
  );
}

/** @internal */
export type UpdateFeatureParams$Outbound = {
  name?: string | undefined;
  type?: string | undefined;
  consumable?: boolean | undefined;
  display?: UpdateFeatureDisplayRequest$Outbound | undefined;
  credit_schema?: Array<UpdateFeatureCreditSchemaRequest$Outbound> | undefined;
  event_names?: Array<string> | undefined;
  archived?: boolean | undefined;
  feature_id: string;
  new_feature_id?: string | undefined;
};

/** @internal */
export const UpdateFeatureParams$outboundSchema: z.ZodMiniType<
  UpdateFeatureParams$Outbound,
  UpdateFeatureParams
> = z.pipe(
  z.object({
    name: z.optional(z.string()),
    type: z.optional(UpdateFeatureTypeRequest$outboundSchema),
    consumable: z.optional(z.boolean()),
    display: z.optional(
      z.lazy(() => UpdateFeatureDisplayRequest$outboundSchema),
    ),
    creditSchema: z.optional(
      z.array(z.lazy(() => UpdateFeatureCreditSchemaRequest$outboundSchema)),
    ),
    eventNames: z.optional(z.array(z.string())),
    archived: z.optional(z.boolean()),
    featureId: z.string(),
    newFeatureId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      creditSchema: "credit_schema",
      eventNames: "event_names",
      featureId: "feature_id",
      newFeatureId: "new_feature_id",
    });
  }),
);

export function updateFeatureParamsToJSON(
  updateFeatureParams: UpdateFeatureParams,
): string {
  return JSON.stringify(
    UpdateFeatureParams$outboundSchema.parse(updateFeatureParams),
  );
}

/** @internal */
export const UpdateFeatureTypeResponse$inboundSchema: z.ZodMiniType<
  UpdateFeatureTypeResponse,
  unknown
> = openEnums.inboundSchema(UpdateFeatureTypeResponse);

/** @internal */
export const UpdateFeatureCreditSchemaResponse$inboundSchema: z.ZodMiniType<
  UpdateFeatureCreditSchemaResponse,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function updateFeatureCreditSchemaResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFeatureCreditSchemaResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFeatureCreditSchemaResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFeatureCreditSchemaResponse' from JSON`,
  );
}

/** @internal */
export const UpdateFeatureDisplayResponse$inboundSchema: z.ZodMiniType<
  UpdateFeatureDisplayResponse,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function updateFeatureDisplayResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFeatureDisplayResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFeatureDisplayResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFeatureDisplayResponse' from JSON`,
  );
}

/** @internal */
export const UpdateFeatureResponse$inboundSchema: z.ZodMiniType<
  UpdateFeatureResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: UpdateFeatureTypeResponse$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => UpdateFeatureCreditSchemaResponse$inboundSchema)),
    ),
    display: types.optional(
      z.lazy(() => UpdateFeatureDisplayResponse$inboundSchema),
    ),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function updateFeatureResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFeatureResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFeatureResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFeatureResponse' from JSON`,
  );
}
