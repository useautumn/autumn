/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type GetFeatureGlobals = {
  xApiVersion?: string | undefined;
};

export type GetFeatureParams = {
  /**
   * The ID of the feature.
   */
  featureId: string;
};

/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export const GetFeatureType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
/**
 * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
 */
export type GetFeatureType = OpenEnum<typeof GetFeatureType>;

export type GetFeatureCreditSchema = {
  /**
   * ID of the metered feature that draws from this credit system.
   */
  meteredFeatureId: string;
  /**
   * Credits consumed per unit of the metered feature.
   */
  creditCost: number;
};

/**
 * Display names for the feature in billing UI and customer-facing components.
 */
export type GetFeatureDisplay = {
  /**
   * Singular form for UI display (e.g., 'API call', 'seat').
   */
  singular?: string | null | undefined;
  /**
   * Plural form for UI display (e.g., 'API calls', 'seats').
   */
  plural?: string | null | undefined;
};

/**
 * OK
 */
export type GetFeatureResponse = {
  /**
   * The unique identifier for this feature, used in /check and /track calls.
   */
  id: string;
  /**
   * Human-readable name displayed in the dashboard and billing UI.
   */
  name: string;
  /**
   * Feature type: 'boolean' for on/off access, 'metered' for usage-tracked features, 'credit_system' for unified credit pools.
   */
  type: GetFeatureType;
  /**
   * For metered features: true if usage resets periodically (API calls, credits), false if allocated persistently (seats, storage).
   */
  consumable: boolean;
  /**
   * Event names that trigger this feature's balance. Allows multiple features to respond to a single event.
   */
  eventNames?: Array<string> | undefined;
  /**
   * For credit_system features: maps metered features to their credit costs.
   */
  creditSchema?: Array<GetFeatureCreditSchema> | undefined;
  /**
   * Display names for the feature in billing UI and customer-facing components.
   */
  display?: GetFeatureDisplay | undefined;
  /**
   * Whether the feature is archived and hidden from the dashboard.
   */
  archived: boolean;
};

/** @internal */
export type GetFeatureParams$Outbound = {
  feature_id: string;
};

/** @internal */
export const GetFeatureParams$outboundSchema: z.ZodMiniType<
  GetFeatureParams$Outbound,
  GetFeatureParams
> = z.pipe(
  z.object({
    featureId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function getFeatureParamsToJSON(
  getFeatureParams: GetFeatureParams,
): string {
  return JSON.stringify(
    GetFeatureParams$outboundSchema.parse(getFeatureParams),
  );
}

/** @internal */
export const GetFeatureType$inboundSchema: z.ZodMiniType<
  GetFeatureType,
  unknown
> = openEnums.inboundSchema(GetFeatureType);

/** @internal */
export const GetFeatureCreditSchema$inboundSchema: z.ZodMiniType<
  GetFeatureCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function getFeatureCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetFeatureCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetFeatureCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetFeatureCreditSchema' from JSON`,
  );
}

/** @internal */
export const GetFeatureDisplay$inboundSchema: z.ZodMiniType<
  GetFeatureDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function getFeatureDisplayFromJSON(
  jsonString: string,
): SafeParseResult<GetFeatureDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetFeatureDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetFeatureDisplay' from JSON`,
  );
}

/** @internal */
export const GetFeatureResponse$inboundSchema: z.ZodMiniType<
  GetFeatureResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: GetFeatureType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => GetFeatureCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => GetFeatureDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function getFeatureResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetFeatureResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetFeatureResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetFeatureResponse' from JSON`,
  );
}
