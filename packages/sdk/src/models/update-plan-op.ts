/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type UpdatePlanGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const UpdatePlanPriceIntervalRequest = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type UpdatePlanPriceIntervalRequest = ClosedEnum<
  typeof UpdatePlanPriceIntervalRequest
>;

/**
 * Base price configuration for a plan.
 */
export type UpdatePlanBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: UpdatePlanPriceIntervalRequest;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const UpdatePlanResetIntervalRequest = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type UpdatePlanResetIntervalRequest = ClosedEnum<
  typeof UpdatePlanResetIntervalRequest
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type UpdatePlanResetRequest = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: UpdatePlanResetIntervalRequest;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type UpdatePlanToRequest = number | string;

export type UpdatePlanTierRequest = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const UpdatePlanItemPriceIntervalRequest = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type UpdatePlanItemPriceIntervalRequest = ClosedEnum<
  typeof UpdatePlanItemPriceIntervalRequest
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const UpdatePlanBillingMethodRequest = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type UpdatePlanBillingMethodRequest = ClosedEnum<
  typeof UpdatePlanBillingMethodRequest
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type UpdatePlanPriceRequest = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<UpdatePlanTierRequest> | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: UpdatePlanItemPriceIntervalRequest;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: UpdatePlanBillingMethodRequest;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const UpdatePlanOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type UpdatePlanOnIncrease = ClosedEnum<typeof UpdatePlanOnIncrease>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const UpdatePlanOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type UpdatePlanOnDecrease = ClosedEnum<typeof UpdatePlanOnDecrease>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type UpdatePlanProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: UpdatePlanOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: UpdatePlanOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const UpdatePlanExpiryDurationTypeRequest = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type UpdatePlanExpiryDurationTypeRequest = ClosedEnum<
  typeof UpdatePlanExpiryDurationTypeRequest
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type UpdatePlanRolloverRequest = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: UpdatePlanExpiryDurationTypeRequest;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type UpdatePlanPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: UpdatePlanResetRequest | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: UpdatePlanPriceRequest | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: UpdatePlanProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: UpdatePlanRolloverRequest | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const UpdatePlanDurationTypeRequest = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type UpdatePlanDurationTypeRequest = ClosedEnum<
  typeof UpdatePlanDurationTypeRequest
>;

/**
 * Free trial configuration for a plan.
 */
export type UpdatePlanFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: UpdatePlanDurationTypeRequest | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

export type UpdatePlanParams = {
  /**
   * The ID of the plan to update.
   */
  planId: string;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group?: string | undefined;
  /**
   * Display name of the plan.
   */
  name?: string | undefined;
  description?: string | undefined;
  /**
   * Whether the plan is an add-on.
   */
  addOn?: boolean | undefined;
  /**
   * Whether the plan is automatically enabled.
   */
  autoEnable?: boolean | undefined;
  /**
   * The price of the plan. Set to null to remove the base price.
   */
  price?: UpdatePlanBasePrice | null | undefined;
  /**
   * Feature configurations for this plan. Each item defines included units, pricing, and reset behavior.
   */
  items?: Array<UpdatePlanPlanItem> | undefined;
  /**
   * The free trial of the plan. Set to null to remove the free trial.
   */
  freeTrial?: UpdatePlanFreeTrialParams | null | undefined;
  version?: number | undefined;
  archived?: boolean | undefined;
  /**
   * The new ID to use for the plan. Can only be updated if the plan has not been used by any customers.
   */
  newPlanId?: string | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const UpdatePlanPriceIntervalResponse = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type UpdatePlanPriceIntervalResponse = OpenEnum<
  typeof UpdatePlanPriceIntervalResponse
>;

/**
 * Display text for showing this price in pricing pages.
 */
export type UpdatePlanPriceDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

export type UpdatePlanPriceResponse = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: UpdatePlanPriceIntervalResponse;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Display text for showing this price in pricing pages.
   */
  display?: UpdatePlanPriceDisplay | undefined;
};

/**
 * The type of the feature
 */
export const UpdatePlanType = {
  Static: "static",
  Boolean: "boolean",
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature
 */
export type UpdatePlanType = OpenEnum<typeof UpdatePlanType>;

export type UpdatePlanFeatureDisplay = {
  /**
   * The singular display name for the feature.
   */
  singular: string;
  /**
   * The plural display name for the feature.
   */
  plural: string;
};

export type UpdatePlanCreditSchema = {
  /**
   * The ID of the metered feature (should be a single_use feature).
   */
  meteredFeatureId: string;
  /**
   * The credit cost of the metered feature.
   */
  creditCost: number;
};

/**
 * The full feature object if expanded.
 */
export type UpdatePlanFeature = {
  /**
   * The ID of the feature, used to refer to it in other API calls like /track or /check.
   */
  id: string;
  /**
   * The name of the feature.
   */
  name?: string | null | undefined;
  /**
   * The type of the feature
   */
  type: UpdatePlanType;
  /**
   * Singular and plural display names for the feature.
   */
  display?: UpdatePlanFeatureDisplay | null | undefined;
  /**
   * Credit cost schema for credit system features.
   */
  creditSchema?: Array<UpdatePlanCreditSchema> | null | undefined;
  /**
   * Whether or not the feature is archived.
   */
  archived?: boolean | null | undefined;
};

/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export const UpdatePlanResetIntervalResponse = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
 */
export type UpdatePlanResetIntervalResponse = OpenEnum<
  typeof UpdatePlanResetIntervalResponse
>;

export type UpdatePlanResetResponse = {
  /**
   * The interval at which the feature balance resets (e.g. 'month', 'year'). For consumable features, usage resets to 0 and included units are restored.
   */
  interval: UpdatePlanResetIntervalResponse;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type UpdatePlanToResponse = number | string;

export type UpdatePlanTierResponse = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export const UpdatePlanPriceItemIntervalResponse = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval for this price. For consumable features, should match reset.interval.
 */
export type UpdatePlanPriceItemIntervalResponse = OpenEnum<
  typeof UpdatePlanPriceItemIntervalResponse
>;

/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export const UpdatePlanBillingMethodResponse = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
 */
export type UpdatePlanBillingMethodResponse = OpenEnum<
  typeof UpdatePlanBillingMethodResponse
>;

export type UpdatePlanItemPriceResponse = {
  /**
   * Price per billing_units after included usage is consumed. Mutually exclusive with tiers.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration. Each tier's 'up_to' does NOT include the included amount. Either 'tiers' or 'amount' is required.
   */
  tiers?: Array<UpdatePlanTierResponse> | undefined;
  /**
   * Billing interval for this price. For consumable features, should match reset.interval.
   */
  interval: UpdatePlanPriceItemIntervalResponse;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Number of units per price increment. Usage is rounded UP to the nearest billing_units when billed (e.g. billing_units=100 means 101 usage rounds to 200).
   */
  billingUnits: number;
  /**
   * 'prepaid' for features like seats where customers pay upfront, 'usage_based' for pay-as-you-go after included usage.
   */
  billingMethod: UpdatePlanBillingMethodResponse;
  /**
   * Maximum units a customer can purchase beyond included. E.g. if included=100 and max_purchase=300, customer can use up to 400 total before usage is capped. Null for no limit.
   */
  maxPurchase: number | null;
};

/**
 * Display text for showing this item in pricing pages.
 */
export type UpdatePlanItemDisplay = {
  /**
   * Main display text (e.g. '$10' or '100 messages').
   */
  primaryText: string;
  /**
   * Secondary display text (e.g. 'per month' or 'then $0.5 per 100').
   */
  secondaryText?: string | undefined;
};

/**
 * When rolled over units expire.
 */
export const UpdatePlanExpiryDurationTypeResponse = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type UpdatePlanExpiryDurationTypeResponse = OpenEnum<
  typeof UpdatePlanExpiryDurationTypeResponse
>;

/**
 * Rollover configuration for unused units. If set, unused included units roll over to the next period.
 */
export type UpdatePlanRolloverResponse = {
  /**
   * Maximum rollover units. Null for unlimited rollover.
   */
  max: number | null;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: UpdatePlanExpiryDurationTypeResponse;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

export type UpdatePlanItem = {
  /**
   * The ID of the feature this item configures.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: UpdatePlanFeature | undefined;
  /**
   * Number of free units included. For consumable features, balance resets to this number each interval.
   */
  included: number;
  /**
   * Whether the customer has unlimited access to this feature.
   */
  unlimited: boolean;
  /**
   * Reset configuration for consumable features. Null for non-consumable features like seats where usage persists across billing cycles.
   */
  reset: UpdatePlanResetResponse | null;
  /**
   * Pricing configuration for usage beyond included units. Null if feature is entirely free.
   */
  price: UpdatePlanItemPriceResponse | null;
  /**
   * Display text for showing this item in pricing pages.
   */
  display?: UpdatePlanItemDisplay | undefined;
  /**
   * Rollover configuration for unused units. If set, unused included units roll over to the next period.
   */
  rollover?: UpdatePlanRolloverResponse | undefined;
};

/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export const UpdatePlanDurationTypeResponse = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial duration ('day', 'month', 'year').
 */
export type UpdatePlanDurationTypeResponse = OpenEnum<
  typeof UpdatePlanDurationTypeResponse
>;

/**
 * Free trial configuration. If set, new customers can try this plan before being charged.
 */
export type UpdatePlanFreeTrial = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial duration ('day', 'month', 'year').
   */
  durationType: UpdatePlanDurationTypeResponse;
  /**
   * Whether a payment method is required to start the trial. If true, customer will be charged after trial ends.
   */
  cardRequired: boolean;
};

/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export const UpdatePlanEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * Environment this plan belongs to ('sandbox' or 'live').
 */
export type UpdatePlanEnv = OpenEnum<typeof UpdatePlanEnv>;

/**
 * A plan defines a set of features, pricing, and entitlements that can be attached to customers.
 */
export type UpdatePlanResponse = {
  /**
   * Unique identifier for the plan.
   */
  id: string;
  /**
   * Display name of the plan.
   */
  name: string;
  /**
   * Optional description of the plan.
   */
  description: string | null;
  /**
   * Group identifier for organizing related plans. Plans in the same group are mutually exclusive.
   */
  group: string | null;
  /**
   * Version number of the plan. Incremented when plan configuration changes.
   */
  version: number;
  /**
   * Whether this is an add-on plan that can be attached alongside a main plan.
   */
  addOn: boolean;
  /**
   * If true, this plan is automatically attached when a customer is created. Used for free plans.
   */
  autoEnable: boolean;
  /**
   * Base recurring price for the plan. Null for free plans or usage-only plans.
   */
  price: UpdatePlanPriceResponse | null;
  /**
   * Feature configurations included in this plan. Each item defines included units, pricing, and reset behavior for a feature.
   */
  items: Array<UpdatePlanItem>;
  /**
   * Free trial configuration. If set, new customers can try this plan before being charged.
   */
  freeTrial?: UpdatePlanFreeTrial | undefined;
  /**
   * Unix timestamp (ms) when the plan was created.
   */
  createdAt: number;
  /**
   * Environment this plan belongs to ('sandbox' or 'live').
   */
  env: UpdatePlanEnv;
  /**
   * Whether the plan is archived. Archived plans cannot be attached to new customers.
   */
  archived: boolean;
  /**
   * If this is a variant, the ID of the base plan it was created from.
   */
  baseVariantId: string | null;
};

/** @internal */
export const UpdatePlanPriceIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanPriceIntervalRequest
> = z.enum(UpdatePlanPriceIntervalRequest);

/** @internal */
export type UpdatePlanBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const UpdatePlanBasePrice$outboundSchema: z.ZodMiniType<
  UpdatePlanBasePrice$Outbound,
  UpdatePlanBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: UpdatePlanPriceIntervalRequest$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function updatePlanBasePriceToJSON(
  updatePlanBasePrice: UpdatePlanBasePrice,
): string {
  return JSON.stringify(
    UpdatePlanBasePrice$outboundSchema.parse(updatePlanBasePrice),
  );
}

/** @internal */
export const UpdatePlanResetIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanResetIntervalRequest
> = z.enum(UpdatePlanResetIntervalRequest);

/** @internal */
export type UpdatePlanResetRequest$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const UpdatePlanResetRequest$outboundSchema: z.ZodMiniType<
  UpdatePlanResetRequest$Outbound,
  UpdatePlanResetRequest
> = z.pipe(
  z.object({
    interval: UpdatePlanResetIntervalRequest$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function updatePlanResetRequestToJSON(
  updatePlanResetRequest: UpdatePlanResetRequest,
): string {
  return JSON.stringify(
    UpdatePlanResetRequest$outboundSchema.parse(updatePlanResetRequest),
  );
}

/** @internal */
export type UpdatePlanToRequest$Outbound = number | string;

/** @internal */
export const UpdatePlanToRequest$outboundSchema: z.ZodMiniType<
  UpdatePlanToRequest$Outbound,
  UpdatePlanToRequest
> = smartUnion([z.number(), z.string()]);

export function updatePlanToRequestToJSON(
  updatePlanToRequest: UpdatePlanToRequest,
): string {
  return JSON.stringify(
    UpdatePlanToRequest$outboundSchema.parse(updatePlanToRequest),
  );
}

/** @internal */
export type UpdatePlanTierRequest$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const UpdatePlanTierRequest$outboundSchema: z.ZodMiniType<
  UpdatePlanTierRequest$Outbound,
  UpdatePlanTierRequest
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function updatePlanTierRequestToJSON(
  updatePlanTierRequest: UpdatePlanTierRequest,
): string {
  return JSON.stringify(
    UpdatePlanTierRequest$outboundSchema.parse(updatePlanTierRequest),
  );
}

/** @internal */
export const UpdatePlanItemPriceIntervalRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanItemPriceIntervalRequest
> = z.enum(UpdatePlanItemPriceIntervalRequest);

/** @internal */
export const UpdatePlanBillingMethodRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanBillingMethodRequest
> = z.enum(UpdatePlanBillingMethodRequest);

/** @internal */
export type UpdatePlanPriceRequest$Outbound = {
  amount?: number | undefined;
  tiers?: Array<UpdatePlanTierRequest$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const UpdatePlanPriceRequest$outboundSchema: z.ZodMiniType<
  UpdatePlanPriceRequest$Outbound,
  UpdatePlanPriceRequest
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(
      z.array(z.lazy(() => UpdatePlanTierRequest$outboundSchema)),
    ),
    interval: UpdatePlanItemPriceIntervalRequest$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: UpdatePlanBillingMethodRequest$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function updatePlanPriceRequestToJSON(
  updatePlanPriceRequest: UpdatePlanPriceRequest,
): string {
  return JSON.stringify(
    UpdatePlanPriceRequest$outboundSchema.parse(updatePlanPriceRequest),
  );
}

/** @internal */
export const UpdatePlanOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanOnIncrease
> = z.enum(UpdatePlanOnIncrease);

/** @internal */
export const UpdatePlanOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanOnDecrease
> = z.enum(UpdatePlanOnDecrease);

/** @internal */
export type UpdatePlanProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const UpdatePlanProration$outboundSchema: z.ZodMiniType<
  UpdatePlanProration$Outbound,
  UpdatePlanProration
> = z.pipe(
  z.object({
    onIncrease: UpdatePlanOnIncrease$outboundSchema,
    onDecrease: UpdatePlanOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function updatePlanProrationToJSON(
  updatePlanProration: UpdatePlanProration,
): string {
  return JSON.stringify(
    UpdatePlanProration$outboundSchema.parse(updatePlanProration),
  );
}

/** @internal */
export const UpdatePlanExpiryDurationTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanExpiryDurationTypeRequest
> = z.enum(UpdatePlanExpiryDurationTypeRequest);

/** @internal */
export type UpdatePlanRolloverRequest$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const UpdatePlanRolloverRequest$outboundSchema: z.ZodMiniType<
  UpdatePlanRolloverRequest$Outbound,
  UpdatePlanRolloverRequest
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: UpdatePlanExpiryDurationTypeRequest$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function updatePlanRolloverRequestToJSON(
  updatePlanRolloverRequest: UpdatePlanRolloverRequest,
): string {
  return JSON.stringify(
    UpdatePlanRolloverRequest$outboundSchema.parse(updatePlanRolloverRequest),
  );
}

/** @internal */
export type UpdatePlanPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: UpdatePlanResetRequest$Outbound | undefined;
  price?: UpdatePlanPriceRequest$Outbound | undefined;
  proration?: UpdatePlanProration$Outbound | undefined;
  rollover?: UpdatePlanRolloverRequest$Outbound | undefined;
};

/** @internal */
export const UpdatePlanPlanItem$outboundSchema: z.ZodMiniType<
  UpdatePlanPlanItem$Outbound,
  UpdatePlanPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => UpdatePlanResetRequest$outboundSchema)),
    price: z.optional(z.lazy(() => UpdatePlanPriceRequest$outboundSchema)),
    proration: z.optional(z.lazy(() => UpdatePlanProration$outboundSchema)),
    rollover: z.optional(
      z.lazy(() => UpdatePlanRolloverRequest$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function updatePlanPlanItemToJSON(
  updatePlanPlanItem: UpdatePlanPlanItem,
): string {
  return JSON.stringify(
    UpdatePlanPlanItem$outboundSchema.parse(updatePlanPlanItem),
  );
}

/** @internal */
export const UpdatePlanDurationTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof UpdatePlanDurationTypeRequest
> = z.enum(UpdatePlanDurationTypeRequest);

/** @internal */
export type UpdatePlanFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const UpdatePlanFreeTrialParams$outboundSchema: z.ZodMiniType<
  UpdatePlanFreeTrialParams$Outbound,
  UpdatePlanFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(
      UpdatePlanDurationTypeRequest$outboundSchema,
      "month",
    ),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function updatePlanFreeTrialParamsToJSON(
  updatePlanFreeTrialParams: UpdatePlanFreeTrialParams,
): string {
  return JSON.stringify(
    UpdatePlanFreeTrialParams$outboundSchema.parse(updatePlanFreeTrialParams),
  );
}

/** @internal */
export type UpdatePlanParams$Outbound = {
  plan_id: string;
  group: string;
  name?: string | undefined;
  description?: string | undefined;
  add_on?: boolean | undefined;
  auto_enable?: boolean | undefined;
  price?: UpdatePlanBasePrice$Outbound | null | undefined;
  items?: Array<UpdatePlanPlanItem$Outbound> | undefined;
  free_trial?: UpdatePlanFreeTrialParams$Outbound | null | undefined;
  version?: number | undefined;
  archived: boolean;
  new_plan_id?: string | undefined;
};

/** @internal */
export const UpdatePlanParams$outboundSchema: z.ZodMiniType<
  UpdatePlanParams$Outbound,
  UpdatePlanParams
> = z.pipe(
  z.object({
    planId: z.string(),
    group: z._default(z.string(), ""),
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    addOn: z.optional(z.boolean()),
    autoEnable: z.optional(z.boolean()),
    price: z.optional(
      z.nullable(z.lazy(() => UpdatePlanBasePrice$outboundSchema)),
    ),
    items: z.optional(z.array(z.lazy(() => UpdatePlanPlanItem$outboundSchema))),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => UpdatePlanFreeTrialParams$outboundSchema)),
    ),
    version: z.optional(z.number()),
    archived: z._default(z.boolean(), false),
    newPlanId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      planId: "plan_id",
      addOn: "add_on",
      autoEnable: "auto_enable",
      freeTrial: "free_trial",
      newPlanId: "new_plan_id",
    });
  }),
);

export function updatePlanParamsToJSON(
  updatePlanParams: UpdatePlanParams,
): string {
  return JSON.stringify(
    UpdatePlanParams$outboundSchema.parse(updatePlanParams),
  );
}

/** @internal */
export const UpdatePlanPriceIntervalResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanPriceIntervalResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanPriceIntervalResponse);

/** @internal */
export const UpdatePlanPriceDisplay$inboundSchema: z.ZodMiniType<
  UpdatePlanPriceDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function updatePlanPriceDisplayFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanPriceDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanPriceDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanPriceDisplay' from JSON`,
  );
}

/** @internal */
export const UpdatePlanPriceResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanPriceResponse,
  unknown
> = z.pipe(
  z.object({
    amount: types.number(),
    interval: UpdatePlanPriceIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
    display: types.optional(z.lazy(() => UpdatePlanPriceDisplay$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
    });
  }),
);

export function updatePlanPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanPriceResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanType$inboundSchema: z.ZodMiniType<
  UpdatePlanType,
  unknown
> = openEnums.inboundSchema(UpdatePlanType);

/** @internal */
export const UpdatePlanFeatureDisplay$inboundSchema: z.ZodMiniType<
  UpdatePlanFeatureDisplay,
  unknown
> = z.object({
  singular: types.string(),
  plural: types.string(),
});

export function updatePlanFeatureDisplayFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanFeatureDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanFeatureDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanFeatureDisplay' from JSON`,
  );
}

/** @internal */
export const UpdatePlanCreditSchema$inboundSchema: z.ZodMiniType<
  UpdatePlanCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function updatePlanCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanCreditSchema' from JSON`,
  );
}

/** @internal */
export const UpdatePlanFeature$inboundSchema: z.ZodMiniType<
  UpdatePlanFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: z.optional(z.nullable(types.string())),
    type: UpdatePlanType$inboundSchema,
    display: z.optional(
      z.nullable(z.lazy(() => UpdatePlanFeatureDisplay$inboundSchema)),
    ),
    credit_schema: z.optional(
      z.nullable(z.array(z.lazy(() => UpdatePlanCreditSchema$inboundSchema))),
    ),
    archived: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "credit_schema": "creditSchema",
    });
  }),
);

export function updatePlanFeatureFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanFeature' from JSON`,
  );
}

/** @internal */
export const UpdatePlanResetIntervalResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanResetIntervalResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanResetIntervalResponse);

/** @internal */
export const UpdatePlanResetResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanResetResponse,
  unknown
> = z.pipe(
  z.object({
    interval: UpdatePlanResetIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
    });
  }),
);

export function updatePlanResetResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanResetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanResetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanResetResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanToResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanToResponse,
  unknown
> = smartUnion([types.number(), types.string()]);

export function updatePlanToResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanToResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanToResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanToResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanTierResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanTierResponse,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function updatePlanTierResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanTierResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanTierResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanTierResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanPriceItemIntervalResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanPriceItemIntervalResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanPriceItemIntervalResponse);

/** @internal */
export const UpdatePlanBillingMethodResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanBillingMethodResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanBillingMethodResponse);

/** @internal */
export const UpdatePlanItemPriceResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanItemPriceResponse,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => UpdatePlanTierResponse$inboundSchema)),
    ),
    interval: UpdatePlanPriceItemIntervalResponse$inboundSchema,
    interval_count: types.optional(types.number()),
    billing_units: types.number(),
    billing_method: UpdatePlanBillingMethodResponse$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function updatePlanItemPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanItemPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanItemPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanItemPriceResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanItemDisplay$inboundSchema: z.ZodMiniType<
  UpdatePlanItemDisplay,
  unknown
> = z.pipe(
  z.object({
    primary_text: types.string(),
    secondary_text: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "primary_text": "primaryText",
      "secondary_text": "secondaryText",
    });
  }),
);

export function updatePlanItemDisplayFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanItemDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanItemDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanItemDisplay' from JSON`,
  );
}

/** @internal */
export const UpdatePlanExpiryDurationTypeResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanExpiryDurationTypeResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanExpiryDurationTypeResponse);

/** @internal */
export const UpdatePlanRolloverResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanRolloverResponse,
  unknown
> = z.pipe(
  z.object({
    max: types.nullable(types.number()),
    expiry_duration_type: UpdatePlanExpiryDurationTypeResponse$inboundSchema,
    expiry_duration_length: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expiry_duration_type": "expiryDurationType",
      "expiry_duration_length": "expiryDurationLength",
    });
  }),
);

export function updatePlanRolloverResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanRolloverResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanRolloverResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanRolloverResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePlanItem$inboundSchema: z.ZodMiniType<
  UpdatePlanItem,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => UpdatePlanFeature$inboundSchema)),
    included: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => UpdatePlanResetResponse$inboundSchema)),
    price: types.nullable(
      z.lazy(() => UpdatePlanItemPriceResponse$inboundSchema),
    ),
    display: types.optional(z.lazy(() => UpdatePlanItemDisplay$inboundSchema)),
    rollover: types.optional(
      z.lazy(() => UpdatePlanRolloverResponse$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function updatePlanItemFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanItem' from JSON`,
  );
}

/** @internal */
export const UpdatePlanDurationTypeResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanDurationTypeResponse,
  unknown
> = openEnums.inboundSchema(UpdatePlanDurationTypeResponse);

/** @internal */
export const UpdatePlanFreeTrial$inboundSchema: z.ZodMiniType<
  UpdatePlanFreeTrial,
  unknown
> = z.pipe(
  z.object({
    duration_length: types.number(),
    duration_type: UpdatePlanDurationTypeResponse$inboundSchema,
    card_required: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "duration_length": "durationLength",
      "duration_type": "durationType",
      "card_required": "cardRequired",
    });
  }),
);

export function updatePlanFreeTrialFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanFreeTrial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanFreeTrial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanFreeTrial' from JSON`,
  );
}

/** @internal */
export const UpdatePlanEnv$inboundSchema: z.ZodMiniType<
  UpdatePlanEnv,
  unknown
> = openEnums.inboundSchema(UpdatePlanEnv);

/** @internal */
export const UpdatePlanResponse$inboundSchema: z.ZodMiniType<
  UpdatePlanResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    description: types.nullable(types.string()),
    group: types.nullable(types.string()),
    version: types.number(),
    add_on: types.boolean(),
    auto_enable: types.boolean(),
    price: types.nullable(z.lazy(() => UpdatePlanPriceResponse$inboundSchema)),
    items: z.array(z.lazy(() => UpdatePlanItem$inboundSchema)),
    free_trial: types.optional(z.lazy(() => UpdatePlanFreeTrial$inboundSchema)),
    created_at: types.number(),
    env: UpdatePlanEnv$inboundSchema,
    archived: types.boolean(),
    base_variant_id: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "add_on": "addOn",
      "auto_enable": "autoEnable",
      "free_trial": "freeTrial",
      "created_at": "createdAt",
      "base_variant_id": "baseVariantId",
    });
  }),
);

export function updatePlanResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePlanResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePlanResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePlanResponse' from JSON`,
  );
}
