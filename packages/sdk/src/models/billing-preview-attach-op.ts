/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingPreviewAttachGlobals = {
  xApiVersion?: string | undefined;
};

export type BillingPreviewAttachFeatureQuantities = {
  featureId: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

export const BillingPreviewAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type BillingPreviewAttachDurationType = ClosedEnum<
  typeof BillingPreviewAttachDurationType
>;

export type BillingPreviewAttachFreeTrial = {
  durationLength: number;
  durationType?: BillingPreviewAttachDurationType | undefined;
  cardRequired?: boolean | undefined;
};

export const BillingPreviewAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewAttachPriceInterval = ClosedEnum<
  typeof BillingPreviewAttachPriceInterval
>;

export type BillingPreviewAttachPriceRequest = {
  amount: number;
  interval: BillingPreviewAttachPriceInterval;
  intervalCount?: number | undefined;
};

export const BillingPreviewAttachItemResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewAttachItemResetInterval = ClosedEnum<
  typeof BillingPreviewAttachItemResetInterval
>;

export type BillingPreviewAttachCustomizeReset = {
  interval: BillingPreviewAttachItemResetInterval;
  intervalCount?: number | undefined;
};

export type BillingPreviewAttachTo = number | string;

export type BillingPreviewAttachTierRequest = {
  to: number | string;
  amount: number;
};

export const BillingPreviewAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingPreviewAttachItemPriceInterval = ClosedEnum<
  typeof BillingPreviewAttachItemPriceInterval
>;

export const BillingPreviewAttachBillingMethodRequest = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BillingPreviewAttachBillingMethodRequest = ClosedEnum<
  typeof BillingPreviewAttachBillingMethodRequest
>;

export type BillingPreviewAttachItemPrice = {
  amount?: number | undefined;
  tiers?: Array<BillingPreviewAttachTierRequest> | undefined;
  interval: BillingPreviewAttachItemPriceInterval;
  intervalCount?: number | undefined;
  billingUnits?: number | undefined;
  billingMethod: BillingPreviewAttachBillingMethodRequest;
  maxPurchase?: number | undefined;
};

export const BillingPreviewAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type BillingPreviewAttachOnIncrease = ClosedEnum<
  typeof BillingPreviewAttachOnIncrease
>;

export const BillingPreviewAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type BillingPreviewAttachOnDecrease = ClosedEnum<
  typeof BillingPreviewAttachOnDecrease
>;

export type BillingPreviewAttachProration = {
  onIncrease: BillingPreviewAttachOnIncrease;
  onDecrease: BillingPreviewAttachOnDecrease;
};

export const BillingPreviewAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type BillingPreviewAttachExpiryDurationType = ClosedEnum<
  typeof BillingPreviewAttachExpiryDurationType
>;

export type BillingPreviewAttachRolloverRequest = {
  max?: number | undefined;
  expiryDurationType: BillingPreviewAttachExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export type BillingPreviewAttachItem = {
  featureId: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingPreviewAttachCustomizeReset | undefined;
  price?: BillingPreviewAttachItemPrice | undefined;
  proration?: BillingPreviewAttachProration | undefined;
  rollover?: BillingPreviewAttachRolloverRequest | undefined;
};

export type BillingPreviewAttachCustomize = {
  price?: BillingPreviewAttachPriceRequest | null | undefined;
  items?: Array<BillingPreviewAttachItem> | undefined;
};

export type BillingPreviewAttachInvoiceMode = {
  enabled: boolean;
  enableProductImmediately?: boolean | undefined;
  finalizeInvoice?: boolean | undefined;
};

export type BillingPreviewAttachDiscountRequest2 = {
  promotionCode: string;
};

export type BillingPreviewAttachDiscountRequest1 = {
  rewardId: string;
};

export type BillingPreviewAttachDiscountUnion =
  | BillingPreviewAttachDiscountRequest1
  | BillingPreviewAttachDiscountRequest2;

export const BillingPreviewAttachRedirectMode = {
  Always: "always",
  IfRequired: "if_required",
  Never: "never",
} as const;
export type BillingPreviewAttachRedirectMode = ClosedEnum<
  typeof BillingPreviewAttachRedirectMode
>;

export const BillingPreviewAttachPlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
export type BillingPreviewAttachPlanSchedule = ClosedEnum<
  typeof BillingPreviewAttachPlanSchedule
>;

export const BillingPreviewAttachBillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
export type BillingPreviewAttachBillingBehavior = ClosedEnum<
  typeof BillingPreviewAttachBillingBehavior
>;

export type BillingPreviewAttachRequest = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | null | undefined;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?:
    | Array<BillingPreviewAttachFeatureQuantities>
    | null
    | undefined;
  version?: number | undefined;
  freeTrial?: BillingPreviewAttachFreeTrial | null | undefined;
  customize?: BillingPreviewAttachCustomize | undefined;
  planId: string;
  invoiceMode?: BillingPreviewAttachInvoiceMode | undefined;
  discounts?:
    | Array<
      | BillingPreviewAttachDiscountRequest1
      | BillingPreviewAttachDiscountRequest2
    >
    | undefined;
  redirectMode?: BillingPreviewAttachRedirectMode | undefined;
  successUrl?: string | undefined;
  newBillingSubscription?: boolean | undefined;
  planSchedule?: BillingPreviewAttachPlanSchedule | undefined;
  billingBehavior?: BillingPreviewAttachBillingBehavior | undefined;
};

export type BillingPreviewAttachDiscountResponse = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type BillingPreviewAttachEffectivePeriod = {
  start: number;
  end: number;
};

export type BillingPreviewAttachLineItem = {
  title: string;
  description: string;
  amount: number;
  discounts?: Array<BillingPreviewAttachDiscountResponse> | undefined;
  isBase?: boolean | undefined;
  totalQuantity: number;
  paidQuantity: number;
  planId: string;
  deferredForTrial?: boolean | undefined;
  effectivePeriod?: BillingPreviewAttachEffectivePeriod | undefined;
};

export type BillingPreviewAttachCredit = {
  amount: number;
  description: string;
};

export type BillingPreviewAttachNextCycleDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type BillingPreviewAttachNextCycleEffectivePeriod = {
  start: number;
  end: number;
};

export type BillingPreviewAttachNextCycleLineItem = {
  title: string;
  description: string;
  amount: number;
  discounts?: Array<BillingPreviewAttachNextCycleDiscount> | undefined;
  isBase?: boolean | undefined;
  totalQuantity: number;
  paidQuantity: number;
  planId: string;
  deferredForTrial?: boolean | undefined;
  effectivePeriod?: BillingPreviewAttachNextCycleEffectivePeriod | undefined;
};

export type BillingPreviewAttachNextCycle = {
  startsAt: number;
  total: number;
  lineItems: Array<BillingPreviewAttachNextCycleLineItem>;
};

export type IncomingFeatureQuantity = {
  featureId: string;
  quantity: number;
};

export const IncomingType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type IncomingType = OpenEnum<typeof IncomingType>;

export type IncomingCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type IncomingDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type IncomingFeature = {
  id: string;
  name: string;
  type: IncomingType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<IncomingCreditSchema> | undefined;
  display?: IncomingDisplay | undefined;
  archived: boolean;
};

export const IntervalIncomingEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type IntervalIncomingEnum = OpenEnum<typeof IntervalIncomingEnum>;

export type IncomingIntervalUnion = IntervalIncomingEnum | string;

export type IncomingReset = {
  interval: IntervalIncomingEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type IncomingTier = {
  to?: any | undefined;
  amount: number;
};

export const IncomingBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type IncomingBillingMethod = OpenEnum<typeof IncomingBillingMethod>;

export type IncomingPrice = {
  amount?: number | undefined;
  tiers?: Array<IncomingTier> | undefined;
  billingUnits: number;
  billingMethod: IncomingBillingMethod;
  maxPurchase: number | null;
};

export type IncomingBreakdown = {
  object: "balance_breakdown";
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: IncomingReset | null;
  price: IncomingPrice | null;
  expiresAt: number | null;
};

export type IncomingRollover = {
  balance: number;
  expiresAt: number;
};

export type IncomingBalances = {
  object: "balance";
  featureId: string;
  feature?: IncomingFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<IncomingBreakdown> | undefined;
  rollovers?: Array<IncomingRollover> | undefined;
};

export type Incoming = {
  plan: Plan;
  featureQuantities: Array<IncomingFeatureQuantity>;
  balances: { [k: string]: IncomingBalances };
  periodStart?: number | undefined;
  periodEnd?: number | undefined;
};

export type OutgoingFeatureQuantity = {
  featureId: string;
  quantity: number;
};

export const OutgoingType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type OutgoingType = OpenEnum<typeof OutgoingType>;

export type OutgoingCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type OutgoingDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type OutgoingFeature = {
  id: string;
  name: string;
  type: OutgoingType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<OutgoingCreditSchema> | undefined;
  display?: OutgoingDisplay | undefined;
  archived: boolean;
};

export const IntervalOutgoingEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type IntervalOutgoingEnum = OpenEnum<typeof IntervalOutgoingEnum>;

export type OutgoingIntervalUnion = IntervalOutgoingEnum | string;

export type OutgoingReset = {
  interval: IntervalOutgoingEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type OutgoingTier = {
  to?: any | undefined;
  amount: number;
};

export const OutgoingBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type OutgoingBillingMethod = OpenEnum<typeof OutgoingBillingMethod>;

export type OutgoingPrice = {
  amount?: number | undefined;
  tiers?: Array<OutgoingTier> | undefined;
  billingUnits: number;
  billingMethod: OutgoingBillingMethod;
  maxPurchase: number | null;
};

export type OutgoingBreakdown = {
  object: "balance_breakdown";
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: OutgoingReset | null;
  price: OutgoingPrice | null;
  expiresAt: number | null;
};

export type OutgoingRollover = {
  balance: number;
  expiresAt: number;
};

export type OutgoingBalances = {
  object: "balance";
  featureId: string;
  feature?: OutgoingFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<OutgoingBreakdown> | undefined;
  rollovers?: Array<OutgoingRollover> | undefined;
};

export type Outgoing = {
  plan: Plan;
  featureQuantities: Array<OutgoingFeatureQuantity>;
  balances: { [k: string]: OutgoingBalances };
  periodStart?: number | undefined;
  periodEnd?: number | undefined;
};

export const RedirectType = {
  StripeCheckout: "stripe_checkout",
  AutumnCheckout: "autumn_checkout",
} as const;
export type RedirectType = OpenEnum<typeof RedirectType>;

/**
 * OK
 */
export type BillingPreviewAttachResponse = {
  customerId: string;
  lineItems: Array<BillingPreviewAttachLineItem>;
  total: number;
  currency: string;
  periodStart?: number | undefined;
  periodEnd?: number | undefined;
  credit?: BillingPreviewAttachCredit | undefined;
  nextCycle?: BillingPreviewAttachNextCycle | undefined;
  incoming: Array<Incoming>;
  outgoing: Array<Outgoing>;
  redirectType: RedirectType | null;
};

/** @internal */
export type BillingPreviewAttachFeatureQuantities$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingPreviewAttachFeatureQuantities$outboundSchema:
  z.ZodMiniType<
    BillingPreviewAttachFeatureQuantities$Outbound,
    BillingPreviewAttachFeatureQuantities
  > = z.pipe(
    z.object({
      featureId: z.string(),
      quantity: z.optional(z.number()),
      adjustable: z.optional(z.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        featureId: "feature_id",
      });
    }),
  );

export function billingPreviewAttachFeatureQuantitiesToJSON(
  billingPreviewAttachFeatureQuantities: BillingPreviewAttachFeatureQuantities,
): string {
  return JSON.stringify(
    BillingPreviewAttachFeatureQuantities$outboundSchema.parse(
      billingPreviewAttachFeatureQuantities,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachDurationType
> = z.enum(BillingPreviewAttachDurationType);

/** @internal */
export type BillingPreviewAttachFreeTrial$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingPreviewAttachFreeTrial$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachFreeTrial$Outbound,
  BillingPreviewAttachFreeTrial
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(
      BillingPreviewAttachDurationType$outboundSchema,
      "month",
    ),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingPreviewAttachFreeTrialToJSON(
  billingPreviewAttachFreeTrial: BillingPreviewAttachFreeTrial,
): string {
  return JSON.stringify(
    BillingPreviewAttachFreeTrial$outboundSchema.parse(
      billingPreviewAttachFreeTrial,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachPriceInterval
> = z.enum(BillingPreviewAttachPriceInterval);

/** @internal */
export type BillingPreviewAttachPriceRequest$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingPreviewAttachPriceRequest$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachPriceRequest$Outbound,
  BillingPreviewAttachPriceRequest
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingPreviewAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingPreviewAttachPriceRequestToJSON(
  billingPreviewAttachPriceRequest: BillingPreviewAttachPriceRequest,
): string {
  return JSON.stringify(
    BillingPreviewAttachPriceRequest$outboundSchema.parse(
      billingPreviewAttachPriceRequest,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachItemResetInterval$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewAttachItemResetInterval> = z.enum(
    BillingPreviewAttachItemResetInterval,
  );

/** @internal */
export type BillingPreviewAttachCustomizeReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingPreviewAttachCustomizeReset$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachCustomizeReset$Outbound,
  BillingPreviewAttachCustomizeReset
> = z.pipe(
  z.object({
    interval: BillingPreviewAttachItemResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingPreviewAttachCustomizeResetToJSON(
  billingPreviewAttachCustomizeReset: BillingPreviewAttachCustomizeReset,
): string {
  return JSON.stringify(
    BillingPreviewAttachCustomizeReset$outboundSchema.parse(
      billingPreviewAttachCustomizeReset,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachTo$Outbound = number | string;

/** @internal */
export const BillingPreviewAttachTo$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachTo$Outbound,
  BillingPreviewAttachTo
> = smartUnion([z.number(), z.string()]);

export function billingPreviewAttachToToJSON(
  billingPreviewAttachTo: BillingPreviewAttachTo,
): string {
  return JSON.stringify(
    BillingPreviewAttachTo$outboundSchema.parse(billingPreviewAttachTo),
  );
}

/** @internal */
export type BillingPreviewAttachTierRequest$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingPreviewAttachTierRequest$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachTierRequest$Outbound,
  BillingPreviewAttachTierRequest
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingPreviewAttachTierRequestToJSON(
  billingPreviewAttachTierRequest: BillingPreviewAttachTierRequest,
): string {
  return JSON.stringify(
    BillingPreviewAttachTierRequest$outboundSchema.parse(
      billingPreviewAttachTierRequest,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachItemPriceInterval$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewAttachItemPriceInterval> = z.enum(
    BillingPreviewAttachItemPriceInterval,
  );

/** @internal */
export const BillingPreviewAttachBillingMethodRequest$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewAttachBillingMethodRequest> = z.enum(
    BillingPreviewAttachBillingMethodRequest,
  );

/** @internal */
export type BillingPreviewAttachItemPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingPreviewAttachTierRequest$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingPreviewAttachItemPrice$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachItemPrice$Outbound,
  BillingPreviewAttachItemPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(
      z.array(z.lazy(() => BillingPreviewAttachTierRequest$outboundSchema)),
    ),
    interval: BillingPreviewAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingPreviewAttachBillingMethodRequest$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingPreviewAttachItemPriceToJSON(
  billingPreviewAttachItemPrice: BillingPreviewAttachItemPrice,
): string {
  return JSON.stringify(
    BillingPreviewAttachItemPrice$outboundSchema.parse(
      billingPreviewAttachItemPrice,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachOnIncrease
> = z.enum(BillingPreviewAttachOnIncrease);

/** @internal */
export const BillingPreviewAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachOnDecrease
> = z.enum(BillingPreviewAttachOnDecrease);

/** @internal */
export type BillingPreviewAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingPreviewAttachProration$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachProration$Outbound,
  BillingPreviewAttachProration
> = z.pipe(
  z.object({
    onIncrease: BillingPreviewAttachOnIncrease$outboundSchema,
    onDecrease: BillingPreviewAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingPreviewAttachProrationToJSON(
  billingPreviewAttachProration: BillingPreviewAttachProration,
): string {
  return JSON.stringify(
    BillingPreviewAttachProration$outboundSchema.parse(
      billingPreviewAttachProration,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachExpiryDurationType$outboundSchema:
  z.ZodMiniEnum<typeof BillingPreviewAttachExpiryDurationType> = z.enum(
    BillingPreviewAttachExpiryDurationType,
  );

/** @internal */
export type BillingPreviewAttachRolloverRequest$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingPreviewAttachRolloverRequest$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachRolloverRequest$Outbound,
  BillingPreviewAttachRolloverRequest
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingPreviewAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingPreviewAttachRolloverRequestToJSON(
  billingPreviewAttachRolloverRequest: BillingPreviewAttachRolloverRequest,
): string {
  return JSON.stringify(
    BillingPreviewAttachRolloverRequest$outboundSchema.parse(
      billingPreviewAttachRolloverRequest,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingPreviewAttachCustomizeReset$Outbound | undefined;
  price?: BillingPreviewAttachItemPrice$Outbound | undefined;
  proration?: BillingPreviewAttachProration$Outbound | undefined;
  rollover?: BillingPreviewAttachRolloverRequest$Outbound | undefined;
};

/** @internal */
export const BillingPreviewAttachItem$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachItem$Outbound,
  BillingPreviewAttachItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(
      z.lazy(() => BillingPreviewAttachCustomizeReset$outboundSchema),
    ),
    price: z.optional(
      z.lazy(() => BillingPreviewAttachItemPrice$outboundSchema),
    ),
    proration: z.optional(
      z.lazy(() => BillingPreviewAttachProration$outboundSchema),
    ),
    rollover: z.optional(
      z.lazy(() => BillingPreviewAttachRolloverRequest$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingPreviewAttachItemToJSON(
  billingPreviewAttachItem: BillingPreviewAttachItem,
): string {
  return JSON.stringify(
    BillingPreviewAttachItem$outboundSchema.parse(billingPreviewAttachItem),
  );
}

/** @internal */
export type BillingPreviewAttachCustomize$Outbound = {
  price?: BillingPreviewAttachPriceRequest$Outbound | null | undefined;
  items?: Array<BillingPreviewAttachItem$Outbound> | undefined;
};

/** @internal */
export const BillingPreviewAttachCustomize$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachCustomize$Outbound,
  BillingPreviewAttachCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => BillingPreviewAttachPriceRequest$outboundSchema)),
  ),
  items: z.optional(
    z.array(z.lazy(() => BillingPreviewAttachItem$outboundSchema)),
  ),
});

export function billingPreviewAttachCustomizeToJSON(
  billingPreviewAttachCustomize: BillingPreviewAttachCustomize,
): string {
  return JSON.stringify(
    BillingPreviewAttachCustomize$outboundSchema.parse(
      billingPreviewAttachCustomize,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_product_immediately: boolean;
  finalize_invoice: boolean;
};

/** @internal */
export const BillingPreviewAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachInvoiceMode$Outbound,
  BillingPreviewAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enableProductImmediately: z._default(z.boolean(), false),
    finalizeInvoice: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enableProductImmediately: "enable_product_immediately",
      finalizeInvoice: "finalize_invoice",
    });
  }),
);

export function billingPreviewAttachInvoiceModeToJSON(
  billingPreviewAttachInvoiceMode: BillingPreviewAttachInvoiceMode,
): string {
  return JSON.stringify(
    BillingPreviewAttachInvoiceMode$outboundSchema.parse(
      billingPreviewAttachInvoiceMode,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachDiscountRequest2$Outbound = {
  promotion_code: string;
};

/** @internal */
export const BillingPreviewAttachDiscountRequest2$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachDiscountRequest2$Outbound,
  BillingPreviewAttachDiscountRequest2
> = z.pipe(
  z.object({
    promotionCode: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      promotionCode: "promotion_code",
    });
  }),
);

export function billingPreviewAttachDiscountRequest2ToJSON(
  billingPreviewAttachDiscountRequest2: BillingPreviewAttachDiscountRequest2,
): string {
  return JSON.stringify(
    BillingPreviewAttachDiscountRequest2$outboundSchema.parse(
      billingPreviewAttachDiscountRequest2,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachDiscountRequest1$Outbound = {
  reward_id: string;
};

/** @internal */
export const BillingPreviewAttachDiscountRequest1$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachDiscountRequest1$Outbound,
  BillingPreviewAttachDiscountRequest1
> = z.pipe(
  z.object({
    rewardId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
    });
  }),
);

export function billingPreviewAttachDiscountRequest1ToJSON(
  billingPreviewAttachDiscountRequest1: BillingPreviewAttachDiscountRequest1,
): string {
  return JSON.stringify(
    BillingPreviewAttachDiscountRequest1$outboundSchema.parse(
      billingPreviewAttachDiscountRequest1,
    ),
  );
}

/** @internal */
export type BillingPreviewAttachDiscountUnion$Outbound =
  | BillingPreviewAttachDiscountRequest1$Outbound
  | BillingPreviewAttachDiscountRequest2$Outbound;

/** @internal */
export const BillingPreviewAttachDiscountUnion$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachDiscountUnion$Outbound,
  BillingPreviewAttachDiscountUnion
> = smartUnion([
  z.lazy(() => BillingPreviewAttachDiscountRequest1$outboundSchema),
  z.lazy(() => BillingPreviewAttachDiscountRequest2$outboundSchema),
]);

export function billingPreviewAttachDiscountUnionToJSON(
  billingPreviewAttachDiscountUnion: BillingPreviewAttachDiscountUnion,
): string {
  return JSON.stringify(
    BillingPreviewAttachDiscountUnion$outboundSchema.parse(
      billingPreviewAttachDiscountUnion,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachRedirectMode$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachRedirectMode
> = z.enum(BillingPreviewAttachRedirectMode);

/** @internal */
export const BillingPreviewAttachPlanSchedule$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachPlanSchedule
> = z.enum(BillingPreviewAttachPlanSchedule);

/** @internal */
export const BillingPreviewAttachBillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingPreviewAttachBillingBehavior
> = z.enum(BillingPreviewAttachBillingBehavior);

/** @internal */
export type BillingPreviewAttachRequest$Outbound = {
  customer_id: string;
  entity_id?: string | null | undefined;
  feature_quantities?:
    | Array<BillingPreviewAttachFeatureQuantities$Outbound>
    | null
    | undefined;
  version?: number | undefined;
  free_trial?: BillingPreviewAttachFreeTrial$Outbound | null | undefined;
  customize?: BillingPreviewAttachCustomize$Outbound | undefined;
  plan_id: string;
  invoice_mode?: BillingPreviewAttachInvoiceMode$Outbound | undefined;
  discounts?:
    | Array<
      | BillingPreviewAttachDiscountRequest1$Outbound
      | BillingPreviewAttachDiscountRequest2$Outbound
    >
    | undefined;
  redirect_mode: string;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
  billing_behavior?: string | undefined;
};

/** @internal */
export const BillingPreviewAttachRequest$outboundSchema: z.ZodMiniType<
  BillingPreviewAttachRequest$Outbound,
  BillingPreviewAttachRequest
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.nullable(z.string())),
    featureQuantities: z.optional(z.nullable(z.array(z.lazy(() =>
      BillingPreviewAttachFeatureQuantities$outboundSchema
    )))),
    version: z.optional(z.number()),
    freeTrial: z.optional(z.nullable(z.lazy(() =>
      BillingPreviewAttachFreeTrial$outboundSchema
    ))),
    customize: z.optional(z.lazy(() =>
      BillingPreviewAttachCustomize$outboundSchema
    )),
    planId: z.string(),
    invoiceMode: z.optional(z.lazy(() =>
      BillingPreviewAttachInvoiceMode$outboundSchema
    )),
    discounts: z.optional(z.array(smartUnion([
      z.lazy(() => BillingPreviewAttachDiscountRequest1$outboundSchema),
      z.lazy(() =>
        BillingPreviewAttachDiscountRequest2$outboundSchema
      ),
    ]))),
    redirectMode: z._default(
      BillingPreviewAttachRedirectMode$outboundSchema,
      "always",
    ),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(BillingPreviewAttachPlanSchedule$outboundSchema),
    billingBehavior: z.optional(
      BillingPreviewAttachBillingBehavior$outboundSchema,
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      featureQuantities: "feature_quantities",
      freeTrial: "free_trial",
      planId: "plan_id",
      invoiceMode: "invoice_mode",
      redirectMode: "redirect_mode",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
      billingBehavior: "billing_behavior",
    });
  }),
);

export function billingPreviewAttachRequestToJSON(
  billingPreviewAttachRequest: BillingPreviewAttachRequest,
): string {
  return JSON.stringify(
    BillingPreviewAttachRequest$outboundSchema.parse(
      billingPreviewAttachRequest,
    ),
  );
}

/** @internal */
export const BillingPreviewAttachDiscountResponse$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachDiscountResponse,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function billingPreviewAttachDiscountResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachDiscountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewAttachDiscountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachDiscountResponse' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachEffectivePeriod$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachEffectivePeriod,
  unknown
> = z.object({
  start: types.number(),
  end: types.number(),
});

export function billingPreviewAttachEffectivePeriodFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachEffectivePeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewAttachEffectivePeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachEffectivePeriod' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachLineItem$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachLineItem,
  unknown
> = z.pipe(
  z.object({
    title: types.string(),
    description: types.string(),
    amount: types.number(),
    discounts: types.optional(
      z.array(z.lazy(() => BillingPreviewAttachDiscountResponse$inboundSchema)),
    ),
    is_base: types.optional(types.boolean()),
    total_quantity: types.number(),
    paid_quantity: types.number(),
    plan_id: types.string(),
    deferred_for_trial: types.optional(types.boolean()),
    effective_period: types.optional(
      z.lazy(() => BillingPreviewAttachEffectivePeriod$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_base": "isBase",
      "total_quantity": "totalQuantity",
      "paid_quantity": "paidQuantity",
      "plan_id": "planId",
      "deferred_for_trial": "deferredForTrial",
      "effective_period": "effectivePeriod",
    });
  }),
);

export function billingPreviewAttachLineItemFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewAttachLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachLineItem' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachCredit$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachCredit,
  unknown
> = z.object({
  amount: types.number(),
  description: types.string(),
});

export function billingPreviewAttachCreditFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachCredit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewAttachCredit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachCredit' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachNextCycleDiscount$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachNextCycleDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function billingPreviewAttachNextCycleDiscountFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachNextCycleDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewAttachNextCycleDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachNextCycleDiscount' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachNextCycleEffectivePeriod$inboundSchema:
  z.ZodMiniType<BillingPreviewAttachNextCycleEffectivePeriod, unknown> = z
    .object({
      start: types.number(),
      end: types.number(),
    });

export function billingPreviewAttachNextCycleEffectivePeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  BillingPreviewAttachNextCycleEffectivePeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewAttachNextCycleEffectivePeriod$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BillingPreviewAttachNextCycleEffectivePeriod' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachNextCycleLineItem$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachNextCycleLineItem,
  unknown
> = z.pipe(
  z.object({
    title: types.string(),
    description: types.string(),
    amount: types.number(),
    discounts: types.optional(
      z.array(
        z.lazy(() => BillingPreviewAttachNextCycleDiscount$inboundSchema),
      ),
    ),
    is_base: types.optional(types.boolean()),
    total_quantity: types.number(),
    paid_quantity: types.number(),
    plan_id: types.string(),
    deferred_for_trial: types.optional(types.boolean()),
    effective_period: types.optional(
      z.lazy(() => BillingPreviewAttachNextCycleEffectivePeriod$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_base": "isBase",
      "total_quantity": "totalQuantity",
      "paid_quantity": "paidQuantity",
      "plan_id": "planId",
      "deferred_for_trial": "deferredForTrial",
      "effective_period": "effectivePeriod",
    });
  }),
);

export function billingPreviewAttachNextCycleLineItemFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachNextCycleLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BillingPreviewAttachNextCycleLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachNextCycleLineItem' from JSON`,
  );
}

/** @internal */
export const BillingPreviewAttachNextCycle$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
    line_items: z.array(
      z.lazy(() => BillingPreviewAttachNextCycleLineItem$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
      "line_items": "lineItems",
    });
  }),
);

export function billingPreviewAttachNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewAttachNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachNextCycle' from JSON`,
  );
}

/** @internal */
export const IncomingFeatureQuantity$inboundSchema: z.ZodMiniType<
  IncomingFeatureQuantity,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function incomingFeatureQuantityFromJSON(
  jsonString: string,
): SafeParseResult<IncomingFeatureQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingFeatureQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingFeatureQuantity' from JSON`,
  );
}

/** @internal */
export const IncomingType$inboundSchema: z.ZodMiniType<IncomingType, unknown> =
  openEnums.inboundSchema(IncomingType);

/** @internal */
export const IncomingCreditSchema$inboundSchema: z.ZodMiniType<
  IncomingCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function incomingCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<IncomingCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingCreditSchema' from JSON`,
  );
}

/** @internal */
export const IncomingDisplay$inboundSchema: z.ZodMiniType<
  IncomingDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function incomingDisplayFromJSON(
  jsonString: string,
): SafeParseResult<IncomingDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingDisplay' from JSON`,
  );
}

/** @internal */
export const IncomingFeature$inboundSchema: z.ZodMiniType<
  IncomingFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: IncomingType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => IncomingCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => IncomingDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function incomingFeatureFromJSON(
  jsonString: string,
): SafeParseResult<IncomingFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingFeature' from JSON`,
  );
}

/** @internal */
export const IntervalIncomingEnum$inboundSchema: z.ZodMiniType<
  IntervalIncomingEnum,
  unknown
> = openEnums.inboundSchema(IntervalIncomingEnum);

/** @internal */
export const IncomingIntervalUnion$inboundSchema: z.ZodMiniType<
  IncomingIntervalUnion,
  unknown
> = smartUnion([IntervalIncomingEnum$inboundSchema, types.string()]);

export function incomingIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<IncomingIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingIntervalUnion' from JSON`,
  );
}

/** @internal */
export const IncomingReset$inboundSchema: z.ZodMiniType<
  IncomingReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([IntervalIncomingEnum$inboundSchema, types.string()]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function incomingResetFromJSON(
  jsonString: string,
): SafeParseResult<IncomingReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingReset' from JSON`,
  );
}

/** @internal */
export const IncomingTier$inboundSchema: z.ZodMiniType<IncomingTier, unknown> =
  z.object({
    to: types.optional(z.any()),
    amount: types.number(),
  });

export function incomingTierFromJSON(
  jsonString: string,
): SafeParseResult<IncomingTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingTier' from JSON`,
  );
}

/** @internal */
export const IncomingBillingMethod$inboundSchema: z.ZodMiniType<
  IncomingBillingMethod,
  unknown
> = openEnums.inboundSchema(IncomingBillingMethod);

/** @internal */
export const IncomingPrice$inboundSchema: z.ZodMiniType<
  IncomingPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(z.array(z.lazy(() => IncomingTier$inboundSchema))),
    billing_units: types.number(),
    billing_method: IncomingBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function incomingPriceFromJSON(
  jsonString: string,
): SafeParseResult<IncomingPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingPrice' from JSON`,
  );
}

/** @internal */
export const IncomingBreakdown$inboundSchema: z.ZodMiniType<
  IncomingBreakdown,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance_breakdown"),
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => IncomingReset$inboundSchema)),
    price: types.nullable(z.lazy(() => IncomingPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function incomingBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<IncomingBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingBreakdown' from JSON`,
  );
}

/** @internal */
export const IncomingRollover$inboundSchema: z.ZodMiniType<
  IncomingRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function incomingRolloverFromJSON(
  jsonString: string,
): SafeParseResult<IncomingRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingRollover' from JSON`,
  );
}

/** @internal */
export const IncomingBalances$inboundSchema: z.ZodMiniType<
  IncomingBalances,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance"),
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => IncomingFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => IncomingBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => IncomingRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function incomingBalancesFromJSON(
  jsonString: string,
): SafeParseResult<IncomingBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncomingBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncomingBalances' from JSON`,
  );
}

/** @internal */
export const Incoming$inboundSchema: z.ZodMiniType<Incoming, unknown> = z.pipe(
  z.object({
    plan: Plan$inboundSchema,
    feature_quantities: z.array(z.lazy(() =>
      IncomingFeatureQuantity$inboundSchema
    )),
    balances: z.record(
      z.string(),
      z.lazy(() => IncomingBalances$inboundSchema),
    ),
    period_start: types.optional(types.number()),
    period_end: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_quantities": "featureQuantities",
      "period_start": "periodStart",
      "period_end": "periodEnd",
    });
  }),
);

export function incomingFromJSON(
  jsonString: string,
): SafeParseResult<Incoming, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Incoming$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Incoming' from JSON`,
  );
}

/** @internal */
export const OutgoingFeatureQuantity$inboundSchema: z.ZodMiniType<
  OutgoingFeatureQuantity,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
    });
  }),
);

export function outgoingFeatureQuantityFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingFeatureQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingFeatureQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingFeatureQuantity' from JSON`,
  );
}

/** @internal */
export const OutgoingType$inboundSchema: z.ZodMiniType<OutgoingType, unknown> =
  openEnums.inboundSchema(OutgoingType);

/** @internal */
export const OutgoingCreditSchema$inboundSchema: z.ZodMiniType<
  OutgoingCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function outgoingCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingCreditSchema' from JSON`,
  );
}

/** @internal */
export const OutgoingDisplay$inboundSchema: z.ZodMiniType<
  OutgoingDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function outgoingDisplayFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingDisplay' from JSON`,
  );
}

/** @internal */
export const OutgoingFeature$inboundSchema: z.ZodMiniType<
  OutgoingFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: OutgoingType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => OutgoingCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => OutgoingDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function outgoingFeatureFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingFeature' from JSON`,
  );
}

/** @internal */
export const IntervalOutgoingEnum$inboundSchema: z.ZodMiniType<
  IntervalOutgoingEnum,
  unknown
> = openEnums.inboundSchema(IntervalOutgoingEnum);

/** @internal */
export const OutgoingIntervalUnion$inboundSchema: z.ZodMiniType<
  OutgoingIntervalUnion,
  unknown
> = smartUnion([IntervalOutgoingEnum$inboundSchema, types.string()]);

export function outgoingIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingIntervalUnion' from JSON`,
  );
}

/** @internal */
export const OutgoingReset$inboundSchema: z.ZodMiniType<
  OutgoingReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([IntervalOutgoingEnum$inboundSchema, types.string()]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function outgoingResetFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingReset' from JSON`,
  );
}

/** @internal */
export const OutgoingTier$inboundSchema: z.ZodMiniType<OutgoingTier, unknown> =
  z.object({
    to: types.optional(z.any()),
    amount: types.number(),
  });

export function outgoingTierFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingTier' from JSON`,
  );
}

/** @internal */
export const OutgoingBillingMethod$inboundSchema: z.ZodMiniType<
  OutgoingBillingMethod,
  unknown
> = openEnums.inboundSchema(OutgoingBillingMethod);

/** @internal */
export const OutgoingPrice$inboundSchema: z.ZodMiniType<
  OutgoingPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(z.array(z.lazy(() => OutgoingTier$inboundSchema))),
    billing_units: types.number(),
    billing_method: OutgoingBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function outgoingPriceFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingPrice' from JSON`,
  );
}

/** @internal */
export const OutgoingBreakdown$inboundSchema: z.ZodMiniType<
  OutgoingBreakdown,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance_breakdown"),
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => OutgoingReset$inboundSchema)),
    price: types.nullable(z.lazy(() => OutgoingPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function outgoingBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingBreakdown' from JSON`,
  );
}

/** @internal */
export const OutgoingRollover$inboundSchema: z.ZodMiniType<
  OutgoingRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function outgoingRolloverFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingRollover' from JSON`,
  );
}

/** @internal */
export const OutgoingBalances$inboundSchema: z.ZodMiniType<
  OutgoingBalances,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance"),
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => OutgoingFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => OutgoingBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => OutgoingRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function outgoingBalancesFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingBalances' from JSON`,
  );
}

/** @internal */
export const Outgoing$inboundSchema: z.ZodMiniType<Outgoing, unknown> = z.pipe(
  z.object({
    plan: Plan$inboundSchema,
    feature_quantities: z.array(z.lazy(() =>
      OutgoingFeatureQuantity$inboundSchema
    )),
    balances: z.record(
      z.string(),
      z.lazy(() => OutgoingBalances$inboundSchema),
    ),
    period_start: types.optional(types.number()),
    period_end: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_quantities": "featureQuantities",
      "period_start": "periodStart",
      "period_end": "periodEnd",
    });
  }),
);

export function outgoingFromJSON(
  jsonString: string,
): SafeParseResult<Outgoing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Outgoing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Outgoing' from JSON`,
  );
}

/** @internal */
export const RedirectType$inboundSchema: z.ZodMiniType<RedirectType, unknown> =
  openEnums.inboundSchema(RedirectType);

/** @internal */
export const BillingPreviewAttachResponse$inboundSchema: z.ZodMiniType<
  BillingPreviewAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(
      z.lazy(() => BillingPreviewAttachLineItem$inboundSchema),
    ),
    total: types.number(),
    currency: types.string(),
    period_start: types.optional(types.number()),
    period_end: types.optional(types.number()),
    credit: types.optional(
      z.lazy(() => BillingPreviewAttachCredit$inboundSchema),
    ),
    next_cycle: types.optional(
      z.lazy(() => BillingPreviewAttachNextCycle$inboundSchema),
    ),
    incoming: z.array(z.lazy(() => Incoming$inboundSchema)),
    outgoing: z.array(z.lazy(() => Outgoing$inboundSchema)),
    redirect_type: types.nullable(RedirectType$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "period_start": "periodStart",
      "period_end": "periodEnd",
      "next_cycle": "nextCycle",
      "redirect_type": "redirectType",
    });
  }),
);

export function billingPreviewAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingPreviewAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingPreviewAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingPreviewAttachResponse' from JSON`,
  );
}
