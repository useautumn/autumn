/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type PreviewAttachGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type PreviewAttachFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const PreviewAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type PreviewAttachPriceInterval = ClosedEnum<
  typeof PreviewAttachPriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type PreviewAttachBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: PreviewAttachPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const PreviewAttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type PreviewAttachResetInterval = ClosedEnum<
  typeof PreviewAttachResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type PreviewAttachReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: PreviewAttachResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type PreviewAttachTo = number | string;

export type PreviewAttachTier = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const PreviewAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type PreviewAttachItemPriceInterval = ClosedEnum<
  typeof PreviewAttachItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const PreviewAttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type PreviewAttachBillingMethod = ClosedEnum<
  typeof PreviewAttachBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type PreviewAttachPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<PreviewAttachTier> | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: PreviewAttachItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: PreviewAttachBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const PreviewAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type PreviewAttachOnIncrease = ClosedEnum<
  typeof PreviewAttachOnIncrease
>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const PreviewAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type PreviewAttachOnDecrease = ClosedEnum<
  typeof PreviewAttachOnDecrease
>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type PreviewAttachProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: PreviewAttachOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: PreviewAttachOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const PreviewAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type PreviewAttachExpiryDurationType = ClosedEnum<
  typeof PreviewAttachExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type PreviewAttachRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: PreviewAttachExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type PreviewAttachPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: PreviewAttachReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: PreviewAttachPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: PreviewAttachProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: PreviewAttachRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const PreviewAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type PreviewAttachDurationType = ClosedEnum<
  typeof PreviewAttachDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type PreviewAttachFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: PreviewAttachDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type PreviewAttachCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: PreviewAttachBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<PreviewAttachPlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: PreviewAttachFreeTrialParams | null | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type PreviewAttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const PreviewAttachProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type PreviewAttachProrationBehavior = ClosedEnum<
  typeof PreviewAttachProrationBehavior
>;

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type PreviewAttachAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export const PreviewAttachPlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export type PreviewAttachPlanSchedule = ClosedEnum<
  typeof PreviewAttachPlanSchedule
>;

export type PreviewAttachParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<PreviewAttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: PreviewAttachCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: PreviewAttachInvoiceMode | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: PreviewAttachProrationBehavior | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<PreviewAttachAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
   */
  planSchedule?: PreviewAttachPlanSchedule | undefined;
};

export type PreviewAttachDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type PreviewAttachLineItem = {
  /**
   * The title of the line item.
   */
  title: string;
  /**
   * A detailed description of the line item.
   */
  description: string;
  /**
   * The amount in cents for this line item.
   */
  amount: number;
  /**
   * List of discounts applied to this line item.
   */
  discounts?: Array<PreviewAttachDiscount> | undefined;
};

/**
 * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
 */
export type PreviewAttachNextCycle = {
  /**
   * Unix timestamp (milliseconds) when the next billing cycle starts.
   */
  startsAt: number;
  /**
   * The total amount in cents for the next cycle.
   */
  total: number;
};

/**
 * OK
 */
export type PreviewAttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * List of line items for the current billing period.
   */
  lineItems: Array<PreviewAttachLineItem>;
  /**
   * The total amount in cents for the current billing period.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
   */
  nextCycle?: PreviewAttachNextCycle | undefined;
};

/** @internal */
export type PreviewAttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const PreviewAttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  PreviewAttachFeatureQuantity$Outbound,
  PreviewAttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewAttachFeatureQuantityToJSON(
  previewAttachFeatureQuantity: PreviewAttachFeatureQuantity,
): string {
  return JSON.stringify(
    PreviewAttachFeatureQuantity$outboundSchema.parse(
      previewAttachFeatureQuantity,
    ),
  );
}

/** @internal */
export const PreviewAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachPriceInterval
> = z.enum(PreviewAttachPriceInterval);

/** @internal */
export type PreviewAttachBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewAttachBasePrice$outboundSchema: z.ZodMiniType<
  PreviewAttachBasePrice$Outbound,
  PreviewAttachBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: PreviewAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewAttachBasePriceToJSON(
  previewAttachBasePrice: PreviewAttachBasePrice,
): string {
  return JSON.stringify(
    PreviewAttachBasePrice$outboundSchema.parse(previewAttachBasePrice),
  );
}

/** @internal */
export const PreviewAttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachResetInterval
> = z.enum(PreviewAttachResetInterval);

/** @internal */
export type PreviewAttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewAttachReset$outboundSchema: z.ZodMiniType<
  PreviewAttachReset$Outbound,
  PreviewAttachReset
> = z.pipe(
  z.object({
    interval: PreviewAttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewAttachResetToJSON(
  previewAttachReset: PreviewAttachReset,
): string {
  return JSON.stringify(
    PreviewAttachReset$outboundSchema.parse(previewAttachReset),
  );
}

/** @internal */
export type PreviewAttachTo$Outbound = number | string;

/** @internal */
export const PreviewAttachTo$outboundSchema: z.ZodMiniType<
  PreviewAttachTo$Outbound,
  PreviewAttachTo
> = smartUnion([z.number(), z.string()]);

export function previewAttachToToJSON(
  previewAttachTo: PreviewAttachTo,
): string {
  return JSON.stringify(PreviewAttachTo$outboundSchema.parse(previewAttachTo));
}

/** @internal */
export type PreviewAttachTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const PreviewAttachTier$outboundSchema: z.ZodMiniType<
  PreviewAttachTier$Outbound,
  PreviewAttachTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function previewAttachTierToJSON(
  previewAttachTier: PreviewAttachTier,
): string {
  return JSON.stringify(
    PreviewAttachTier$outboundSchema.parse(previewAttachTier),
  );
}

/** @internal */
export const PreviewAttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachItemPriceInterval
> = z.enum(PreviewAttachItemPriceInterval);

/** @internal */
export const PreviewAttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachBillingMethod
> = z.enum(PreviewAttachBillingMethod);

/** @internal */
export type PreviewAttachPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<PreviewAttachTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const PreviewAttachPrice$outboundSchema: z.ZodMiniType<
  PreviewAttachPrice$Outbound,
  PreviewAttachPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => PreviewAttachTier$outboundSchema))),
    interval: PreviewAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: PreviewAttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function previewAttachPriceToJSON(
  previewAttachPrice: PreviewAttachPrice,
): string {
  return JSON.stringify(
    PreviewAttachPrice$outboundSchema.parse(previewAttachPrice),
  );
}

/** @internal */
export const PreviewAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachOnIncrease
> = z.enum(PreviewAttachOnIncrease);

/** @internal */
export const PreviewAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachOnDecrease
> = z.enum(PreviewAttachOnDecrease);

/** @internal */
export type PreviewAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const PreviewAttachProration$outboundSchema: z.ZodMiniType<
  PreviewAttachProration$Outbound,
  PreviewAttachProration
> = z.pipe(
  z.object({
    onIncrease: PreviewAttachOnIncrease$outboundSchema,
    onDecrease: PreviewAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function previewAttachProrationToJSON(
  previewAttachProration: PreviewAttachProration,
): string {
  return JSON.stringify(
    PreviewAttachProration$outboundSchema.parse(previewAttachProration),
  );
}

/** @internal */
export const PreviewAttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachExpiryDurationType
> = z.enum(PreviewAttachExpiryDurationType);

/** @internal */
export type PreviewAttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const PreviewAttachRollover$outboundSchema: z.ZodMiniType<
  PreviewAttachRollover$Outbound,
  PreviewAttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: PreviewAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function previewAttachRolloverToJSON(
  previewAttachRollover: PreviewAttachRollover,
): string {
  return JSON.stringify(
    PreviewAttachRollover$outboundSchema.parse(previewAttachRollover),
  );
}

/** @internal */
export type PreviewAttachPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: PreviewAttachReset$Outbound | undefined;
  price?: PreviewAttachPrice$Outbound | undefined;
  proration?: PreviewAttachProration$Outbound | undefined;
  rollover?: PreviewAttachRollover$Outbound | undefined;
};

/** @internal */
export const PreviewAttachPlanItem$outboundSchema: z.ZodMiniType<
  PreviewAttachPlanItem$Outbound,
  PreviewAttachPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => PreviewAttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => PreviewAttachPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => PreviewAttachProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => PreviewAttachRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewAttachPlanItemToJSON(
  previewAttachPlanItem: PreviewAttachPlanItem,
): string {
  return JSON.stringify(
    PreviewAttachPlanItem$outboundSchema.parse(previewAttachPlanItem),
  );
}

/** @internal */
export const PreviewAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachDurationType
> = z.enum(PreviewAttachDurationType);

/** @internal */
export type PreviewAttachFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const PreviewAttachFreeTrialParams$outboundSchema: z.ZodMiniType<
  PreviewAttachFreeTrialParams$Outbound,
  PreviewAttachFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(PreviewAttachDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function previewAttachFreeTrialParamsToJSON(
  previewAttachFreeTrialParams: PreviewAttachFreeTrialParams,
): string {
  return JSON.stringify(
    PreviewAttachFreeTrialParams$outboundSchema.parse(
      previewAttachFreeTrialParams,
    ),
  );
}

/** @internal */
export type PreviewAttachCustomize$Outbound = {
  price?: PreviewAttachBasePrice$Outbound | null | undefined;
  items?: Array<PreviewAttachPlanItem$Outbound> | undefined;
  free_trial?: PreviewAttachFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const PreviewAttachCustomize$outboundSchema: z.ZodMiniType<
  PreviewAttachCustomize$Outbound,
  PreviewAttachCustomize
> = z.pipe(
  z.object({
    price: z.optional(
      z.nullable(z.lazy(() => PreviewAttachBasePrice$outboundSchema)),
    ),
    items: z.optional(
      z.array(z.lazy(() => PreviewAttachPlanItem$outboundSchema)),
    ),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => PreviewAttachFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function previewAttachCustomizeToJSON(
  previewAttachCustomize: PreviewAttachCustomize,
): string {
  return JSON.stringify(
    PreviewAttachCustomize$outboundSchema.parse(previewAttachCustomize),
  );
}

/** @internal */
export type PreviewAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const PreviewAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  PreviewAttachInvoiceMode$Outbound,
  PreviewAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function previewAttachInvoiceModeToJSON(
  previewAttachInvoiceMode: PreviewAttachInvoiceMode,
): string {
  return JSON.stringify(
    PreviewAttachInvoiceMode$outboundSchema.parse(previewAttachInvoiceMode),
  );
}

/** @internal */
export const PreviewAttachProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachProrationBehavior
> = z.enum(PreviewAttachProrationBehavior);

/** @internal */
export type PreviewAttachAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const PreviewAttachAttachDiscount$outboundSchema: z.ZodMiniType<
  PreviewAttachAttachDiscount$Outbound,
  PreviewAttachAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function previewAttachAttachDiscountToJSON(
  previewAttachAttachDiscount: PreviewAttachAttachDiscount,
): string {
  return JSON.stringify(
    PreviewAttachAttachDiscount$outboundSchema.parse(
      previewAttachAttachDiscount,
    ),
  );
}

/** @internal */
export const PreviewAttachPlanSchedule$outboundSchema: z.ZodMiniEnum<
  typeof PreviewAttachPlanSchedule
> = z.enum(PreviewAttachPlanSchedule);

/** @internal */
export type PreviewAttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<PreviewAttachFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: PreviewAttachCustomize$Outbound | undefined;
  invoice_mode?: PreviewAttachInvoiceMode$Outbound | undefined;
  proration_behavior?: string | undefined;
  discounts?: Array<PreviewAttachAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
};

/** @internal */
export const PreviewAttachParams$outboundSchema: z.ZodMiniType<
  PreviewAttachParams$Outbound,
  PreviewAttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => PreviewAttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => PreviewAttachCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => PreviewAttachInvoiceMode$outboundSchema),
    ),
    prorationBehavior: z.optional(
      PreviewAttachProrationBehavior$outboundSchema,
    ),
    discounts: z.optional(
      z.array(z.lazy(() => PreviewAttachAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(PreviewAttachPlanSchedule$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      invoiceMode: "invoice_mode",
      prorationBehavior: "proration_behavior",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
    });
  }),
);

export function previewAttachParamsToJSON(
  previewAttachParams: PreviewAttachParams,
): string {
  return JSON.stringify(
    PreviewAttachParams$outboundSchema.parse(previewAttachParams),
  );
}

/** @internal */
export const PreviewAttachDiscount$inboundSchema: z.ZodMiniType<
  PreviewAttachDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function previewAttachDiscountFromJSON(
  jsonString: string,
): SafeParseResult<PreviewAttachDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewAttachDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewAttachDiscount' from JSON`,
  );
}

/** @internal */
export const PreviewAttachLineItem$inboundSchema: z.ZodMiniType<
  PreviewAttachLineItem,
  unknown
> = z.object({
  title: types.string(),
  description: types.string(),
  amount: types.number(),
  discounts: types.optional(
    z.array(z.lazy(() => PreviewAttachDiscount$inboundSchema)),
  ),
});

export function previewAttachLineItemFromJSON(
  jsonString: string,
): SafeParseResult<PreviewAttachLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewAttachLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewAttachLineItem' from JSON`,
  );
}

/** @internal */
export const PreviewAttachNextCycle$inboundSchema: z.ZodMiniType<
  PreviewAttachNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
    });
  }),
);

export function previewAttachNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<PreviewAttachNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewAttachNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewAttachNextCycle' from JSON`,
  );
}

/** @internal */
export const PreviewAttachResponse$inboundSchema: z.ZodMiniType<
  PreviewAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(z.lazy(() => PreviewAttachLineItem$inboundSchema)),
    total: types.number(),
    currency: types.string(),
    next_cycle: types.optional(
      z.lazy(() => PreviewAttachNextCycle$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "next_cycle": "nextCycle",
    });
  }),
);

export function previewAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<PreviewAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewAttachResponse' from JSON`,
  );
}
