/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { Balance, Balance$inboundSchema } from "./balance.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type GetEntityGlobals = {
  xApiVersion?: string | undefined;
};

export type GetEntityParams = {
  /**
   * The ID of the customer to create the entity for.
   */
  customerId?: string | undefined;
  /**
   * The ID of the entity.
   */
  entityId: string;
};

/**
 * The environment (sandbox/live)
 */
export const GetEntityEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment (sandbox/live)
 */
export type GetEntityEnv = OpenEnum<typeof GetEntityEnv>;

/**
 * Current status of the subscription.
 */
export const GetEntityStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Current status of the subscription.
 */
export type GetEntityStatus = OpenEnum<typeof GetEntityStatus>;

export type GetEntitySubscription = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the subscribed plan.
   */
  planId: string;
  /**
   * Whether the plan was automatically enabled for the customer.
   */
  autoEnable: boolean;
  /**
   * Whether this is an add-on plan rather than a base subscription.
   */
  addOn: boolean;
  /**
   * Current status of the subscription.
   */
  status: GetEntityStatus;
  /**
   * Whether the subscription has overdue payments.
   */
  pastDue: boolean;
  /**
   * Timestamp when the subscription was canceled, or null if not canceled.
   */
  canceledAt: number | null;
  /**
   * Timestamp when the subscription will expire, or null if no expiry set.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the trial period ends, or null if not on trial.
   */
  trialEndsAt: number | null;
  /**
   * Timestamp when the subscription started.
   */
  startedAt: number;
  /**
   * Start timestamp of the current billing period.
   */
  currentPeriodStart: number | null;
  /**
   * End timestamp of the current billing period.
   */
  currentPeriodEnd: number | null;
  /**
   * Number of units of this subscription (for per-seat plans).
   */
  quantity: number;
};

export type GetEntityPurchase = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the purchased plan.
   */
  planId: string;
  /**
   * Timestamp when the purchase expires, or null for lifetime access.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the purchase was made.
   */
  startedAt: number;
  /**
   * Number of units purchased.
   */
  quantity: number;
};

export type GetEntityInvoice = {
  /**
   * Array of plan IDs included in this invoice
   */
  planIds: Array<string>;
  /**
   * The Stripe invoice ID
   */
  stripeId: string;
  /**
   * The status of the invoice
   */
  status: string;
  /**
   * The total amount of the invoice
   */
  total: number;
  /**
   * The currency code for the invoice
   */
  currency: string;
  /**
   * Timestamp when the invoice was created
   */
  createdAt: number;
  /**
   * URL to the Stripe-hosted invoice page
   */
  hostedInvoiceUrl?: string | null | undefined;
};

/**
 * OK
 */
export type GetEntityResponse = {
  autumnId?: string | undefined;
  /**
   * The unique identifier of the entity
   */
  id: string | null;
  /**
   * The name of the entity
   */
  name: string | null;
  /**
   * The customer ID this entity belongs to
   */
  customerId?: string | null | undefined;
  /**
   * The feature ID this entity belongs to
   */
  featureId?: string | null | undefined;
  /**
   * Unix timestamp when the entity was created
   */
  createdAt: number;
  /**
   * The environment (sandbox/live)
   */
  env: GetEntityEnv;
  subscriptions: Array<GetEntitySubscription>;
  purchases: Array<GetEntityPurchase>;
  balances: { [k: string]: Balance };
  /**
   * Invoices for this entity (only included when expand=invoices)
   */
  invoices?: Array<GetEntityInvoice> | undefined;
};

/** @internal */
export type GetEntityParams$Outbound = {
  customer_id?: string | undefined;
  entity_id: string;
};

/** @internal */
export const GetEntityParams$outboundSchema: z.ZodMiniType<
  GetEntityParams$Outbound,
  GetEntityParams
> = z.pipe(
  z.object({
    customerId: z.optional(z.string()),
    entityId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
    });
  }),
);

export function getEntityParamsToJSON(
  getEntityParams: GetEntityParams,
): string {
  return JSON.stringify(GetEntityParams$outboundSchema.parse(getEntityParams));
}

/** @internal */
export const GetEntityEnv$inboundSchema: z.ZodMiniType<GetEntityEnv, unknown> =
  openEnums.inboundSchema(GetEntityEnv);

/** @internal */
export const GetEntityStatus$inboundSchema: z.ZodMiniType<
  GetEntityStatus,
  unknown
> = openEnums.inboundSchema(GetEntityStatus);

/** @internal */
export const GetEntitySubscription$inboundSchema: z.ZodMiniType<
  GetEntitySubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: GetEntityStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function getEntitySubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<GetEntitySubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetEntitySubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetEntitySubscription' from JSON`,
  );
}

/** @internal */
export const GetEntityPurchase$inboundSchema: z.ZodMiniType<
  GetEntityPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function getEntityPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<GetEntityPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetEntityPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetEntityPurchase' from JSON`,
  );
}

/** @internal */
export const GetEntityInvoice$inboundSchema: z.ZodMiniType<
  GetEntityInvoice,
  unknown
> = z.pipe(
  z.object({
    plan_ids: z.array(types.string()),
    stripe_id: types.string(),
    status: types.string(),
    total: types.number(),
    currency: types.string(),
    created_at: types.number(),
    hosted_invoice_url: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_ids": "planIds",
      "stripe_id": "stripeId",
      "created_at": "createdAt",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function getEntityInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<GetEntityInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetEntityInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetEntityInvoice' from JSON`,
  );
}

/** @internal */
export const GetEntityResponse$inboundSchema: z.ZodMiniType<
  GetEntityResponse,
  unknown
> = z.pipe(
  z.object({
    autumn_id: types.optional(types.string()),
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    customer_id: z.optional(z.nullable(types.string())),
    feature_id: z.optional(z.nullable(types.string())),
    created_at: types.number(),
    env: GetEntityEnv$inboundSchema,
    subscriptions: z.array(z.lazy(() => GetEntitySubscription$inboundSchema)),
    purchases: z.array(z.lazy(() => GetEntityPurchase$inboundSchema)),
    balances: z.record(z.string(), Balance$inboundSchema),
    invoices: types.optional(
      z.array(z.lazy(() => GetEntityInvoice$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "autumn_id": "autumnId",
      "customer_id": "customerId",
      "feature_id": "featureId",
      "created_at": "createdAt",
    });
  }),
);

export function getEntityResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetEntityResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetEntityResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetEntityResponse' from JSON`,
  );
}
