/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type AttachGlobals = {
  xApiVersion?: string | undefined;
};

export type Options = {
  featureId: string;
  quantity?: number | undefined;
  resetAfterTrialEnd?: boolean | undefined;
};

export const Duration = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type Duration = ClosedEnum<typeof Duration>;

export type AttachFreeTrial = {
  length: number;
  duration: Duration;
  cardRequired?: boolean | undefined;
};

export const AttachType = {
  Feature: "feature",
  PricedFeature: "priced_feature",
  Price: "price",
} as const;
export type AttachType = ClosedEnum<typeof AttachType>;

export type IncludedUsage = number | string;

export const AttachInterval = {
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type AttachInterval = ClosedEnum<typeof AttachInterval>;

export const UsageModel = {
  Prepaid: "prepaid",
  PayPerUse: "pay_per_use",
} as const;
export type UsageModel = ClosedEnum<typeof UsageModel>;

/**
 * The maximum amount of usage for this tier.
 */
export type AttachTo = number | string;

export type Tiers = {
  /**
   * The maximum amount of usage for this tier.
   */
  to: number | string;
  /**
   * The price of the product item for this tier.
   */
  amount: number;
};

export type AttachItem = {
  /**
   * The type of the product item.
   */
  type?: AttachType | null | undefined;
  /**
   * The feature ID of the product item. Should be null for fixed price items.
   */
  featureId?: string | null | undefined;
  /**
   * The amount of usage included for this feature (per interval).
   */
  includedUsage?: number | string | null | undefined;
  /**
   * The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off.
   */
  interval?: AttachInterval | null | undefined;
  /**
   * Interval count of the feature.
   */
  intervalCount?: number | null | undefined;
  /**
   * The feature ID of the entity (like seats) to track sub-balances for.
   */
  entityFeatureId?: string | null | undefined;
  /**
   * Whether the feature should be prepaid upfront or billed for how much they use end of billing period.
   */
  usageModel?: UsageModel | null | undefined;
  /**
   * The price of the product item. Should be null if tiered pricing is set.
   */
  price?: number | null | undefined;
  /**
   * Tiered pricing for the product item. Not applicable for fixed price items.
   */
  tiers?: Array<Tiers> | null | undefined;
  /**
   * The billing units of the product item (eg $1 for 30 credits).
   */
  billingUnits?: number | null | undefined;
  /**
   * Whether the usage should be reset when the product is enabled.
   */
  resetUsageWhenEnabled?: boolean | null | undefined;
};

export const RedirectMode = {
  Always: "always",
  IfRequired: "if_required",
  Never: "never",
} as const;
export type RedirectMode = ClosedEnum<typeof RedirectMode>;

export const PlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
export type PlanSchedule = ClosedEnum<typeof PlanSchedule>;

export const BillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
export type BillingBehavior = ClosedEnum<typeof BillingBehavior>;

export type AttachRequest = {
  options?: Array<Options> | null | undefined;
  version?: number | undefined;
  freeTrial?: AttachFreeTrial | null | undefined;
  items?: Array<AttachItem> | undefined;
  productId: string;
  invoice?: boolean | undefined;
  enableProductImmediately?: boolean | undefined;
  finalizeInvoice?: boolean | undefined;
  redirectMode?: RedirectMode | undefined;
  successUrl?: string | undefined;
  newBillingSubscription?: boolean | undefined;
  planSchedule?: PlanSchedule | undefined;
  billingBehavior?: BillingBehavior | undefined;
  adjustableQuantity?: boolean | undefined;
};

export type AttachInvoice = {
  status: string | null;
  stripeId: string;
  total: number;
  currency: string;
  hostedInvoiceUrl: string | null;
};

export const Code = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
export type Code = OpenEnum<typeof Code>;

export type RequiredAction = {
  code: Code;
  reason: string;
};

/**
 * OK
 */
export type AttachResponse = {
  customerId: string;
  invoice?: AttachInvoice | undefined;
  paymentUrl: string | null;
  requiredAction?: RequiredAction | undefined;
};

/** @internal */
export type Options$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  reset_after_trial_end: boolean;
};

/** @internal */
export const Options$outboundSchema: z.ZodMiniType<Options$Outbound, Options> =
  z.pipe(
    z.object({
      featureId: z.string(),
      quantity: z.optional(z.number()),
      resetAfterTrialEnd: z._default(z.boolean(), false),
    }),
    z.transform((v) => {
      return remap$(v, {
        featureId: "feature_id",
        resetAfterTrialEnd: "reset_after_trial_end",
      });
    }),
  );

export function optionsToJSON(options: Options): string {
  return JSON.stringify(Options$outboundSchema.parse(options));
}

/** @internal */
export const Duration$outboundSchema: z.ZodMiniEnum<typeof Duration> = z.enum(
  Duration,
);

/** @internal */
export type AttachFreeTrial$Outbound = {
  length: number;
  duration: string;
  card_required: boolean;
};

/** @internal */
export const AttachFreeTrial$outboundSchema: z.ZodMiniType<
  AttachFreeTrial$Outbound,
  AttachFreeTrial
> = z.pipe(
  z.object({
    length: z.number(),
    duration: Duration$outboundSchema,
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      cardRequired: "card_required",
    });
  }),
);

export function attachFreeTrialToJSON(
  attachFreeTrial: AttachFreeTrial,
): string {
  return JSON.stringify(AttachFreeTrial$outboundSchema.parse(attachFreeTrial));
}

/** @internal */
export const AttachType$outboundSchema: z.ZodMiniEnum<typeof AttachType> = z
  .enum(AttachType);

/** @internal */
export type IncludedUsage$Outbound = number | string;

/** @internal */
export const IncludedUsage$outboundSchema: z.ZodMiniType<
  IncludedUsage$Outbound,
  IncludedUsage
> = smartUnion([z.number(), z.string()]);

export function includedUsageToJSON(includedUsage: IncludedUsage): string {
  return JSON.stringify(IncludedUsage$outboundSchema.parse(includedUsage));
}

/** @internal */
export const AttachInterval$outboundSchema: z.ZodMiniEnum<
  typeof AttachInterval
> = z.enum(AttachInterval);

/** @internal */
export const UsageModel$outboundSchema: z.ZodMiniEnum<typeof UsageModel> = z
  .enum(UsageModel);

/** @internal */
export type AttachTo$Outbound = number | string;

/** @internal */
export const AttachTo$outboundSchema: z.ZodMiniType<
  AttachTo$Outbound,
  AttachTo
> = smartUnion([z.number(), z.string()]);

export function attachToToJSON(attachTo: AttachTo): string {
  return JSON.stringify(AttachTo$outboundSchema.parse(attachTo));
}

/** @internal */
export type Tiers$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const Tiers$outboundSchema: z.ZodMiniType<Tiers$Outbound, Tiers> = z
  .object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
  });

export function tiersToJSON(tiers: Tiers): string {
  return JSON.stringify(Tiers$outboundSchema.parse(tiers));
}

/** @internal */
export type AttachItem$Outbound = {
  type?: string | null | undefined;
  feature_id?: string | null | undefined;
  included_usage?: number | string | null | undefined;
  interval?: string | null | undefined;
  interval_count?: number | null | undefined;
  entity_feature_id?: string | null | undefined;
  usage_model?: string | null | undefined;
  price?: number | null | undefined;
  tiers?: Array<Tiers$Outbound> | null | undefined;
  billing_units?: number | null | undefined;
  reset_usage_when_enabled?: boolean | null | undefined;
};

/** @internal */
export const AttachItem$outboundSchema: z.ZodMiniType<
  AttachItem$Outbound,
  AttachItem
> = z.pipe(
  z.object({
    type: z.optional(z.nullable(AttachType$outboundSchema)),
    featureId: z.optional(z.nullable(z.string())),
    includedUsage: z.optional(z.nullable(smartUnion([z.number(), z.string()]))),
    interval: z.optional(z.nullable(AttachInterval$outboundSchema)),
    intervalCount: z.optional(z.nullable(z.number())),
    entityFeatureId: z.optional(z.nullable(z.string())),
    usageModel: z.optional(z.nullable(UsageModel$outboundSchema)),
    price: z.optional(z.nullable(z.number())),
    tiers: z.optional(z.nullable(z.array(z.lazy(() => Tiers$outboundSchema)))),
    billingUnits: z.optional(z.nullable(z.number())),
    resetUsageWhenEnabled: z.optional(z.nullable(z.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
      includedUsage: "included_usage",
      intervalCount: "interval_count",
      entityFeatureId: "entity_feature_id",
      usageModel: "usage_model",
      billingUnits: "billing_units",
      resetUsageWhenEnabled: "reset_usage_when_enabled",
    });
  }),
);

export function attachItemToJSON(attachItem: AttachItem): string {
  return JSON.stringify(AttachItem$outboundSchema.parse(attachItem));
}

/** @internal */
export const RedirectMode$outboundSchema: z.ZodMiniEnum<typeof RedirectMode> = z
  .enum(RedirectMode);

/** @internal */
export const PlanSchedule$outboundSchema: z.ZodMiniEnum<typeof PlanSchedule> = z
  .enum(PlanSchedule);

/** @internal */
export const BillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingBehavior
> = z.enum(BillingBehavior);

/** @internal */
export type AttachRequest$Outbound = {
  options?: Array<Options$Outbound> | null | undefined;
  version?: number | undefined;
  free_trial?: AttachFreeTrial$Outbound | null | undefined;
  items?: Array<AttachItem$Outbound> | undefined;
  product_id: string;
  invoice?: boolean | undefined;
  enable_product_immediately?: boolean | undefined;
  finalize_invoice?: boolean | undefined;
  redirect_mode: string;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
  billing_behavior?: string | undefined;
  adjustable_quantity?: boolean | undefined;
};

/** @internal */
export const AttachRequest$outboundSchema: z.ZodMiniType<
  AttachRequest$Outbound,
  AttachRequest
> = z.pipe(
  z.object({
    options: z.optional(
      z.nullable(z.array(z.lazy(() => Options$outboundSchema))),
    ),
    version: z.optional(z.number()),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => AttachFreeTrial$outboundSchema)),
    ),
    items: z.optional(z.array(z.lazy(() => AttachItem$outboundSchema))),
    productId: z.string(),
    invoice: z.optional(z.boolean()),
    enableProductImmediately: z.optional(z.boolean()),
    finalizeInvoice: z.optional(z.boolean()),
    redirectMode: z._default(RedirectMode$outboundSchema, "always"),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(PlanSchedule$outboundSchema),
    billingBehavior: z.optional(BillingBehavior$outboundSchema),
    adjustableQuantity: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
      productId: "product_id",
      enableProductImmediately: "enable_product_immediately",
      finalizeInvoice: "finalize_invoice",
      redirectMode: "redirect_mode",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
      billingBehavior: "billing_behavior",
      adjustableQuantity: "adjustable_quantity",
    });
  }),
);

export function attachRequestToJSON(attachRequest: AttachRequest): string {
  return JSON.stringify(AttachRequest$outboundSchema.parse(attachRequest));
}

/** @internal */
export const AttachInvoice$inboundSchema: z.ZodMiniType<
  AttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function attachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<AttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachInvoice' from JSON`,
  );
}

/** @internal */
export const Code$inboundSchema: z.ZodMiniType<Code, unknown> = openEnums
  .inboundSchema(Code);

/** @internal */
export const RequiredAction$inboundSchema: z.ZodMiniType<
  RequiredAction,
  unknown
> = z.object({
  code: Code$inboundSchema,
  reason: types.string(),
});

export function requiredActionFromJSON(
  jsonString: string,
): SafeParseResult<RequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequiredAction' from JSON`,
  );
}

/** @internal */
export const AttachResponse$inboundSchema: z.ZodMiniType<
  AttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    invoice: types.optional(z.lazy(() => AttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(z.lazy(() => RequiredAction$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function attachResponseFromJSON(
  jsonString: string,
): SafeParseResult<AttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachResponse' from JSON`,
  );
}
