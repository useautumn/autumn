/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type AttachGlobals = {
  xApiVersion?: string | undefined;
};

export type AttachEntityData = {
  /**
   * The feature ID that this entity is associated with
   */
  featureId: string;
  /**
   * Name of the entity
   */
  name?: string | undefined;
};

export type Options = {
  featureId: string;
  quantity?: number | undefined;
  resetAfterTrialEnd?: boolean | undefined;
};

export const FreeTrialDuration = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type FreeTrialDuration = ClosedEnum<typeof FreeTrialDuration>;

export type AttachFreeTrial = {
  length: number;
  duration: FreeTrialDuration;
  cardRequired?: boolean | undefined;
};

export const AttachType = {
  Feature: "feature",
  PricedFeature: "priced_feature",
  Price: "price",
} as const;
export type AttachType = ClosedEnum<typeof AttachType>;

export const FeatureType = {
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  Boolean: "boolean",
  Static: "static",
} as const;
export type FeatureType = ClosedEnum<typeof FeatureType>;

/**
 * The type of the feature
 */
export const AttachFeatureType = {
  Static: "static",
  Boolean: "boolean",
  SingleUse: "single_use",
  ContinuousUse: "continuous_use",
  CreditSystem: "credit_system",
} as const;
/**
 * The type of the feature
 */
export type AttachFeatureType = ClosedEnum<typeof AttachFeatureType>;

export type AttachFeatureDisplay = {
  /**
   * The singular display name for the feature.
   */
  singular: string;
  /**
   * The plural display name for the feature.
   */
  plural: string;
};

export type AttachCreditSchema = {
  /**
   * The ID of the metered feature (should be a single_use feature).
   */
  meteredFeatureId: string;
  /**
   * The credit cost of the metered feature.
   */
  creditCost: number;
};

export type AttachFeature = {
  /**
   * The ID of the feature, used to refer to it in other API calls like /track or /check.
   */
  id: string;
  /**
   * The name of the feature.
   */
  name?: string | null | undefined;
  /**
   * The type of the feature
   */
  type: AttachFeatureType;
  /**
   * Singular and plural display names for the feature.
   */
  display?: AttachFeatureDisplay | null | undefined;
  /**
   * Credit cost schema for credit system features.
   */
  creditSchema?: Array<AttachCreditSchema> | null | undefined;
  /**
   * Whether or not the feature is archived.
   */
  archived?: boolean | null | undefined;
};

export type IncludedUsage = number | string;

export const AttachInterval = {
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type AttachInterval = ClosedEnum<typeof AttachInterval>;

export const UsageModel = {
  Prepaid: "prepaid",
  PayPerUse: "pay_per_use",
} as const;
export type UsageModel = ClosedEnum<typeof UsageModel>;

/**
 * The maximum amount of usage for this tier.
 */
export type AttachTo = number | string;

export type Tiers = {
  /**
   * The maximum amount of usage for this tier.
   */
  to: number | string;
  /**
   * The price of the product item for this tier.
   */
  amount: number;
};

export type AttachDisplay = {
  primaryText: string;
  secondaryText?: string | null | undefined;
};

export const AttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type AttachOnIncrease = ClosedEnum<typeof AttachOnIncrease>;

export const AttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type AttachOnDecrease = ClosedEnum<typeof AttachOnDecrease>;

export const RolloverDuration = {
  Month: "month",
  Forever: "forever",
} as const;
export type RolloverDuration = ClosedEnum<typeof RolloverDuration>;

export type AttachRollover = {
  max: number | null;
  duration?: RolloverDuration | undefined;
  length: number;
};

export type Config = {
  onIncrease?: AttachOnIncrease | null | undefined;
  onDecrease?: AttachOnDecrease | null | undefined;
  rollover?: AttachRollover | null | undefined;
};

export type AttachItem = {
  /**
   * The type of the product item.
   */
  type?: AttachType | null | undefined;
  /**
   * The feature ID of the product item. Should be null for fixed price items.
   */
  featureId?: string | null | undefined;
  featureType?: FeatureType | null | undefined;
  feature?: AttachFeature | null | undefined;
  /**
   * The amount of usage included for this feature (per interval).
   */
  includedUsage?: number | string | null | undefined;
  /**
   * The reset or billing interval of the product item. If null, feature will have no reset date, and if there's a price, it will be billed one-off.
   */
  interval?: AttachInterval | null | undefined;
  /**
   * Interval count of the feature.
   */
  intervalCount?: number | null | undefined;
  /**
   * The feature ID of the entity (like seats) to track sub-balances for.
   */
  entityFeatureId?: string | null | undefined;
  /**
   * Whether the feature should be prepaid upfront or billed for how much they use end of billing period.
   */
  usageModel?: UsageModel | null | undefined;
  /**
   * The price of the product item. Should be null if tiered pricing is set.
   */
  price?: number | null | undefined;
  /**
   * Tiered pricing for the product item. Not applicable for fixed price items.
   */
  tiers?: Array<Tiers> | null | undefined;
  /**
   * The billing units of the product item (eg $1 for 30 credits).
   */
  billingUnits?: number | null | undefined;
  /**
   * Whether the usage should be reset when the product is enabled.
   */
  resetUsageWhenEnabled?: boolean | null | undefined;
  display?: AttachDisplay | null | undefined;
  usageLimit?: number | null | undefined;
  config?: Config | null | undefined;
  createdAt?: number | null | undefined;
  entitlementId?: string | null | undefined;
  priceId?: string | null | undefined;
  priceConfig?: any | null | undefined;
};

export const RedirectMode = {
  Always: "always",
  IfRequired: "if_required",
  Never: "never",
} as const;
export type RedirectMode = ClosedEnum<typeof RedirectMode>;

export const PlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
export type PlanSchedule = ClosedEnum<typeof PlanSchedule>;

export const BillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
export type BillingBehavior = ClosedEnum<typeof BillingBehavior>;

export type AttachRequest = {
  entityId?: string | null | undefined;
  entityData?: AttachEntityData | undefined;
  options?: Array<Options> | null | undefined;
  version?: number | undefined;
  freeTrial?: AttachFreeTrial | null | undefined;
  items?: Array<AttachItem> | undefined;
  productId: string;
  invoice?: boolean | undefined;
  enableProductImmediately?: boolean | undefined;
  finalizeInvoice?: boolean | undefined;
  redirectMode?: RedirectMode | undefined;
  successUrl?: string | undefined;
  newBillingSubscription?: boolean | undefined;
  planSchedule?: PlanSchedule | undefined;
  billingBehavior?: BillingBehavior | undefined;
  adjustableQuantity?: boolean | undefined;
};

export type AttachInvoice = {
  status: string | null;
  stripeId: string;
  total: number;
  currency: string;
  hostedInvoiceUrl: string | null;
};

export const Code = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
export type Code = OpenEnum<typeof Code>;

export type RequiredAction = {
  code: Code;
  reason: string;
};

/**
 * OK
 */
export type AttachResponse = {
  customerId: string;
  entityId?: string | undefined;
  invoice?: AttachInvoice | undefined;
  paymentUrl: string | null;
  requiredAction?: RequiredAction | undefined;
};

/** @internal */
export type AttachEntityData$Outbound = {
  feature_id: string;
  name?: string | undefined;
};

/** @internal */
export const AttachEntityData$outboundSchema: z.ZodMiniType<
  AttachEntityData$Outbound,
  AttachEntityData
> = z.pipe(
  z.object({
    featureId: z.string(),
    name: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function attachEntityDataToJSON(
  attachEntityData: AttachEntityData,
): string {
  return JSON.stringify(
    AttachEntityData$outboundSchema.parse(attachEntityData),
  );
}

/** @internal */
export type Options$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  reset_after_trial_end: boolean;
};

/** @internal */
export const Options$outboundSchema: z.ZodMiniType<Options$Outbound, Options> =
  z.pipe(
    z.object({
      featureId: z.string(),
      quantity: z.optional(z.number()),
      resetAfterTrialEnd: z._default(z.boolean(), false),
    }),
    z.transform((v) => {
      return remap$(v, {
        featureId: "feature_id",
        resetAfterTrialEnd: "reset_after_trial_end",
      });
    }),
  );

export function optionsToJSON(options: Options): string {
  return JSON.stringify(Options$outboundSchema.parse(options));
}

/** @internal */
export const FreeTrialDuration$outboundSchema: z.ZodMiniEnum<
  typeof FreeTrialDuration
> = z.enum(FreeTrialDuration);

/** @internal */
export type AttachFreeTrial$Outbound = {
  length: number;
  duration: string;
  card_required: boolean;
};

/** @internal */
export const AttachFreeTrial$outboundSchema: z.ZodMiniType<
  AttachFreeTrial$Outbound,
  AttachFreeTrial
> = z.pipe(
  z.object({
    length: z.number(),
    duration: FreeTrialDuration$outboundSchema,
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      cardRequired: "card_required",
    });
  }),
);

export function attachFreeTrialToJSON(
  attachFreeTrial: AttachFreeTrial,
): string {
  return JSON.stringify(AttachFreeTrial$outboundSchema.parse(attachFreeTrial));
}

/** @internal */
export const AttachType$outboundSchema: z.ZodMiniEnum<typeof AttachType> = z
  .enum(AttachType);

/** @internal */
export const FeatureType$outboundSchema: z.ZodMiniEnum<typeof FeatureType> = z
  .enum(FeatureType);

/** @internal */
export const AttachFeatureType$outboundSchema: z.ZodMiniEnum<
  typeof AttachFeatureType
> = z.enum(AttachFeatureType);

/** @internal */
export type AttachFeatureDisplay$Outbound = {
  singular: string;
  plural: string;
};

/** @internal */
export const AttachFeatureDisplay$outboundSchema: z.ZodMiniType<
  AttachFeatureDisplay$Outbound,
  AttachFeatureDisplay
> = z.object({
  singular: z.string(),
  plural: z.string(),
});

export function attachFeatureDisplayToJSON(
  attachFeatureDisplay: AttachFeatureDisplay,
): string {
  return JSON.stringify(
    AttachFeatureDisplay$outboundSchema.parse(attachFeatureDisplay),
  );
}

/** @internal */
export type AttachCreditSchema$Outbound = {
  metered_feature_id: string;
  credit_cost: number;
};

/** @internal */
export const AttachCreditSchema$outboundSchema: z.ZodMiniType<
  AttachCreditSchema$Outbound,
  AttachCreditSchema
> = z.pipe(
  z.object({
    meteredFeatureId: z.string(),
    creditCost: z.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      meteredFeatureId: "metered_feature_id",
      creditCost: "credit_cost",
    });
  }),
);

export function attachCreditSchemaToJSON(
  attachCreditSchema: AttachCreditSchema,
): string {
  return JSON.stringify(
    AttachCreditSchema$outboundSchema.parse(attachCreditSchema),
  );
}

/** @internal */
export type AttachFeature$Outbound = {
  id: string;
  name?: string | null | undefined;
  type: string;
  display?: AttachFeatureDisplay$Outbound | null | undefined;
  credit_schema?: Array<AttachCreditSchema$Outbound> | null | undefined;
  archived?: boolean | null | undefined;
};

/** @internal */
export const AttachFeature$outboundSchema: z.ZodMiniType<
  AttachFeature$Outbound,
  AttachFeature
> = z.pipe(
  z.object({
    id: z.string(),
    name: z.optional(z.nullable(z.string())),
    type: AttachFeatureType$outboundSchema,
    display: z.optional(
      z.nullable(z.lazy(() => AttachFeatureDisplay$outboundSchema)),
    ),
    creditSchema: z.optional(
      z.nullable(z.array(z.lazy(() => AttachCreditSchema$outboundSchema))),
    ),
    archived: z.optional(z.nullable(z.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      creditSchema: "credit_schema",
    });
  }),
);

export function attachFeatureToJSON(attachFeature: AttachFeature): string {
  return JSON.stringify(AttachFeature$outboundSchema.parse(attachFeature));
}

/** @internal */
export type IncludedUsage$Outbound = number | string;

/** @internal */
export const IncludedUsage$outboundSchema: z.ZodMiniType<
  IncludedUsage$Outbound,
  IncludedUsage
> = smartUnion([z.number(), z.string()]);

export function includedUsageToJSON(includedUsage: IncludedUsage): string {
  return JSON.stringify(IncludedUsage$outboundSchema.parse(includedUsage));
}

/** @internal */
export const AttachInterval$outboundSchema: z.ZodMiniEnum<
  typeof AttachInterval
> = z.enum(AttachInterval);

/** @internal */
export const UsageModel$outboundSchema: z.ZodMiniEnum<typeof UsageModel> = z
  .enum(UsageModel);

/** @internal */
export type AttachTo$Outbound = number | string;

/** @internal */
export const AttachTo$outboundSchema: z.ZodMiniType<
  AttachTo$Outbound,
  AttachTo
> = smartUnion([z.number(), z.string()]);

export function attachToToJSON(attachTo: AttachTo): string {
  return JSON.stringify(AttachTo$outboundSchema.parse(attachTo));
}

/** @internal */
export type Tiers$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const Tiers$outboundSchema: z.ZodMiniType<Tiers$Outbound, Tiers> = z
  .object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
  });

export function tiersToJSON(tiers: Tiers): string {
  return JSON.stringify(Tiers$outboundSchema.parse(tiers));
}

/** @internal */
export type AttachDisplay$Outbound = {
  primary_text: string;
  secondary_text?: string | null | undefined;
};

/** @internal */
export const AttachDisplay$outboundSchema: z.ZodMiniType<
  AttachDisplay$Outbound,
  AttachDisplay
> = z.pipe(
  z.object({
    primaryText: z.string(),
    secondaryText: z.optional(z.nullable(z.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      primaryText: "primary_text",
      secondaryText: "secondary_text",
    });
  }),
);

export function attachDisplayToJSON(attachDisplay: AttachDisplay): string {
  return JSON.stringify(AttachDisplay$outboundSchema.parse(attachDisplay));
}

/** @internal */
export const AttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof AttachOnIncrease
> = z.enum(AttachOnIncrease);

/** @internal */
export const AttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof AttachOnDecrease
> = z.enum(AttachOnDecrease);

/** @internal */
export const RolloverDuration$outboundSchema: z.ZodMiniEnum<
  typeof RolloverDuration
> = z.enum(RolloverDuration);

/** @internal */
export type AttachRollover$Outbound = {
  max: number | null;
  duration: string;
  length: number;
};

/** @internal */
export const AttachRollover$outboundSchema: z.ZodMiniType<
  AttachRollover$Outbound,
  AttachRollover
> = z.object({
  max: z.nullable(z.number()),
  duration: z._default(RolloverDuration$outboundSchema, "month"),
  length: z.number(),
});

export function attachRolloverToJSON(attachRollover: AttachRollover): string {
  return JSON.stringify(AttachRollover$outboundSchema.parse(attachRollover));
}

/** @internal */
export type Config$Outbound = {
  on_increase?: string | null | undefined;
  on_decrease?: string | null | undefined;
  rollover?: AttachRollover$Outbound | null | undefined;
};

/** @internal */
export const Config$outboundSchema: z.ZodMiniType<Config$Outbound, Config> = z
  .pipe(
    z.object({
      onIncrease: z.optional(z.nullable(AttachOnIncrease$outboundSchema)),
      onDecrease: z.optional(z.nullable(AttachOnDecrease$outboundSchema)),
      rollover: z.optional(
        z.nullable(z.lazy(() => AttachRollover$outboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        onIncrease: "on_increase",
        onDecrease: "on_decrease",
      });
    }),
  );

export function configToJSON(config: Config): string {
  return JSON.stringify(Config$outboundSchema.parse(config));
}

/** @internal */
export type AttachItem$Outbound = {
  type?: string | null | undefined;
  feature_id?: string | null | undefined;
  feature_type?: string | null | undefined;
  feature?: AttachFeature$Outbound | null | undefined;
  included_usage?: number | string | null | undefined;
  interval?: string | null | undefined;
  interval_count?: number | null | undefined;
  entity_feature_id?: string | null | undefined;
  usage_model?: string | null | undefined;
  price?: number | null | undefined;
  tiers?: Array<Tiers$Outbound> | null | undefined;
  billing_units?: number | null | undefined;
  reset_usage_when_enabled?: boolean | null | undefined;
  display?: AttachDisplay$Outbound | null | undefined;
  usage_limit?: number | null | undefined;
  config?: Config$Outbound | null | undefined;
  created_at?: number | null | undefined;
  entitlement_id?: string | null | undefined;
  price_id?: string | null | undefined;
  price_config?: any | null | undefined;
};

/** @internal */
export const AttachItem$outboundSchema: z.ZodMiniType<
  AttachItem$Outbound,
  AttachItem
> = z.pipe(
  z.object({
    type: z.optional(z.nullable(AttachType$outboundSchema)),
    featureId: z.optional(z.nullable(z.string())),
    featureType: z.optional(z.nullable(FeatureType$outboundSchema)),
    feature: z.optional(z.nullable(z.lazy(() => AttachFeature$outboundSchema))),
    includedUsage: z.optional(z.nullable(smartUnion([z.number(), z.string()]))),
    interval: z.optional(z.nullable(AttachInterval$outboundSchema)),
    intervalCount: z.optional(z.nullable(z.number())),
    entityFeatureId: z.optional(z.nullable(z.string())),
    usageModel: z.optional(z.nullable(UsageModel$outboundSchema)),
    price: z.optional(z.nullable(z.number())),
    tiers: z.optional(z.nullable(z.array(z.lazy(() => Tiers$outboundSchema)))),
    billingUnits: z.optional(z.nullable(z.number())),
    resetUsageWhenEnabled: z.optional(z.nullable(z.boolean())),
    display: z.optional(z.nullable(z.lazy(() => AttachDisplay$outboundSchema))),
    usageLimit: z.optional(z.nullable(z.number())),
    config: z.optional(z.nullable(z.lazy(() => Config$outboundSchema))),
    createdAt: z.optional(z.nullable(z.number())),
    entitlementId: z.optional(z.nullable(z.string())),
    priceId: z.optional(z.nullable(z.string())),
    priceConfig: z.optional(z.nullable(z.any())),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
      featureType: "feature_type",
      includedUsage: "included_usage",
      intervalCount: "interval_count",
      entityFeatureId: "entity_feature_id",
      usageModel: "usage_model",
      billingUnits: "billing_units",
      resetUsageWhenEnabled: "reset_usage_when_enabled",
      usageLimit: "usage_limit",
      createdAt: "created_at",
      entitlementId: "entitlement_id",
      priceId: "price_id",
      priceConfig: "price_config",
    });
  }),
);

export function attachItemToJSON(attachItem: AttachItem): string {
  return JSON.stringify(AttachItem$outboundSchema.parse(attachItem));
}

/** @internal */
export const RedirectMode$outboundSchema: z.ZodMiniEnum<typeof RedirectMode> = z
  .enum(RedirectMode);

/** @internal */
export const PlanSchedule$outboundSchema: z.ZodMiniEnum<typeof PlanSchedule> = z
  .enum(PlanSchedule);

/** @internal */
export const BillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingBehavior
> = z.enum(BillingBehavior);

/** @internal */
export type AttachRequest$Outbound = {
  entity_id?: string | null | undefined;
  entity_data?: AttachEntityData$Outbound | undefined;
  options?: Array<Options$Outbound> | null | undefined;
  version?: number | undefined;
  free_trial?: AttachFreeTrial$Outbound | null | undefined;
  items?: Array<AttachItem$Outbound> | undefined;
  product_id: string;
  invoice?: boolean | undefined;
  enable_product_immediately?: boolean | undefined;
  finalize_invoice?: boolean | undefined;
  redirect_mode: string;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
  billing_behavior?: string | undefined;
  adjustable_quantity?: boolean | undefined;
};

/** @internal */
export const AttachRequest$outboundSchema: z.ZodMiniType<
  AttachRequest$Outbound,
  AttachRequest
> = z.pipe(
  z.object({
    entityId: z.optional(z.nullable(z.string())),
    entityData: z.optional(z.lazy(() => AttachEntityData$outboundSchema)),
    options: z.optional(
      z.nullable(z.array(z.lazy(() => Options$outboundSchema))),
    ),
    version: z.optional(z.number()),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => AttachFreeTrial$outboundSchema)),
    ),
    items: z.optional(z.array(z.lazy(() => AttachItem$outboundSchema))),
    productId: z.string(),
    invoice: z.optional(z.boolean()),
    enableProductImmediately: z.optional(z.boolean()),
    finalizeInvoice: z.optional(z.boolean()),
    redirectMode: z._default(RedirectMode$outboundSchema, "always"),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(PlanSchedule$outboundSchema),
    billingBehavior: z.optional(BillingBehavior$outboundSchema),
    adjustableQuantity: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      entityId: "entity_id",
      entityData: "entity_data",
      freeTrial: "free_trial",
      productId: "product_id",
      enableProductImmediately: "enable_product_immediately",
      finalizeInvoice: "finalize_invoice",
      redirectMode: "redirect_mode",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
      billingBehavior: "billing_behavior",
      adjustableQuantity: "adjustable_quantity",
    });
  }),
);

export function attachRequestToJSON(attachRequest: AttachRequest): string {
  return JSON.stringify(AttachRequest$outboundSchema.parse(attachRequest));
}

/** @internal */
export const AttachInvoice$inboundSchema: z.ZodMiniType<
  AttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function attachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<AttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachInvoice' from JSON`,
  );
}

/** @internal */
export const Code$inboundSchema: z.ZodMiniType<Code, unknown> = openEnums
  .inboundSchema(Code);

/** @internal */
export const RequiredAction$inboundSchema: z.ZodMiniType<
  RequiredAction,
  unknown
> = z.object({
  code: Code$inboundSchema,
  reason: types.string(),
});

export function requiredActionFromJSON(
  jsonString: string,
): SafeParseResult<RequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequiredAction' from JSON`,
  );
}

/** @internal */
export const AttachResponse$inboundSchema: z.ZodMiniType<
  AttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => AttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(z.lazy(() => RequiredAction$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function attachResponseFromJSON(
  jsonString: string,
): SafeParseResult<AttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachResponse' from JSON`,
  );
}
