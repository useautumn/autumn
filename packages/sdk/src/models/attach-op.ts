/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type AttachGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type AttachFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const AttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type AttachPriceInterval = ClosedEnum<typeof AttachPriceInterval>;

/**
 * Base price configuration for a plan.
 */
export type AttachBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: AttachPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const AttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type AttachResetInterval = ClosedEnum<typeof AttachResetInterval>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type AttachReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: AttachResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type AttachTo = number | string;

export type AttachTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const AttachTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type AttachTierBehavior = ClosedEnum<typeof AttachTierBehavior>;

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const AttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type AttachItemPriceInterval = ClosedEnum<
  typeof AttachItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const AttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type AttachBillingMethod = ClosedEnum<typeof AttachBillingMethod>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type AttachPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing.  Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<AttachTier> | undefined;
  tierBehavior?: AttachTierBehavior | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: AttachItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: AttachBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const AttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type AttachOnIncrease = ClosedEnum<typeof AttachOnIncrease>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const AttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type AttachOnDecrease = ClosedEnum<typeof AttachOnDecrease>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type AttachProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: AttachOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: AttachOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const AttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type AttachExpiryDurationType = ClosedEnum<
  typeof AttachExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type AttachRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: AttachExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type AttachPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: AttachReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: AttachPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: AttachProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: AttachRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const AttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type AttachDurationType = ClosedEnum<typeof AttachDurationType>;

/**
 * Free trial configuration for a plan.
 */
export type AttachFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: AttachDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type AttachCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: AttachBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<AttachPlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: AttachFreeTrialParams | null | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type AttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const AttachProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type AttachProrationBehavior = ClosedEnum<
  typeof AttachProrationBehavior
>;

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type AttachAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export const AttachPlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export type AttachPlanSchedule = ClosedEnum<typeof AttachPlanSchedule>;

export type AttachParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<AttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: AttachCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: AttachInvoiceMode | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: AttachProrationBehavior | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<AttachAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
   */
  planSchedule?: AttachPlanSchedule | undefined;
  /**
   * Additional parameters to pass into the creation of the Stripe checkout session.
   */
  checkoutSessionParams?: { [k: string]: any } | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type AttachInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const AttachCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type AttachCode = OpenEnum<typeof AttachCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type AttachRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: AttachCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type AttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: AttachInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: AttachRequiredAction | undefined;
};

/** @internal */
export type AttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const AttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  AttachFeatureQuantity$Outbound,
  AttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function attachFeatureQuantityToJSON(
  attachFeatureQuantity: AttachFeatureQuantity,
): string {
  return JSON.stringify(
    AttachFeatureQuantity$outboundSchema.parse(attachFeatureQuantity),
  );
}

/** @internal */
export const AttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof AttachPriceInterval
> = z.enum(AttachPriceInterval);

/** @internal */
export type AttachBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const AttachBasePrice$outboundSchema: z.ZodMiniType<
  AttachBasePrice$Outbound,
  AttachBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: AttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function attachBasePriceToJSON(
  attachBasePrice: AttachBasePrice,
): string {
  return JSON.stringify(AttachBasePrice$outboundSchema.parse(attachBasePrice));
}

/** @internal */
export const AttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof AttachResetInterval
> = z.enum(AttachResetInterval);

/** @internal */
export type AttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const AttachReset$outboundSchema: z.ZodMiniType<
  AttachReset$Outbound,
  AttachReset
> = z.pipe(
  z.object({
    interval: AttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function attachResetToJSON(attachReset: AttachReset): string {
  return JSON.stringify(AttachReset$outboundSchema.parse(attachReset));
}

/** @internal */
export type AttachTo$Outbound = number | string;

/** @internal */
export const AttachTo$outboundSchema: z.ZodMiniType<
  AttachTo$Outbound,
  AttachTo
> = smartUnion([z.number(), z.string()]);

export function attachToToJSON(attachTo: AttachTo): string {
  return JSON.stringify(AttachTo$outboundSchema.parse(attachTo));
}

/** @internal */
export type AttachTier$Outbound = {
  to: number | string;
  amount: number;
  flat_amount?: number | null | undefined;
};

/** @internal */
export const AttachTier$outboundSchema: z.ZodMiniType<
  AttachTier$Outbound,
  AttachTier
> = z.pipe(
  z.object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
    flatAmount: z.optional(z.nullable(z.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      flatAmount: "flat_amount",
    });
  }),
);

export function attachTierToJSON(attachTier: AttachTier): string {
  return JSON.stringify(AttachTier$outboundSchema.parse(attachTier));
}

/** @internal */
export const AttachTierBehavior$outboundSchema: z.ZodMiniEnum<
  typeof AttachTierBehavior
> = z.enum(AttachTierBehavior);

/** @internal */
export const AttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof AttachItemPriceInterval
> = z.enum(AttachItemPriceInterval);

/** @internal */
export const AttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof AttachBillingMethod
> = z.enum(AttachBillingMethod);

/** @internal */
export type AttachPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<AttachTier$Outbound> | undefined;
  tier_behavior?: string | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const AttachPrice$outboundSchema: z.ZodMiniType<
  AttachPrice$Outbound,
  AttachPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => AttachTier$outboundSchema))),
    tierBehavior: z.optional(AttachTierBehavior$outboundSchema),
    interval: AttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: AttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      tierBehavior: "tier_behavior",
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function attachPriceToJSON(attachPrice: AttachPrice): string {
  return JSON.stringify(AttachPrice$outboundSchema.parse(attachPrice));
}

/** @internal */
export const AttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof AttachOnIncrease
> = z.enum(AttachOnIncrease);

/** @internal */
export const AttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof AttachOnDecrease
> = z.enum(AttachOnDecrease);

/** @internal */
export type AttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const AttachProration$outboundSchema: z.ZodMiniType<
  AttachProration$Outbound,
  AttachProration
> = z.pipe(
  z.object({
    onIncrease: AttachOnIncrease$outboundSchema,
    onDecrease: AttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function attachProrationToJSON(
  attachProration: AttachProration,
): string {
  return JSON.stringify(AttachProration$outboundSchema.parse(attachProration));
}

/** @internal */
export const AttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof AttachExpiryDurationType
> = z.enum(AttachExpiryDurationType);

/** @internal */
export type AttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const AttachRollover$outboundSchema: z.ZodMiniType<
  AttachRollover$Outbound,
  AttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: AttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function attachRolloverToJSON(attachRollover: AttachRollover): string {
  return JSON.stringify(AttachRollover$outboundSchema.parse(attachRollover));
}

/** @internal */
export type AttachPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: AttachReset$Outbound | undefined;
  price?: AttachPrice$Outbound | undefined;
  proration?: AttachProration$Outbound | undefined;
  rollover?: AttachRollover$Outbound | undefined;
};

/** @internal */
export const AttachPlanItem$outboundSchema: z.ZodMiniType<
  AttachPlanItem$Outbound,
  AttachPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => AttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => AttachPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => AttachProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => AttachRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function attachPlanItemToJSON(attachPlanItem: AttachPlanItem): string {
  return JSON.stringify(AttachPlanItem$outboundSchema.parse(attachPlanItem));
}

/** @internal */
export const AttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof AttachDurationType
> = z.enum(AttachDurationType);

/** @internal */
export type AttachFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const AttachFreeTrialParams$outboundSchema: z.ZodMiniType<
  AttachFreeTrialParams$Outbound,
  AttachFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(AttachDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function attachFreeTrialParamsToJSON(
  attachFreeTrialParams: AttachFreeTrialParams,
): string {
  return JSON.stringify(
    AttachFreeTrialParams$outboundSchema.parse(attachFreeTrialParams),
  );
}

/** @internal */
export type AttachCustomize$Outbound = {
  price?: AttachBasePrice$Outbound | null | undefined;
  items?: Array<AttachPlanItem$Outbound> | undefined;
  free_trial?: AttachFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const AttachCustomize$outboundSchema: z.ZodMiniType<
  AttachCustomize$Outbound,
  AttachCustomize
> = z.pipe(
  z.object({
    price: z.optional(z.nullable(z.lazy(() => AttachBasePrice$outboundSchema))),
    items: z.optional(z.array(z.lazy(() => AttachPlanItem$outboundSchema))),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => AttachFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function attachCustomizeToJSON(
  attachCustomize: AttachCustomize,
): string {
  return JSON.stringify(AttachCustomize$outboundSchema.parse(attachCustomize));
}

/** @internal */
export type AttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const AttachInvoiceMode$outboundSchema: z.ZodMiniType<
  AttachInvoiceMode$Outbound,
  AttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function attachInvoiceModeToJSON(
  attachInvoiceMode: AttachInvoiceMode,
): string {
  return JSON.stringify(
    AttachInvoiceMode$outboundSchema.parse(attachInvoiceMode),
  );
}

/** @internal */
export const AttachProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof AttachProrationBehavior
> = z.enum(AttachProrationBehavior);

/** @internal */
export type AttachAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const AttachAttachDiscount$outboundSchema: z.ZodMiniType<
  AttachAttachDiscount$Outbound,
  AttachAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function attachAttachDiscountToJSON(
  attachAttachDiscount: AttachAttachDiscount,
): string {
  return JSON.stringify(
    AttachAttachDiscount$outboundSchema.parse(attachAttachDiscount),
  );
}

/** @internal */
export const AttachPlanSchedule$outboundSchema: z.ZodMiniEnum<
  typeof AttachPlanSchedule
> = z.enum(AttachPlanSchedule);

/** @internal */
export type AttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<AttachFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: AttachCustomize$Outbound | undefined;
  invoice_mode?: AttachInvoiceMode$Outbound | undefined;
  proration_behavior?: string | undefined;
  discounts?: Array<AttachAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
  checkout_session_params?: { [k: string]: any } | undefined;
};

/** @internal */
export const AttachParams$outboundSchema: z.ZodMiniType<
  AttachParams$Outbound,
  AttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => AttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => AttachCustomize$outboundSchema)),
    invoiceMode: z.optional(z.lazy(() => AttachInvoiceMode$outboundSchema)),
    prorationBehavior: z.optional(AttachProrationBehavior$outboundSchema),
    discounts: z.optional(
      z.array(z.lazy(() => AttachAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(AttachPlanSchedule$outboundSchema),
    checkoutSessionParams: z.optional(z.record(z.string(), z.any())),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      invoiceMode: "invoice_mode",
      prorationBehavior: "proration_behavior",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
      checkoutSessionParams: "checkout_session_params",
    });
  }),
);

export function attachParamsToJSON(attachParams: AttachParams): string {
  return JSON.stringify(AttachParams$outboundSchema.parse(attachParams));
}

/** @internal */
export const AttachInvoice$inboundSchema: z.ZodMiniType<
  AttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function attachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<AttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachInvoice' from JSON`,
  );
}

/** @internal */
export const AttachCode$inboundSchema: z.ZodMiniType<AttachCode, unknown> =
  openEnums.inboundSchema(AttachCode);

/** @internal */
export const AttachRequiredAction$inboundSchema: z.ZodMiniType<
  AttachRequiredAction,
  unknown
> = z.object({
  code: AttachCode$inboundSchema,
  reason: types.string(),
});

export function attachRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<AttachRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachRequiredAction' from JSON`,
  );
}

/** @internal */
export const AttachResponse$inboundSchema: z.ZodMiniType<
  AttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => AttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => AttachRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function attachResponseFromJSON(
  jsonString: string,
): SafeParseResult<AttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttachResponse' from JSON`,
  );
}
