/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type PreviewUpdateGlobals = {
  xApiVersion?: string | undefined;
};

export type PreviewUpdateFeatureQuantity = {
  featureId: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

export const PreviewUpdateDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type PreviewUpdateDurationType = ClosedEnum<
  typeof PreviewUpdateDurationType
>;

export type PreviewUpdateFreeTrial = {
  durationLength: number;
  durationType?: PreviewUpdateDurationType | undefined;
  cardRequired?: boolean | undefined;
};

export const PreviewUpdatePriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PreviewUpdatePriceInterval = ClosedEnum<
  typeof PreviewUpdatePriceInterval
>;

export type PreviewUpdatePrice = {
  amount: number;
  interval: PreviewUpdatePriceInterval;
  intervalCount?: number | undefined;
};

export const PreviewUpdateResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PreviewUpdateResetInterval = ClosedEnum<
  typeof PreviewUpdateResetInterval
>;

export type PreviewUpdateReset = {
  interval: PreviewUpdateResetInterval;
  intervalCount?: number | undefined;
};

export type PreviewUpdateTo = number | string;

export type PreviewUpdateTier = {
  to: number | string;
  amount: number;
};

export const PreviewUpdateItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type PreviewUpdateItemPriceInterval = ClosedEnum<
  typeof PreviewUpdateItemPriceInterval
>;

export const PreviewUpdateBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type PreviewUpdateBillingMethod = ClosedEnum<
  typeof PreviewUpdateBillingMethod
>;

export type PreviewUpdateItemPrice = {
  amount?: number | undefined;
  tiers?: Array<PreviewUpdateTier> | undefined;
  interval: PreviewUpdateItemPriceInterval;
  intervalCount?: number | undefined;
  billingUnits?: number | undefined;
  billingMethod: PreviewUpdateBillingMethod;
  maxPurchase?: number | undefined;
};

export const PreviewUpdateOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type PreviewUpdateOnIncrease = ClosedEnum<
  typeof PreviewUpdateOnIncrease
>;

export const PreviewUpdateOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type PreviewUpdateOnDecrease = ClosedEnum<
  typeof PreviewUpdateOnDecrease
>;

export type PreviewUpdateProration = {
  onIncrease: PreviewUpdateOnIncrease;
  onDecrease: PreviewUpdateOnDecrease;
};

export const PreviewUpdateExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type PreviewUpdateExpiryDurationType = ClosedEnum<
  typeof PreviewUpdateExpiryDurationType
>;

export type PreviewUpdateRollover = {
  max?: number | undefined;
  expiryDurationType: PreviewUpdateExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export type PreviewUpdateItem = {
  featureId: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: PreviewUpdateReset | undefined;
  price?: PreviewUpdateItemPrice | undefined;
  proration?: PreviewUpdateProration | undefined;
  rollover?: PreviewUpdateRollover | undefined;
};

/**
 * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
 */
export type PreviewUpdateCustomize = {
  price?: PreviewUpdatePrice | null | undefined;
  items?: Array<PreviewUpdateItem> | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type PreviewUpdateInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export const PreviewUpdateBillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export type PreviewUpdateBillingBehavior = ClosedEnum<
  typeof PreviewUpdateBillingBehavior
>;

/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export const PreviewUpdateCancelAction = {
  CancelImmediately: "cancel_immediately",
  CancelEndOfCycle: "cancel_end_of_cycle",
  Uncancel: "uncancel",
} as const;
/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export type PreviewUpdateCancelAction = ClosedEnum<
  typeof PreviewUpdateCancelAction
>;

export type PreviewUpdateParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<PreviewUpdateFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: PreviewUpdateFreeTrial | null | undefined;
  /**
   * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
   */
  customize?: PreviewUpdateCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: PreviewUpdateInvoiceMode | undefined;
  /**
   * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
   */
  billingBehavior?: PreviewUpdateBillingBehavior | undefined;
  /**
   * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
   */
  cancelAction?: PreviewUpdateCancelAction | undefined;
};

export type PreviewUpdateDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type PreviewUpdateLineItem = {
  /**
   * The title of the line item.
   */
  title: string;
  /**
   * A detailed description of the line item.
   */
  description: string;
  /**
   * The amount in cents for this line item.
   */
  amount: number;
  /**
   * List of discounts applied to this line item.
   */
  discounts?: Array<PreviewUpdateDiscount> | undefined;
};

/**
 * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
 */
export type PreviewUpdateNextCycle = {
  /**
   * Unix timestamp (milliseconds) when the next billing cycle starts.
   */
  startsAt: number;
  /**
   * The total amount in cents for the next cycle.
   */
  total: number;
};

/**
 * OK
 */
export type PreviewUpdateResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * List of line items for the current billing period.
   */
  lineItems: Array<PreviewUpdateLineItem>;
  /**
   * The total amount in cents for the current billing period.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
   */
  nextCycle?: PreviewUpdateNextCycle | undefined;
};

/** @internal */
export type PreviewUpdateFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const PreviewUpdateFeatureQuantity$outboundSchema: z.ZodMiniType<
  PreviewUpdateFeatureQuantity$Outbound,
  PreviewUpdateFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewUpdateFeatureQuantityToJSON(
  previewUpdateFeatureQuantity: PreviewUpdateFeatureQuantity,
): string {
  return JSON.stringify(
    PreviewUpdateFeatureQuantity$outboundSchema.parse(
      previewUpdateFeatureQuantity,
    ),
  );
}

/** @internal */
export const PreviewUpdateDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateDurationType
> = z.enum(PreviewUpdateDurationType);

/** @internal */
export type PreviewUpdateFreeTrial$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const PreviewUpdateFreeTrial$outboundSchema: z.ZodMiniType<
  PreviewUpdateFreeTrial$Outbound,
  PreviewUpdateFreeTrial
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(PreviewUpdateDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function previewUpdateFreeTrialToJSON(
  previewUpdateFreeTrial: PreviewUpdateFreeTrial,
): string {
  return JSON.stringify(
    PreviewUpdateFreeTrial$outboundSchema.parse(previewUpdateFreeTrial),
  );
}

/** @internal */
export const PreviewUpdatePriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdatePriceInterval
> = z.enum(PreviewUpdatePriceInterval);

/** @internal */
export type PreviewUpdatePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewUpdatePrice$outboundSchema: z.ZodMiniType<
  PreviewUpdatePrice$Outbound,
  PreviewUpdatePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: PreviewUpdatePriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewUpdatePriceToJSON(
  previewUpdatePrice: PreviewUpdatePrice,
): string {
  return JSON.stringify(
    PreviewUpdatePrice$outboundSchema.parse(previewUpdatePrice),
  );
}

/** @internal */
export const PreviewUpdateResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateResetInterval
> = z.enum(PreviewUpdateResetInterval);

/** @internal */
export type PreviewUpdateReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewUpdateReset$outboundSchema: z.ZodMiniType<
  PreviewUpdateReset$Outbound,
  PreviewUpdateReset
> = z.pipe(
  z.object({
    interval: PreviewUpdateResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewUpdateResetToJSON(
  previewUpdateReset: PreviewUpdateReset,
): string {
  return JSON.stringify(
    PreviewUpdateReset$outboundSchema.parse(previewUpdateReset),
  );
}

/** @internal */
export type PreviewUpdateTo$Outbound = number | string;

/** @internal */
export const PreviewUpdateTo$outboundSchema: z.ZodMiniType<
  PreviewUpdateTo$Outbound,
  PreviewUpdateTo
> = smartUnion([z.number(), z.string()]);

export function previewUpdateToToJSON(
  previewUpdateTo: PreviewUpdateTo,
): string {
  return JSON.stringify(PreviewUpdateTo$outboundSchema.parse(previewUpdateTo));
}

/** @internal */
export type PreviewUpdateTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const PreviewUpdateTier$outboundSchema: z.ZodMiniType<
  PreviewUpdateTier$Outbound,
  PreviewUpdateTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function previewUpdateTierToJSON(
  previewUpdateTier: PreviewUpdateTier,
): string {
  return JSON.stringify(
    PreviewUpdateTier$outboundSchema.parse(previewUpdateTier),
  );
}

/** @internal */
export const PreviewUpdateItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateItemPriceInterval
> = z.enum(PreviewUpdateItemPriceInterval);

/** @internal */
export const PreviewUpdateBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateBillingMethod
> = z.enum(PreviewUpdateBillingMethod);

/** @internal */
export type PreviewUpdateItemPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<PreviewUpdateTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const PreviewUpdateItemPrice$outboundSchema: z.ZodMiniType<
  PreviewUpdateItemPrice$Outbound,
  PreviewUpdateItemPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => PreviewUpdateTier$outboundSchema))),
    interval: PreviewUpdateItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: PreviewUpdateBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function previewUpdateItemPriceToJSON(
  previewUpdateItemPrice: PreviewUpdateItemPrice,
): string {
  return JSON.stringify(
    PreviewUpdateItemPrice$outboundSchema.parse(previewUpdateItemPrice),
  );
}

/** @internal */
export const PreviewUpdateOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateOnIncrease
> = z.enum(PreviewUpdateOnIncrease);

/** @internal */
export const PreviewUpdateOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateOnDecrease
> = z.enum(PreviewUpdateOnDecrease);

/** @internal */
export type PreviewUpdateProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const PreviewUpdateProration$outboundSchema: z.ZodMiniType<
  PreviewUpdateProration$Outbound,
  PreviewUpdateProration
> = z.pipe(
  z.object({
    onIncrease: PreviewUpdateOnIncrease$outboundSchema,
    onDecrease: PreviewUpdateOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function previewUpdateProrationToJSON(
  previewUpdateProration: PreviewUpdateProration,
): string {
  return JSON.stringify(
    PreviewUpdateProration$outboundSchema.parse(previewUpdateProration),
  );
}

/** @internal */
export const PreviewUpdateExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateExpiryDurationType
> = z.enum(PreviewUpdateExpiryDurationType);

/** @internal */
export type PreviewUpdateRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const PreviewUpdateRollover$outboundSchema: z.ZodMiniType<
  PreviewUpdateRollover$Outbound,
  PreviewUpdateRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: PreviewUpdateExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function previewUpdateRolloverToJSON(
  previewUpdateRollover: PreviewUpdateRollover,
): string {
  return JSON.stringify(
    PreviewUpdateRollover$outboundSchema.parse(previewUpdateRollover),
  );
}

/** @internal */
export type PreviewUpdateItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: PreviewUpdateReset$Outbound | undefined;
  price?: PreviewUpdateItemPrice$Outbound | undefined;
  proration?: PreviewUpdateProration$Outbound | undefined;
  rollover?: PreviewUpdateRollover$Outbound | undefined;
};

/** @internal */
export const PreviewUpdateItem$outboundSchema: z.ZodMiniType<
  PreviewUpdateItem$Outbound,
  PreviewUpdateItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => PreviewUpdateReset$outboundSchema)),
    price: z.optional(z.lazy(() => PreviewUpdateItemPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => PreviewUpdateProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => PreviewUpdateRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewUpdateItemToJSON(
  previewUpdateItem: PreviewUpdateItem,
): string {
  return JSON.stringify(
    PreviewUpdateItem$outboundSchema.parse(previewUpdateItem),
  );
}

/** @internal */
export type PreviewUpdateCustomize$Outbound = {
  price?: PreviewUpdatePrice$Outbound | null | undefined;
  items?: Array<PreviewUpdateItem$Outbound> | undefined;
};

/** @internal */
export const PreviewUpdateCustomize$outboundSchema: z.ZodMiniType<
  PreviewUpdateCustomize$Outbound,
  PreviewUpdateCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => PreviewUpdatePrice$outboundSchema)),
  ),
  items: z.optional(z.array(z.lazy(() => PreviewUpdateItem$outboundSchema))),
});

export function previewUpdateCustomizeToJSON(
  previewUpdateCustomize: PreviewUpdateCustomize,
): string {
  return JSON.stringify(
    PreviewUpdateCustomize$outboundSchema.parse(previewUpdateCustomize),
  );
}

/** @internal */
export type PreviewUpdateInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const PreviewUpdateInvoiceMode$outboundSchema: z.ZodMiniType<
  PreviewUpdateInvoiceMode$Outbound,
  PreviewUpdateInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function previewUpdateInvoiceModeToJSON(
  previewUpdateInvoiceMode: PreviewUpdateInvoiceMode,
): string {
  return JSON.stringify(
    PreviewUpdateInvoiceMode$outboundSchema.parse(previewUpdateInvoiceMode),
  );
}

/** @internal */
export const PreviewUpdateBillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateBillingBehavior
> = z.enum(PreviewUpdateBillingBehavior);

/** @internal */
export const PreviewUpdateCancelAction$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateCancelAction
> = z.enum(PreviewUpdateCancelAction);

/** @internal */
export type PreviewUpdateParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<PreviewUpdateFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  free_trial?: PreviewUpdateFreeTrial$Outbound | null | undefined;
  customize?: PreviewUpdateCustomize$Outbound | undefined;
  invoice_mode?: PreviewUpdateInvoiceMode$Outbound | undefined;
  billing_behavior?: string | undefined;
  cancel_action?: string | undefined;
};

/** @internal */
export const PreviewUpdateParams$outboundSchema: z.ZodMiniType<
  PreviewUpdateParams$Outbound,
  PreviewUpdateParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => PreviewUpdateFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => PreviewUpdateFreeTrial$outboundSchema)),
    ),
    customize: z.optional(z.lazy(() => PreviewUpdateCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => PreviewUpdateInvoiceMode$outboundSchema),
    ),
    billingBehavior: z.optional(PreviewUpdateBillingBehavior$outboundSchema),
    cancelAction: z.optional(PreviewUpdateCancelAction$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      freeTrial: "free_trial",
      invoiceMode: "invoice_mode",
      billingBehavior: "billing_behavior",
      cancelAction: "cancel_action",
    });
  }),
);

export function previewUpdateParamsToJSON(
  previewUpdateParams: PreviewUpdateParams,
): string {
  return JSON.stringify(
    PreviewUpdateParams$outboundSchema.parse(previewUpdateParams),
  );
}

/** @internal */
export const PreviewUpdateDiscount$inboundSchema: z.ZodMiniType<
  PreviewUpdateDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function previewUpdateDiscountFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateDiscount' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateLineItem$inboundSchema: z.ZodMiniType<
  PreviewUpdateLineItem,
  unknown
> = z.object({
  title: types.string(),
  description: types.string(),
  amount: types.number(),
  discounts: types.optional(
    z.array(z.lazy(() => PreviewUpdateDiscount$inboundSchema)),
  ),
});

export function previewUpdateLineItemFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateLineItem' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateNextCycle$inboundSchema: z.ZodMiniType<
  PreviewUpdateNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
    });
  }),
);

export function previewUpdateNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateNextCycle' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateResponse$inboundSchema: z.ZodMiniType<
  PreviewUpdateResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(z.lazy(() => PreviewUpdateLineItem$inboundSchema)),
    total: types.number(),
    currency: types.string(),
    next_cycle: types.optional(
      z.lazy(() => PreviewUpdateNextCycle$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "next_cycle": "nextCycle",
    });
  }),
);

export function previewUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateResponse' from JSON`,
  );
}
