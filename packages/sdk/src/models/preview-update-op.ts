/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type PreviewUpdateGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type PreviewUpdateFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const PreviewUpdatePriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type PreviewUpdatePriceInterval = ClosedEnum<
  typeof PreviewUpdatePriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type PreviewUpdateBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: PreviewUpdatePriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const PreviewUpdateResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type PreviewUpdateResetInterval = ClosedEnum<
  typeof PreviewUpdateResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type PreviewUpdateReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: PreviewUpdateResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type PreviewUpdateTo = number | string;

export type PreviewUpdateTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const PreviewUpdateTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type PreviewUpdateTierBehavior = ClosedEnum<
  typeof PreviewUpdateTierBehavior
>;

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const PreviewUpdateItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type PreviewUpdateItemPriceInterval = ClosedEnum<
  typeof PreviewUpdateItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const PreviewUpdateBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type PreviewUpdateBillingMethod = ClosedEnum<
  typeof PreviewUpdateBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type PreviewUpdatePrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing.  Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<PreviewUpdateTier> | undefined;
  tierBehavior?: PreviewUpdateTierBehavior | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: PreviewUpdateItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: PreviewUpdateBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const PreviewUpdateOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type PreviewUpdateOnIncrease = ClosedEnum<
  typeof PreviewUpdateOnIncrease
>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const PreviewUpdateOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type PreviewUpdateOnDecrease = ClosedEnum<
  typeof PreviewUpdateOnDecrease
>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type PreviewUpdateProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: PreviewUpdateOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: PreviewUpdateOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const PreviewUpdateExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type PreviewUpdateExpiryDurationType = ClosedEnum<
  typeof PreviewUpdateExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type PreviewUpdateRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: PreviewUpdateExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type PreviewUpdatePlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: PreviewUpdateReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: PreviewUpdatePrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: PreviewUpdateProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: PreviewUpdateRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const PreviewUpdateDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type PreviewUpdateDurationType = ClosedEnum<
  typeof PreviewUpdateDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type PreviewUpdateFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: PreviewUpdateDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type PreviewUpdateCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: PreviewUpdateBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<PreviewUpdatePlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: PreviewUpdateFreeTrialParams | null | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type PreviewUpdateInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const PreviewUpdateProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type PreviewUpdateProrationBehavior = ClosedEnum<
  typeof PreviewUpdateProrationBehavior
>;

/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export const PreviewUpdateCancelAction = {
  CancelImmediately: "cancel_immediately",
  CancelEndOfCycle: "cancel_end_of_cycle",
  Uncancel: "uncancel",
} as const;
/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export type PreviewUpdateCancelAction = ClosedEnum<
  typeof PreviewUpdateCancelAction
>;

export type PreviewUpdateParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<PreviewUpdateFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: PreviewUpdateCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: PreviewUpdateInvoiceMode | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: PreviewUpdateProrationBehavior | undefined;
  /**
   * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
   */
  cancelAction?: PreviewUpdateCancelAction | undefined;
};

export type PreviewUpdateDiscount = {
  amountOff: number;
  percentOff?: number | undefined;
  stripeCouponId?: string | undefined;
  couponName?: string | undefined;
};

export type PreviewUpdateLineItem = {
  /**
   * The title of the line item.
   */
  title: string;
  /**
   * A detailed description of the line item.
   */
  description: string;
  /**
   * The amount in cents for this line item.
   */
  amount: number;
  /**
   * List of discounts applied to this line item.
   */
  discounts?: Array<PreviewUpdateDiscount> | undefined;
};

/**
 * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
 */
export type PreviewUpdateNextCycle = {
  /**
   * Unix timestamp (milliseconds) when the next billing cycle starts.
   */
  startsAt: number;
  /**
   * The total amount in cents for the next cycle.
   */
  total: number;
};

/**
 * OK
 */
export type PreviewUpdateResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * List of line items for the current billing period.
   */
  lineItems: Array<PreviewUpdateLineItem>;
  /**
   * The total amount in cents for the current billing period.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * Preview of the next billing cycle, if applicable. This shows what the customer will be charged in subsequent cycles.
   */
  nextCycle?: PreviewUpdateNextCycle | undefined;
};

/** @internal */
export type PreviewUpdateFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const PreviewUpdateFeatureQuantity$outboundSchema: z.ZodMiniType<
  PreviewUpdateFeatureQuantity$Outbound,
  PreviewUpdateFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewUpdateFeatureQuantityToJSON(
  previewUpdateFeatureQuantity: PreviewUpdateFeatureQuantity,
): string {
  return JSON.stringify(
    PreviewUpdateFeatureQuantity$outboundSchema.parse(
      previewUpdateFeatureQuantity,
    ),
  );
}

/** @internal */
export const PreviewUpdatePriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdatePriceInterval
> = z.enum(PreviewUpdatePriceInterval);

/** @internal */
export type PreviewUpdateBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewUpdateBasePrice$outboundSchema: z.ZodMiniType<
  PreviewUpdateBasePrice$Outbound,
  PreviewUpdateBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: PreviewUpdatePriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewUpdateBasePriceToJSON(
  previewUpdateBasePrice: PreviewUpdateBasePrice,
): string {
  return JSON.stringify(
    PreviewUpdateBasePrice$outboundSchema.parse(previewUpdateBasePrice),
  );
}

/** @internal */
export const PreviewUpdateResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateResetInterval
> = z.enum(PreviewUpdateResetInterval);

/** @internal */
export type PreviewUpdateReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const PreviewUpdateReset$outboundSchema: z.ZodMiniType<
  PreviewUpdateReset$Outbound,
  PreviewUpdateReset
> = z.pipe(
  z.object({
    interval: PreviewUpdateResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function previewUpdateResetToJSON(
  previewUpdateReset: PreviewUpdateReset,
): string {
  return JSON.stringify(
    PreviewUpdateReset$outboundSchema.parse(previewUpdateReset),
  );
}

/** @internal */
export type PreviewUpdateTo$Outbound = number | string;

/** @internal */
export const PreviewUpdateTo$outboundSchema: z.ZodMiniType<
  PreviewUpdateTo$Outbound,
  PreviewUpdateTo
> = smartUnion([z.number(), z.string()]);

export function previewUpdateToToJSON(
  previewUpdateTo: PreviewUpdateTo,
): string {
  return JSON.stringify(PreviewUpdateTo$outboundSchema.parse(previewUpdateTo));
}

/** @internal */
export type PreviewUpdateTier$Outbound = {
  to: number | string;
  amount: number;
  flat_amount?: number | null | undefined;
};

/** @internal */
export const PreviewUpdateTier$outboundSchema: z.ZodMiniType<
  PreviewUpdateTier$Outbound,
  PreviewUpdateTier
> = z.pipe(
  z.object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
    flatAmount: z.optional(z.nullable(z.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      flatAmount: "flat_amount",
    });
  }),
);

export function previewUpdateTierToJSON(
  previewUpdateTier: PreviewUpdateTier,
): string {
  return JSON.stringify(
    PreviewUpdateTier$outboundSchema.parse(previewUpdateTier),
  );
}

/** @internal */
export const PreviewUpdateTierBehavior$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateTierBehavior
> = z.enum(PreviewUpdateTierBehavior);

/** @internal */
export const PreviewUpdateItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateItemPriceInterval
> = z.enum(PreviewUpdateItemPriceInterval);

/** @internal */
export const PreviewUpdateBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateBillingMethod
> = z.enum(PreviewUpdateBillingMethod);

/** @internal */
export type PreviewUpdatePrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<PreviewUpdateTier$Outbound> | undefined;
  tier_behavior?: string | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const PreviewUpdatePrice$outboundSchema: z.ZodMiniType<
  PreviewUpdatePrice$Outbound,
  PreviewUpdatePrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => PreviewUpdateTier$outboundSchema))),
    tierBehavior: z.optional(PreviewUpdateTierBehavior$outboundSchema),
    interval: PreviewUpdateItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: PreviewUpdateBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      tierBehavior: "tier_behavior",
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function previewUpdatePriceToJSON(
  previewUpdatePrice: PreviewUpdatePrice,
): string {
  return JSON.stringify(
    PreviewUpdatePrice$outboundSchema.parse(previewUpdatePrice),
  );
}

/** @internal */
export const PreviewUpdateOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateOnIncrease
> = z.enum(PreviewUpdateOnIncrease);

/** @internal */
export const PreviewUpdateOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateOnDecrease
> = z.enum(PreviewUpdateOnDecrease);

/** @internal */
export type PreviewUpdateProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const PreviewUpdateProration$outboundSchema: z.ZodMiniType<
  PreviewUpdateProration$Outbound,
  PreviewUpdateProration
> = z.pipe(
  z.object({
    onIncrease: PreviewUpdateOnIncrease$outboundSchema,
    onDecrease: PreviewUpdateOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function previewUpdateProrationToJSON(
  previewUpdateProration: PreviewUpdateProration,
): string {
  return JSON.stringify(
    PreviewUpdateProration$outboundSchema.parse(previewUpdateProration),
  );
}

/** @internal */
export const PreviewUpdateExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateExpiryDurationType
> = z.enum(PreviewUpdateExpiryDurationType);

/** @internal */
export type PreviewUpdateRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const PreviewUpdateRollover$outboundSchema: z.ZodMiniType<
  PreviewUpdateRollover$Outbound,
  PreviewUpdateRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: PreviewUpdateExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function previewUpdateRolloverToJSON(
  previewUpdateRollover: PreviewUpdateRollover,
): string {
  return JSON.stringify(
    PreviewUpdateRollover$outboundSchema.parse(previewUpdateRollover),
  );
}

/** @internal */
export type PreviewUpdatePlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: PreviewUpdateReset$Outbound | undefined;
  price?: PreviewUpdatePrice$Outbound | undefined;
  proration?: PreviewUpdateProration$Outbound | undefined;
  rollover?: PreviewUpdateRollover$Outbound | undefined;
};

/** @internal */
export const PreviewUpdatePlanItem$outboundSchema: z.ZodMiniType<
  PreviewUpdatePlanItem$Outbound,
  PreviewUpdatePlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => PreviewUpdateReset$outboundSchema)),
    price: z.optional(z.lazy(() => PreviewUpdatePrice$outboundSchema)),
    proration: z.optional(z.lazy(() => PreviewUpdateProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => PreviewUpdateRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function previewUpdatePlanItemToJSON(
  previewUpdatePlanItem: PreviewUpdatePlanItem,
): string {
  return JSON.stringify(
    PreviewUpdatePlanItem$outboundSchema.parse(previewUpdatePlanItem),
  );
}

/** @internal */
export const PreviewUpdateDurationType$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateDurationType
> = z.enum(PreviewUpdateDurationType);

/** @internal */
export type PreviewUpdateFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const PreviewUpdateFreeTrialParams$outboundSchema: z.ZodMiniType<
  PreviewUpdateFreeTrialParams$Outbound,
  PreviewUpdateFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(PreviewUpdateDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function previewUpdateFreeTrialParamsToJSON(
  previewUpdateFreeTrialParams: PreviewUpdateFreeTrialParams,
): string {
  return JSON.stringify(
    PreviewUpdateFreeTrialParams$outboundSchema.parse(
      previewUpdateFreeTrialParams,
    ),
  );
}

/** @internal */
export type PreviewUpdateCustomize$Outbound = {
  price?: PreviewUpdateBasePrice$Outbound | null | undefined;
  items?: Array<PreviewUpdatePlanItem$Outbound> | undefined;
  free_trial?: PreviewUpdateFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const PreviewUpdateCustomize$outboundSchema: z.ZodMiniType<
  PreviewUpdateCustomize$Outbound,
  PreviewUpdateCustomize
> = z.pipe(
  z.object({
    price: z.optional(
      z.nullable(z.lazy(() => PreviewUpdateBasePrice$outboundSchema)),
    ),
    items: z.optional(
      z.array(z.lazy(() => PreviewUpdatePlanItem$outboundSchema)),
    ),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => PreviewUpdateFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function previewUpdateCustomizeToJSON(
  previewUpdateCustomize: PreviewUpdateCustomize,
): string {
  return JSON.stringify(
    PreviewUpdateCustomize$outboundSchema.parse(previewUpdateCustomize),
  );
}

/** @internal */
export type PreviewUpdateInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const PreviewUpdateInvoiceMode$outboundSchema: z.ZodMiniType<
  PreviewUpdateInvoiceMode$Outbound,
  PreviewUpdateInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function previewUpdateInvoiceModeToJSON(
  previewUpdateInvoiceMode: PreviewUpdateInvoiceMode,
): string {
  return JSON.stringify(
    PreviewUpdateInvoiceMode$outboundSchema.parse(previewUpdateInvoiceMode),
  );
}

/** @internal */
export const PreviewUpdateProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateProrationBehavior
> = z.enum(PreviewUpdateProrationBehavior);

/** @internal */
export const PreviewUpdateCancelAction$outboundSchema: z.ZodMiniEnum<
  typeof PreviewUpdateCancelAction
> = z.enum(PreviewUpdateCancelAction);

/** @internal */
export type PreviewUpdateParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<PreviewUpdateFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: PreviewUpdateCustomize$Outbound | undefined;
  invoice_mode?: PreviewUpdateInvoiceMode$Outbound | undefined;
  proration_behavior?: string | undefined;
  cancel_action?: string | undefined;
};

/** @internal */
export const PreviewUpdateParams$outboundSchema: z.ZodMiniType<
  PreviewUpdateParams$Outbound,
  PreviewUpdateParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => PreviewUpdateFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => PreviewUpdateCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => PreviewUpdateInvoiceMode$outboundSchema),
    ),
    prorationBehavior: z.optional(
      PreviewUpdateProrationBehavior$outboundSchema,
    ),
    cancelAction: z.optional(PreviewUpdateCancelAction$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      invoiceMode: "invoice_mode",
      prorationBehavior: "proration_behavior",
      cancelAction: "cancel_action",
    });
  }),
);

export function previewUpdateParamsToJSON(
  previewUpdateParams: PreviewUpdateParams,
): string {
  return JSON.stringify(
    PreviewUpdateParams$outboundSchema.parse(previewUpdateParams),
  );
}

/** @internal */
export const PreviewUpdateDiscount$inboundSchema: z.ZodMiniType<
  PreviewUpdateDiscount,
  unknown
> = z.object({
  amountOff: types.number(),
  percentOff: types.optional(types.number()),
  stripeCouponId: types.optional(types.string()),
  couponName: types.optional(types.string()),
});

export function previewUpdateDiscountFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateDiscount' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateLineItem$inboundSchema: z.ZodMiniType<
  PreviewUpdateLineItem,
  unknown
> = z.object({
  title: types.string(),
  description: types.string(),
  amount: types.number(),
  discounts: types.optional(
    z.array(z.lazy(() => PreviewUpdateDiscount$inboundSchema)),
  ),
});

export function previewUpdateLineItemFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateLineItem' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateNextCycle$inboundSchema: z.ZodMiniType<
  PreviewUpdateNextCycle,
  unknown
> = z.pipe(
  z.object({
    starts_at: types.number(),
    total: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_at": "startsAt",
    });
  }),
);

export function previewUpdateNextCycleFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateNextCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateNextCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateNextCycle' from JSON`,
  );
}

/** @internal */
export const PreviewUpdateResponse$inboundSchema: z.ZodMiniType<
  PreviewUpdateResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    line_items: z.array(z.lazy(() => PreviewUpdateLineItem$inboundSchema)),
    total: types.number(),
    currency: types.string(),
    next_cycle: types.optional(
      z.lazy(() => PreviewUpdateNextCycle$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "line_items": "lineItems",
      "next_cycle": "nextCycle",
    });
  }),
);

export function previewUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<PreviewUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewUpdateResponse' from JSON`,
  );
}
