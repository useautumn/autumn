/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type SetupPaymentGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type SetupPaymentFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const SetupPaymentPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type SetupPaymentPriceInterval = ClosedEnum<
  typeof SetupPaymentPriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type SetupPaymentBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: SetupPaymentPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const SetupPaymentResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type SetupPaymentResetInterval = ClosedEnum<
  typeof SetupPaymentResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type SetupPaymentReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: SetupPaymentResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type SetupPaymentTo = number | string;

export type SetupPaymentTier = {
  to: number | string;
  amount: number;
  flatAmount?: number | null | undefined;
};

export const SetupPaymentTierBehavior = {
  Graduated: "graduated",
  Volume: "volume",
} as const;
export type SetupPaymentTierBehavior = ClosedEnum<
  typeof SetupPaymentTierBehavior
>;

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const SetupPaymentItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type SetupPaymentItemPriceInterval = ClosedEnum<
  typeof SetupPaymentItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const SetupPaymentBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type SetupPaymentBillingMethod = ClosedEnum<
  typeof SetupPaymentBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type SetupPaymentPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing.  Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<SetupPaymentTier> | undefined;
  tierBehavior?: SetupPaymentTierBehavior | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: SetupPaymentItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: SetupPaymentBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const SetupPaymentOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type SetupPaymentOnIncrease = ClosedEnum<typeof SetupPaymentOnIncrease>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const SetupPaymentOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type SetupPaymentOnDecrease = ClosedEnum<typeof SetupPaymentOnDecrease>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type SetupPaymentProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: SetupPaymentOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: SetupPaymentOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const SetupPaymentExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type SetupPaymentExpiryDurationType = ClosedEnum<
  typeof SetupPaymentExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type SetupPaymentRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: SetupPaymentExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type SetupPaymentPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: SetupPaymentReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: SetupPaymentPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: SetupPaymentProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: SetupPaymentRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const SetupPaymentDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type SetupPaymentDurationType = ClosedEnum<
  typeof SetupPaymentDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type SetupPaymentFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: SetupPaymentDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type SetupPaymentCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: SetupPaymentBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<SetupPaymentPlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: SetupPaymentFreeTrialParams | null | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const SetupPaymentProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type SetupPaymentProrationBehavior = ClosedEnum<
  typeof SetupPaymentProrationBehavior
>;

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type SetupPaymentAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

export type SetupPaymentParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * If specified, the plan will be attached to the customer after setup.
   */
  planId?: string | undefined;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<SetupPaymentFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: SetupPaymentCustomize | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: SetupPaymentProrationBehavior | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<SetupPaymentAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Additional parameters to pass into the creation of the Stripe checkout session.
   */
  checkoutSessionParams?: { [k: string]: any } | undefined;
};

/**
 * OK
 */
export type SetupPaymentResponse = {
  /**
   * The ID of the customer
   */
  customerId: string;
  /**
   * The ID of the entity the plan (if specified) will be attached to after setup.
   */
  entityId?: string | undefined;
  /**
   * URL to redirect the customer to setup their payment.
   */
  url: string;
};

/** @internal */
export type SetupPaymentFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const SetupPaymentFeatureQuantity$outboundSchema: z.ZodMiniType<
  SetupPaymentFeatureQuantity$Outbound,
  SetupPaymentFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function setupPaymentFeatureQuantityToJSON(
  setupPaymentFeatureQuantity: SetupPaymentFeatureQuantity,
): string {
  return JSON.stringify(
    SetupPaymentFeatureQuantity$outboundSchema.parse(
      setupPaymentFeatureQuantity,
    ),
  );
}

/** @internal */
export const SetupPaymentPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentPriceInterval
> = z.enum(SetupPaymentPriceInterval);

/** @internal */
export type SetupPaymentBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const SetupPaymentBasePrice$outboundSchema: z.ZodMiniType<
  SetupPaymentBasePrice$Outbound,
  SetupPaymentBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: SetupPaymentPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function setupPaymentBasePriceToJSON(
  setupPaymentBasePrice: SetupPaymentBasePrice,
): string {
  return JSON.stringify(
    SetupPaymentBasePrice$outboundSchema.parse(setupPaymentBasePrice),
  );
}

/** @internal */
export const SetupPaymentResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentResetInterval
> = z.enum(SetupPaymentResetInterval);

/** @internal */
export type SetupPaymentReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const SetupPaymentReset$outboundSchema: z.ZodMiniType<
  SetupPaymentReset$Outbound,
  SetupPaymentReset
> = z.pipe(
  z.object({
    interval: SetupPaymentResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function setupPaymentResetToJSON(
  setupPaymentReset: SetupPaymentReset,
): string {
  return JSON.stringify(
    SetupPaymentReset$outboundSchema.parse(setupPaymentReset),
  );
}

/** @internal */
export type SetupPaymentTo$Outbound = number | string;

/** @internal */
export const SetupPaymentTo$outboundSchema: z.ZodMiniType<
  SetupPaymentTo$Outbound,
  SetupPaymentTo
> = smartUnion([z.number(), z.string()]);

export function setupPaymentToToJSON(setupPaymentTo: SetupPaymentTo): string {
  return JSON.stringify(SetupPaymentTo$outboundSchema.parse(setupPaymentTo));
}

/** @internal */
export type SetupPaymentTier$Outbound = {
  to: number | string;
  amount: number;
  flat_amount?: number | null | undefined;
};

/** @internal */
export const SetupPaymentTier$outboundSchema: z.ZodMiniType<
  SetupPaymentTier$Outbound,
  SetupPaymentTier
> = z.pipe(
  z.object({
    to: smartUnion([z.number(), z.string()]),
    amount: z.number(),
    flatAmount: z.optional(z.nullable(z.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      flatAmount: "flat_amount",
    });
  }),
);

export function setupPaymentTierToJSON(
  setupPaymentTier: SetupPaymentTier,
): string {
  return JSON.stringify(
    SetupPaymentTier$outboundSchema.parse(setupPaymentTier),
  );
}

/** @internal */
export const SetupPaymentTierBehavior$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentTierBehavior
> = z.enum(SetupPaymentTierBehavior);

/** @internal */
export const SetupPaymentItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentItemPriceInterval
> = z.enum(SetupPaymentItemPriceInterval);

/** @internal */
export const SetupPaymentBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentBillingMethod
> = z.enum(SetupPaymentBillingMethod);

/** @internal */
export type SetupPaymentPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<SetupPaymentTier$Outbound> | undefined;
  tier_behavior?: string | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const SetupPaymentPrice$outboundSchema: z.ZodMiniType<
  SetupPaymentPrice$Outbound,
  SetupPaymentPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => SetupPaymentTier$outboundSchema))),
    tierBehavior: z.optional(SetupPaymentTierBehavior$outboundSchema),
    interval: SetupPaymentItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: SetupPaymentBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      tierBehavior: "tier_behavior",
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function setupPaymentPriceToJSON(
  setupPaymentPrice: SetupPaymentPrice,
): string {
  return JSON.stringify(
    SetupPaymentPrice$outboundSchema.parse(setupPaymentPrice),
  );
}

/** @internal */
export const SetupPaymentOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentOnIncrease
> = z.enum(SetupPaymentOnIncrease);

/** @internal */
export const SetupPaymentOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentOnDecrease
> = z.enum(SetupPaymentOnDecrease);

/** @internal */
export type SetupPaymentProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const SetupPaymentProration$outboundSchema: z.ZodMiniType<
  SetupPaymentProration$Outbound,
  SetupPaymentProration
> = z.pipe(
  z.object({
    onIncrease: SetupPaymentOnIncrease$outboundSchema,
    onDecrease: SetupPaymentOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function setupPaymentProrationToJSON(
  setupPaymentProration: SetupPaymentProration,
): string {
  return JSON.stringify(
    SetupPaymentProration$outboundSchema.parse(setupPaymentProration),
  );
}

/** @internal */
export const SetupPaymentExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentExpiryDurationType
> = z.enum(SetupPaymentExpiryDurationType);

/** @internal */
export type SetupPaymentRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const SetupPaymentRollover$outboundSchema: z.ZodMiniType<
  SetupPaymentRollover$Outbound,
  SetupPaymentRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: SetupPaymentExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function setupPaymentRolloverToJSON(
  setupPaymentRollover: SetupPaymentRollover,
): string {
  return JSON.stringify(
    SetupPaymentRollover$outboundSchema.parse(setupPaymentRollover),
  );
}

/** @internal */
export type SetupPaymentPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: SetupPaymentReset$Outbound | undefined;
  price?: SetupPaymentPrice$Outbound | undefined;
  proration?: SetupPaymentProration$Outbound | undefined;
  rollover?: SetupPaymentRollover$Outbound | undefined;
};

/** @internal */
export const SetupPaymentPlanItem$outboundSchema: z.ZodMiniType<
  SetupPaymentPlanItem$Outbound,
  SetupPaymentPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => SetupPaymentReset$outboundSchema)),
    price: z.optional(z.lazy(() => SetupPaymentPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => SetupPaymentProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => SetupPaymentRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function setupPaymentPlanItemToJSON(
  setupPaymentPlanItem: SetupPaymentPlanItem,
): string {
  return JSON.stringify(
    SetupPaymentPlanItem$outboundSchema.parse(setupPaymentPlanItem),
  );
}

/** @internal */
export const SetupPaymentDurationType$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentDurationType
> = z.enum(SetupPaymentDurationType);

/** @internal */
export type SetupPaymentFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const SetupPaymentFreeTrialParams$outboundSchema: z.ZodMiniType<
  SetupPaymentFreeTrialParams$Outbound,
  SetupPaymentFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(SetupPaymentDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function setupPaymentFreeTrialParamsToJSON(
  setupPaymentFreeTrialParams: SetupPaymentFreeTrialParams,
): string {
  return JSON.stringify(
    SetupPaymentFreeTrialParams$outboundSchema.parse(
      setupPaymentFreeTrialParams,
    ),
  );
}

/** @internal */
export type SetupPaymentCustomize$Outbound = {
  price?: SetupPaymentBasePrice$Outbound | null | undefined;
  items?: Array<SetupPaymentPlanItem$Outbound> | undefined;
  free_trial?: SetupPaymentFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const SetupPaymentCustomize$outboundSchema: z.ZodMiniType<
  SetupPaymentCustomize$Outbound,
  SetupPaymentCustomize
> = z.pipe(
  z.object({
    price: z.optional(
      z.nullable(z.lazy(() => SetupPaymentBasePrice$outboundSchema)),
    ),
    items: z.optional(
      z.array(z.lazy(() => SetupPaymentPlanItem$outboundSchema)),
    ),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => SetupPaymentFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function setupPaymentCustomizeToJSON(
  setupPaymentCustomize: SetupPaymentCustomize,
): string {
  return JSON.stringify(
    SetupPaymentCustomize$outboundSchema.parse(setupPaymentCustomize),
  );
}

/** @internal */
export const SetupPaymentProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof SetupPaymentProrationBehavior
> = z.enum(SetupPaymentProrationBehavior);

/** @internal */
export type SetupPaymentAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const SetupPaymentAttachDiscount$outboundSchema: z.ZodMiniType<
  SetupPaymentAttachDiscount$Outbound,
  SetupPaymentAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function setupPaymentAttachDiscountToJSON(
  setupPaymentAttachDiscount: SetupPaymentAttachDiscount,
): string {
  return JSON.stringify(
    SetupPaymentAttachDiscount$outboundSchema.parse(setupPaymentAttachDiscount),
  );
}

/** @internal */
export type SetupPaymentParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id?: string | undefined;
  feature_quantities?: Array<SetupPaymentFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: SetupPaymentCustomize$Outbound | undefined;
  proration_behavior?: string | undefined;
  discounts?: Array<SetupPaymentAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  checkout_session_params?: { [k: string]: any } | undefined;
};

/** @internal */
export const SetupPaymentParams$outboundSchema: z.ZodMiniType<
  SetupPaymentParams$Outbound,
  SetupPaymentParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.optional(z.string()),
    featureQuantities: z.optional(
      z.array(z.lazy(() => SetupPaymentFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => SetupPaymentCustomize$outboundSchema)),
    prorationBehavior: z.optional(SetupPaymentProrationBehavior$outboundSchema),
    discounts: z.optional(
      z.array(z.lazy(() => SetupPaymentAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    checkoutSessionParams: z.optional(z.record(z.string(), z.any())),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      prorationBehavior: "proration_behavior",
      successUrl: "success_url",
      checkoutSessionParams: "checkout_session_params",
    });
  }),
);

export function setupPaymentParamsToJSON(
  setupPaymentParams: SetupPaymentParams,
): string {
  return JSON.stringify(
    SetupPaymentParams$outboundSchema.parse(setupPaymentParams),
  );
}

/** @internal */
export const SetupPaymentResponse$inboundSchema: z.ZodMiniType<
  SetupPaymentResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    url: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
    });
  }),
);

export function setupPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<SetupPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SetupPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SetupPaymentResponse' from JSON`,
  );
}
