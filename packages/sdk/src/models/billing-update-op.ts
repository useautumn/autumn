/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingUpdateGlobals = {
  xApiVersion?: string | undefined;
};

export type BillingUpdateFeatureQuantity = {
  featureId: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

export const BillingUpdateDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type BillingUpdateDurationType = ClosedEnum<
  typeof BillingUpdateDurationType
>;

export type BillingUpdateFreeTrial = {
  durationLength: number;
  durationType?: BillingUpdateDurationType | undefined;
  cardRequired?: boolean | undefined;
};

export const BillingUpdatePriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingUpdatePriceInterval = ClosedEnum<
  typeof BillingUpdatePriceInterval
>;

export type BillingUpdatePrice = {
  amount: number;
  interval: BillingUpdatePriceInterval;
  intervalCount?: number | undefined;
};

export const BillingUpdateResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingUpdateResetInterval = ClosedEnum<
  typeof BillingUpdateResetInterval
>;

export type BillingUpdateReset = {
  interval: BillingUpdateResetInterval;
  intervalCount?: number | undefined;
};

export type BillingUpdateTo = number | string;

export type BillingUpdateTier = {
  to: number | string;
  amount: number;
};

export const BillingUpdateItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingUpdateItemPriceInterval = ClosedEnum<
  typeof BillingUpdateItemPriceInterval
>;

export const BillingUpdateBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BillingUpdateBillingMethod = ClosedEnum<
  typeof BillingUpdateBillingMethod
>;

export type BillingUpdateItemPrice = {
  amount?: number | undefined;
  tiers?: Array<BillingUpdateTier> | undefined;
  interval: BillingUpdateItemPriceInterval;
  intervalCount?: number | undefined;
  billingUnits?: number | undefined;
  billingMethod: BillingUpdateBillingMethod;
  maxPurchase?: number | undefined;
};

export const BillingUpdateOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type BillingUpdateOnIncrease = ClosedEnum<
  typeof BillingUpdateOnIncrease
>;

export const BillingUpdateOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type BillingUpdateOnDecrease = ClosedEnum<
  typeof BillingUpdateOnDecrease
>;

export type BillingUpdateProration = {
  onIncrease: BillingUpdateOnIncrease;
  onDecrease: BillingUpdateOnDecrease;
};

export const BillingUpdateExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type BillingUpdateExpiryDurationType = ClosedEnum<
  typeof BillingUpdateExpiryDurationType
>;

export type BillingUpdateRollover = {
  max?: number | undefined;
  expiryDurationType: BillingUpdateExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export type BillingUpdateItem = {
  featureId: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingUpdateReset | undefined;
  price?: BillingUpdateItemPrice | undefined;
  proration?: BillingUpdateProration | undefined;
  rollover?: BillingUpdateRollover | undefined;
};

/**
 * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
 */
export type BillingUpdateCustomize = {
  price?: BillingUpdatePrice | null | undefined;
  items?: Array<BillingUpdateItem> | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type BillingUpdateInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export const BillingUpdateBillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export type BillingUpdateBillingBehavior = ClosedEnum<
  typeof BillingUpdateBillingBehavior
>;

/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export const BillingUpdateCancelAction = {
  CancelImmediately: "cancel_immediately",
  CancelEndOfCycle: "cancel_end_of_cycle",
  Uncancel: "uncancel",
} as const;
/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export type BillingUpdateCancelAction = ClosedEnum<
  typeof BillingUpdateCancelAction
>;

export type UpdateSubscriptionParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<BillingUpdateFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: BillingUpdateFreeTrial | null | undefined;
  /**
   * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
   */
  customize?: BillingUpdateCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: BillingUpdateInvoiceMode | undefined;
  /**
   * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
   */
  billingBehavior?: BillingUpdateBillingBehavior | undefined;
  /**
   * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
   */
  cancelAction?: BillingUpdateCancelAction | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type BillingUpdateInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const BillingUpdateCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type BillingUpdateCode = OpenEnum<typeof BillingUpdateCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type BillingUpdateRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: BillingUpdateCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type BillingUpdateResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: BillingUpdateInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: BillingUpdateRequiredAction | undefined;
};

/** @internal */
export type BillingUpdateFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingUpdateFeatureQuantity$outboundSchema: z.ZodMiniType<
  BillingUpdateFeatureQuantity$Outbound,
  BillingUpdateFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingUpdateFeatureQuantityToJSON(
  billingUpdateFeatureQuantity: BillingUpdateFeatureQuantity,
): string {
  return JSON.stringify(
    BillingUpdateFeatureQuantity$outboundSchema.parse(
      billingUpdateFeatureQuantity,
    ),
  );
}

/** @internal */
export const BillingUpdateDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateDurationType
> = z.enum(BillingUpdateDurationType);

/** @internal */
export type BillingUpdateFreeTrial$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingUpdateFreeTrial$outboundSchema: z.ZodMiniType<
  BillingUpdateFreeTrial$Outbound,
  BillingUpdateFreeTrial
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(BillingUpdateDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingUpdateFreeTrialToJSON(
  billingUpdateFreeTrial: BillingUpdateFreeTrial,
): string {
  return JSON.stringify(
    BillingUpdateFreeTrial$outboundSchema.parse(billingUpdateFreeTrial),
  );
}

/** @internal */
export const BillingUpdatePriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdatePriceInterval
> = z.enum(BillingUpdatePriceInterval);

/** @internal */
export type BillingUpdatePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingUpdatePrice$outboundSchema: z.ZodMiniType<
  BillingUpdatePrice$Outbound,
  BillingUpdatePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingUpdatePriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingUpdatePriceToJSON(
  billingUpdatePrice: BillingUpdatePrice,
): string {
  return JSON.stringify(
    BillingUpdatePrice$outboundSchema.parse(billingUpdatePrice),
  );
}

/** @internal */
export const BillingUpdateResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateResetInterval
> = z.enum(BillingUpdateResetInterval);

/** @internal */
export type BillingUpdateReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingUpdateReset$outboundSchema: z.ZodMiniType<
  BillingUpdateReset$Outbound,
  BillingUpdateReset
> = z.pipe(
  z.object({
    interval: BillingUpdateResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingUpdateResetToJSON(
  billingUpdateReset: BillingUpdateReset,
): string {
  return JSON.stringify(
    BillingUpdateReset$outboundSchema.parse(billingUpdateReset),
  );
}

/** @internal */
export type BillingUpdateTo$Outbound = number | string;

/** @internal */
export const BillingUpdateTo$outboundSchema: z.ZodMiniType<
  BillingUpdateTo$Outbound,
  BillingUpdateTo
> = smartUnion([z.number(), z.string()]);

export function billingUpdateToToJSON(
  billingUpdateTo: BillingUpdateTo,
): string {
  return JSON.stringify(BillingUpdateTo$outboundSchema.parse(billingUpdateTo));
}

/** @internal */
export type BillingUpdateTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingUpdateTier$outboundSchema: z.ZodMiniType<
  BillingUpdateTier$Outbound,
  BillingUpdateTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingUpdateTierToJSON(
  billingUpdateTier: BillingUpdateTier,
): string {
  return JSON.stringify(
    BillingUpdateTier$outboundSchema.parse(billingUpdateTier),
  );
}

/** @internal */
export const BillingUpdateItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateItemPriceInterval
> = z.enum(BillingUpdateItemPriceInterval);

/** @internal */
export const BillingUpdateBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateBillingMethod
> = z.enum(BillingUpdateBillingMethod);

/** @internal */
export type BillingUpdateItemPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingUpdateTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingUpdateItemPrice$outboundSchema: z.ZodMiniType<
  BillingUpdateItemPrice$Outbound,
  BillingUpdateItemPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => BillingUpdateTier$outboundSchema))),
    interval: BillingUpdateItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingUpdateBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingUpdateItemPriceToJSON(
  billingUpdateItemPrice: BillingUpdateItemPrice,
): string {
  return JSON.stringify(
    BillingUpdateItemPrice$outboundSchema.parse(billingUpdateItemPrice),
  );
}

/** @internal */
export const BillingUpdateOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateOnIncrease
> = z.enum(BillingUpdateOnIncrease);

/** @internal */
export const BillingUpdateOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateOnDecrease
> = z.enum(BillingUpdateOnDecrease);

/** @internal */
export type BillingUpdateProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingUpdateProration$outboundSchema: z.ZodMiniType<
  BillingUpdateProration$Outbound,
  BillingUpdateProration
> = z.pipe(
  z.object({
    onIncrease: BillingUpdateOnIncrease$outboundSchema,
    onDecrease: BillingUpdateOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingUpdateProrationToJSON(
  billingUpdateProration: BillingUpdateProration,
): string {
  return JSON.stringify(
    BillingUpdateProration$outboundSchema.parse(billingUpdateProration),
  );
}

/** @internal */
export const BillingUpdateExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateExpiryDurationType
> = z.enum(BillingUpdateExpiryDurationType);

/** @internal */
export type BillingUpdateRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingUpdateRollover$outboundSchema: z.ZodMiniType<
  BillingUpdateRollover$Outbound,
  BillingUpdateRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingUpdateExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingUpdateRolloverToJSON(
  billingUpdateRollover: BillingUpdateRollover,
): string {
  return JSON.stringify(
    BillingUpdateRollover$outboundSchema.parse(billingUpdateRollover),
  );
}

/** @internal */
export type BillingUpdateItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingUpdateReset$Outbound | undefined;
  price?: BillingUpdateItemPrice$Outbound | undefined;
  proration?: BillingUpdateProration$Outbound | undefined;
  rollover?: BillingUpdateRollover$Outbound | undefined;
};

/** @internal */
export const BillingUpdateItem$outboundSchema: z.ZodMiniType<
  BillingUpdateItem$Outbound,
  BillingUpdateItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => BillingUpdateReset$outboundSchema)),
    price: z.optional(z.lazy(() => BillingUpdateItemPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => BillingUpdateProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => BillingUpdateRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingUpdateItemToJSON(
  billingUpdateItem: BillingUpdateItem,
): string {
  return JSON.stringify(
    BillingUpdateItem$outboundSchema.parse(billingUpdateItem),
  );
}

/** @internal */
export type BillingUpdateCustomize$Outbound = {
  price?: BillingUpdatePrice$Outbound | null | undefined;
  items?: Array<BillingUpdateItem$Outbound> | undefined;
};

/** @internal */
export const BillingUpdateCustomize$outboundSchema: z.ZodMiniType<
  BillingUpdateCustomize$Outbound,
  BillingUpdateCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => BillingUpdatePrice$outboundSchema)),
  ),
  items: z.optional(z.array(z.lazy(() => BillingUpdateItem$outboundSchema))),
});

export function billingUpdateCustomizeToJSON(
  billingUpdateCustomize: BillingUpdateCustomize,
): string {
  return JSON.stringify(
    BillingUpdateCustomize$outboundSchema.parse(billingUpdateCustomize),
  );
}

/** @internal */
export type BillingUpdateInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const BillingUpdateInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingUpdateInvoiceMode$Outbound,
  BillingUpdateInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function billingUpdateInvoiceModeToJSON(
  billingUpdateInvoiceMode: BillingUpdateInvoiceMode,
): string {
  return JSON.stringify(
    BillingUpdateInvoiceMode$outboundSchema.parse(billingUpdateInvoiceMode),
  );
}

/** @internal */
export const BillingUpdateBillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateBillingBehavior
> = z.enum(BillingUpdateBillingBehavior);

/** @internal */
export const BillingUpdateCancelAction$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateCancelAction
> = z.enum(BillingUpdateCancelAction);

/** @internal */
export type UpdateSubscriptionParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<BillingUpdateFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  free_trial?: BillingUpdateFreeTrial$Outbound | null | undefined;
  customize?: BillingUpdateCustomize$Outbound | undefined;
  invoice_mode?: BillingUpdateInvoiceMode$Outbound | undefined;
  billing_behavior?: string | undefined;
  cancel_action?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionParams$outboundSchema: z.ZodMiniType<
  UpdateSubscriptionParams$Outbound,
  UpdateSubscriptionParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => BillingUpdateFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => BillingUpdateFreeTrial$outboundSchema)),
    ),
    customize: z.optional(z.lazy(() => BillingUpdateCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => BillingUpdateInvoiceMode$outboundSchema),
    ),
    billingBehavior: z.optional(BillingUpdateBillingBehavior$outboundSchema),
    cancelAction: z.optional(BillingUpdateCancelAction$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      freeTrial: "free_trial",
      invoiceMode: "invoice_mode",
      billingBehavior: "billing_behavior",
      cancelAction: "cancel_action",
    });
  }),
);

export function updateSubscriptionParamsToJSON(
  updateSubscriptionParams: UpdateSubscriptionParams,
): string {
  return JSON.stringify(
    UpdateSubscriptionParams$outboundSchema.parse(updateSubscriptionParams),
  );
}

/** @internal */
export const BillingUpdateInvoice$inboundSchema: z.ZodMiniType<
  BillingUpdateInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function billingUpdateInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateInvoice' from JSON`,
  );
}

/** @internal */
export const BillingUpdateCode$inboundSchema: z.ZodMiniType<
  BillingUpdateCode,
  unknown
> = openEnums.inboundSchema(BillingUpdateCode);

/** @internal */
export const BillingUpdateRequiredAction$inboundSchema: z.ZodMiniType<
  BillingUpdateRequiredAction,
  unknown
> = z.object({
  code: BillingUpdateCode$inboundSchema,
  reason: types.string(),
});

export function billingUpdateRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateRequiredAction' from JSON`,
  );
}

/** @internal */
export const BillingUpdateResponse$inboundSchema: z.ZodMiniType<
  BillingUpdateResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => BillingUpdateInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => BillingUpdateRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function billingUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateResponse' from JSON`,
  );
}
