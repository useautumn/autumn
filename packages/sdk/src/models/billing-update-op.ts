/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingUpdateGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type BillingUpdateFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const BillingUpdatePriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type BillingUpdatePriceInterval = ClosedEnum<
  typeof BillingUpdatePriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type BillingUpdateBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: BillingUpdatePriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const BillingUpdateResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type BillingUpdateResetInterval = ClosedEnum<
  typeof BillingUpdateResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type BillingUpdateReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: BillingUpdateResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type BillingUpdateTo = number | string;

export type BillingUpdateTier = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const BillingUpdateItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type BillingUpdateItemPriceInterval = ClosedEnum<
  typeof BillingUpdateItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const BillingUpdateBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type BillingUpdateBillingMethod = ClosedEnum<
  typeof BillingUpdateBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type BillingUpdatePrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<BillingUpdateTier> | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: BillingUpdateItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: BillingUpdateBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const BillingUpdateOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type BillingUpdateOnIncrease = ClosedEnum<
  typeof BillingUpdateOnIncrease
>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const BillingUpdateOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type BillingUpdateOnDecrease = ClosedEnum<
  typeof BillingUpdateOnDecrease
>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type BillingUpdateProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: BillingUpdateOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: BillingUpdateOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const BillingUpdateExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type BillingUpdateExpiryDurationType = ClosedEnum<
  typeof BillingUpdateExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type BillingUpdateRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: BillingUpdateExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type BillingUpdatePlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: BillingUpdateReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: BillingUpdatePrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: BillingUpdateProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: BillingUpdateRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const BillingUpdateDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type BillingUpdateDurationType = ClosedEnum<
  typeof BillingUpdateDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type BillingUpdateFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: BillingUpdateDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type BillingUpdateCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: BillingUpdateBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<BillingUpdatePlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: BillingUpdateFreeTrialParams | null | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type BillingUpdateInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const BillingUpdateProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type BillingUpdateProrationBehavior = ClosedEnum<
  typeof BillingUpdateProrationBehavior
>;

/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export const BillingUpdateCancelAction = {
  CancelImmediately: "cancel_immediately",
  CancelEndOfCycle: "cancel_end_of_cycle",
  Uncancel: "uncancel",
} as const;
/**
 * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
 */
export type BillingUpdateCancelAction = ClosedEnum<
  typeof BillingUpdateCancelAction
>;

export type UpdateSubscriptionParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<BillingUpdateFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: BillingUpdateCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: BillingUpdateInvoiceMode | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: BillingUpdateProrationBehavior | undefined;
  /**
   * Action to perform for cancellation. 'cancel_immediately' cancels now with prorated refund, 'cancel_end_of_cycle' cancels at period end, 'uncancel' reverses a pending cancellation.
   */
  cancelAction?: BillingUpdateCancelAction | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type BillingUpdateInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const BillingUpdateCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type BillingUpdateCode = OpenEnum<typeof BillingUpdateCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type BillingUpdateRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: BillingUpdateCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type BillingUpdateResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: BillingUpdateInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: BillingUpdateRequiredAction | undefined;
};

/** @internal */
export type BillingUpdateFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingUpdateFeatureQuantity$outboundSchema: z.ZodMiniType<
  BillingUpdateFeatureQuantity$Outbound,
  BillingUpdateFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingUpdateFeatureQuantityToJSON(
  billingUpdateFeatureQuantity: BillingUpdateFeatureQuantity,
): string {
  return JSON.stringify(
    BillingUpdateFeatureQuantity$outboundSchema.parse(
      billingUpdateFeatureQuantity,
    ),
  );
}

/** @internal */
export const BillingUpdatePriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdatePriceInterval
> = z.enum(BillingUpdatePriceInterval);

/** @internal */
export type BillingUpdateBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingUpdateBasePrice$outboundSchema: z.ZodMiniType<
  BillingUpdateBasePrice$Outbound,
  BillingUpdateBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingUpdatePriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingUpdateBasePriceToJSON(
  billingUpdateBasePrice: BillingUpdateBasePrice,
): string {
  return JSON.stringify(
    BillingUpdateBasePrice$outboundSchema.parse(billingUpdateBasePrice),
  );
}

/** @internal */
export const BillingUpdateResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateResetInterval
> = z.enum(BillingUpdateResetInterval);

/** @internal */
export type BillingUpdateReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingUpdateReset$outboundSchema: z.ZodMiniType<
  BillingUpdateReset$Outbound,
  BillingUpdateReset
> = z.pipe(
  z.object({
    interval: BillingUpdateResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingUpdateResetToJSON(
  billingUpdateReset: BillingUpdateReset,
): string {
  return JSON.stringify(
    BillingUpdateReset$outboundSchema.parse(billingUpdateReset),
  );
}

/** @internal */
export type BillingUpdateTo$Outbound = number | string;

/** @internal */
export const BillingUpdateTo$outboundSchema: z.ZodMiniType<
  BillingUpdateTo$Outbound,
  BillingUpdateTo
> = smartUnion([z.number(), z.string()]);

export function billingUpdateToToJSON(
  billingUpdateTo: BillingUpdateTo,
): string {
  return JSON.stringify(BillingUpdateTo$outboundSchema.parse(billingUpdateTo));
}

/** @internal */
export type BillingUpdateTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingUpdateTier$outboundSchema: z.ZodMiniType<
  BillingUpdateTier$Outbound,
  BillingUpdateTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingUpdateTierToJSON(
  billingUpdateTier: BillingUpdateTier,
): string {
  return JSON.stringify(
    BillingUpdateTier$outboundSchema.parse(billingUpdateTier),
  );
}

/** @internal */
export const BillingUpdateItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateItemPriceInterval
> = z.enum(BillingUpdateItemPriceInterval);

/** @internal */
export const BillingUpdateBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateBillingMethod
> = z.enum(BillingUpdateBillingMethod);

/** @internal */
export type BillingUpdatePrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingUpdateTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingUpdatePrice$outboundSchema: z.ZodMiniType<
  BillingUpdatePrice$Outbound,
  BillingUpdatePrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => BillingUpdateTier$outboundSchema))),
    interval: BillingUpdateItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingUpdateBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingUpdatePriceToJSON(
  billingUpdatePrice: BillingUpdatePrice,
): string {
  return JSON.stringify(
    BillingUpdatePrice$outboundSchema.parse(billingUpdatePrice),
  );
}

/** @internal */
export const BillingUpdateOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateOnIncrease
> = z.enum(BillingUpdateOnIncrease);

/** @internal */
export const BillingUpdateOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateOnDecrease
> = z.enum(BillingUpdateOnDecrease);

/** @internal */
export type BillingUpdateProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingUpdateProration$outboundSchema: z.ZodMiniType<
  BillingUpdateProration$Outbound,
  BillingUpdateProration
> = z.pipe(
  z.object({
    onIncrease: BillingUpdateOnIncrease$outboundSchema,
    onDecrease: BillingUpdateOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingUpdateProrationToJSON(
  billingUpdateProration: BillingUpdateProration,
): string {
  return JSON.stringify(
    BillingUpdateProration$outboundSchema.parse(billingUpdateProration),
  );
}

/** @internal */
export const BillingUpdateExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateExpiryDurationType
> = z.enum(BillingUpdateExpiryDurationType);

/** @internal */
export type BillingUpdateRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingUpdateRollover$outboundSchema: z.ZodMiniType<
  BillingUpdateRollover$Outbound,
  BillingUpdateRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingUpdateExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingUpdateRolloverToJSON(
  billingUpdateRollover: BillingUpdateRollover,
): string {
  return JSON.stringify(
    BillingUpdateRollover$outboundSchema.parse(billingUpdateRollover),
  );
}

/** @internal */
export type BillingUpdatePlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingUpdateReset$Outbound | undefined;
  price?: BillingUpdatePrice$Outbound | undefined;
  proration?: BillingUpdateProration$Outbound | undefined;
  rollover?: BillingUpdateRollover$Outbound | undefined;
};

/** @internal */
export const BillingUpdatePlanItem$outboundSchema: z.ZodMiniType<
  BillingUpdatePlanItem$Outbound,
  BillingUpdatePlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => BillingUpdateReset$outboundSchema)),
    price: z.optional(z.lazy(() => BillingUpdatePrice$outboundSchema)),
    proration: z.optional(z.lazy(() => BillingUpdateProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => BillingUpdateRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingUpdatePlanItemToJSON(
  billingUpdatePlanItem: BillingUpdatePlanItem,
): string {
  return JSON.stringify(
    BillingUpdatePlanItem$outboundSchema.parse(billingUpdatePlanItem),
  );
}

/** @internal */
export const BillingUpdateDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateDurationType
> = z.enum(BillingUpdateDurationType);

/** @internal */
export type BillingUpdateFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingUpdateFreeTrialParams$outboundSchema: z.ZodMiniType<
  BillingUpdateFreeTrialParams$Outbound,
  BillingUpdateFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(BillingUpdateDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingUpdateFreeTrialParamsToJSON(
  billingUpdateFreeTrialParams: BillingUpdateFreeTrialParams,
): string {
  return JSON.stringify(
    BillingUpdateFreeTrialParams$outboundSchema.parse(
      billingUpdateFreeTrialParams,
    ),
  );
}

/** @internal */
export type BillingUpdateCustomize$Outbound = {
  price?: BillingUpdateBasePrice$Outbound | null | undefined;
  items?: Array<BillingUpdatePlanItem$Outbound> | undefined;
  free_trial?: BillingUpdateFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const BillingUpdateCustomize$outboundSchema: z.ZodMiniType<
  BillingUpdateCustomize$Outbound,
  BillingUpdateCustomize
> = z.pipe(
  z.object({
    price: z.optional(
      z.nullable(z.lazy(() => BillingUpdateBasePrice$outboundSchema)),
    ),
    items: z.optional(
      z.array(z.lazy(() => BillingUpdatePlanItem$outboundSchema)),
    ),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => BillingUpdateFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function billingUpdateCustomizeToJSON(
  billingUpdateCustomize: BillingUpdateCustomize,
): string {
  return JSON.stringify(
    BillingUpdateCustomize$outboundSchema.parse(billingUpdateCustomize),
  );
}

/** @internal */
export type BillingUpdateInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const BillingUpdateInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingUpdateInvoiceMode$Outbound,
  BillingUpdateInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function billingUpdateInvoiceModeToJSON(
  billingUpdateInvoiceMode: BillingUpdateInvoiceMode,
): string {
  return JSON.stringify(
    BillingUpdateInvoiceMode$outboundSchema.parse(billingUpdateInvoiceMode),
  );
}

/** @internal */
export const BillingUpdateProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateProrationBehavior
> = z.enum(BillingUpdateProrationBehavior);

/** @internal */
export const BillingUpdateCancelAction$outboundSchema: z.ZodMiniEnum<
  typeof BillingUpdateCancelAction
> = z.enum(BillingUpdateCancelAction);

/** @internal */
export type UpdateSubscriptionParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<BillingUpdateFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: BillingUpdateCustomize$Outbound | undefined;
  invoice_mode?: BillingUpdateInvoiceMode$Outbound | undefined;
  proration_behavior?: string | undefined;
  cancel_action?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionParams$outboundSchema: z.ZodMiniType<
  UpdateSubscriptionParams$Outbound,
  UpdateSubscriptionParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => BillingUpdateFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => BillingUpdateCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => BillingUpdateInvoiceMode$outboundSchema),
    ),
    prorationBehavior: z.optional(
      BillingUpdateProrationBehavior$outboundSchema,
    ),
    cancelAction: z.optional(BillingUpdateCancelAction$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      invoiceMode: "invoice_mode",
      prorationBehavior: "proration_behavior",
      cancelAction: "cancel_action",
    });
  }),
);

export function updateSubscriptionParamsToJSON(
  updateSubscriptionParams: UpdateSubscriptionParams,
): string {
  return JSON.stringify(
    UpdateSubscriptionParams$outboundSchema.parse(updateSubscriptionParams),
  );
}

/** @internal */
export const BillingUpdateInvoice$inboundSchema: z.ZodMiniType<
  BillingUpdateInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function billingUpdateInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateInvoice' from JSON`,
  );
}

/** @internal */
export const BillingUpdateCode$inboundSchema: z.ZodMiniType<
  BillingUpdateCode,
  unknown
> = openEnums.inboundSchema(BillingUpdateCode);

/** @internal */
export const BillingUpdateRequiredAction$inboundSchema: z.ZodMiniType<
  BillingUpdateRequiredAction,
  unknown
> = z.object({
  code: BillingUpdateCode$inboundSchema,
  reason: types.string(),
});

export function billingUpdateRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateRequiredAction' from JSON`,
  );
}

/** @internal */
export const BillingUpdateResponse$inboundSchema: z.ZodMiniType<
  BillingUpdateResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => BillingUpdateInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => BillingUpdateRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function billingUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingUpdateResponse' from JSON`,
  );
}
