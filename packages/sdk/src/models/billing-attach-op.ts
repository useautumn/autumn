/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingAttachGlobals = {
  xApiVersion?: string | undefined;
};

export type BillingAttachFeatureQuantity = {
  featureId: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

export const BillingAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
export type BillingAttachDurationType = ClosedEnum<
  typeof BillingAttachDurationType
>;

export type BillingAttachFreeTrial = {
  durationLength: number;
  durationType?: BillingAttachDurationType | undefined;
  cardRequired?: boolean | undefined;
};

export const BillingAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingAttachPriceInterval = ClosedEnum<
  typeof BillingAttachPriceInterval
>;

export type BillingAttachPrice = {
  amount: number;
  interval: BillingAttachPriceInterval;
  intervalCount?: number | undefined;
};

export const BillingAttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingAttachResetInterval = ClosedEnum<
  typeof BillingAttachResetInterval
>;

export type BillingAttachReset = {
  interval: BillingAttachResetInterval;
  intervalCount?: number | undefined;
};

export type BillingAttachTo = number | string;

export type BillingAttachTier = {
  to: number | string;
  amount: number;
};

export const BillingAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type BillingAttachItemPriceInterval = ClosedEnum<
  typeof BillingAttachItemPriceInterval
>;

export const BillingAttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type BillingAttachBillingMethod = ClosedEnum<
  typeof BillingAttachBillingMethod
>;

export type BillingAttachItemPrice = {
  amount?: number | undefined;
  tiers?: Array<BillingAttachTier> | undefined;
  interval: BillingAttachItemPriceInterval;
  intervalCount?: number | undefined;
  billingUnits?: number | undefined;
  billingMethod: BillingAttachBillingMethod;
  maxPurchase?: number | undefined;
};

export const BillingAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
export type BillingAttachOnIncrease = ClosedEnum<
  typeof BillingAttachOnIncrease
>;

export const BillingAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
export type BillingAttachOnDecrease = ClosedEnum<
  typeof BillingAttachOnDecrease
>;

export type BillingAttachProration = {
  onIncrease: BillingAttachOnIncrease;
  onDecrease: BillingAttachOnDecrease;
};

export const BillingAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
export type BillingAttachExpiryDurationType = ClosedEnum<
  typeof BillingAttachExpiryDurationType
>;

export type BillingAttachRollover = {
  max?: number | undefined;
  expiryDurationType: BillingAttachExpiryDurationType;
  expiryDurationLength?: number | undefined;
};

export type BillingAttachItem = {
  featureId: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingAttachReset | undefined;
  price?: BillingAttachItemPrice | undefined;
  proration?: BillingAttachProration | undefined;
  rollover?: BillingAttachRollover | undefined;
};

/**
 * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
 */
export type BillingAttachCustomize = {
  price?: BillingAttachPrice | null | undefined;
  items?: Array<BillingAttachItem> | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type BillingAttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export const BillingAttachBillingBehavior = {
  ProrateImmediately: "prorate_immediately",
  NextCycleOnly: "next_cycle_only",
} as const;
/**
 * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
 */
export type BillingAttachBillingBehavior = ClosedEnum<
  typeof BillingAttachBillingBehavior
>;

export type BillingAttachDiscount2 = {
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode: string;
};

export type BillingAttachDiscount1 = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId: string;
};

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type BillingAttachDiscountUnion =
  | BillingAttachDiscount1
  | BillingAttachDiscount2;

/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export const BillingAttachPlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export type BillingAttachPlanSchedule = ClosedEnum<
  typeof BillingAttachPlanSchedule
>;

export type AttachParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<BillingAttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: BillingAttachFreeTrial | null | undefined;
  /**
   * Customize the plan to attach. Can either override the price of the plan, the items in the plan, or both.
   */
  customize?: BillingAttachCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: BillingAttachInvoiceMode | undefined;
  /**
   * How to handle billing when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'next_cycle_only' skips creating any charges and applies the change at the next billing cycle.
   */
  billingBehavior?: BillingAttachBillingBehavior | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?:
    | Array<BillingAttachDiscount1 | BillingAttachDiscount2>
    | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
   */
  planSchedule?: BillingAttachPlanSchedule | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type BillingAttachInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const BillingAttachCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type BillingAttachCode = OpenEnum<typeof BillingAttachCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type BillingAttachRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: BillingAttachCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type BillingAttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: BillingAttachInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: BillingAttachRequiredAction | undefined;
};

/** @internal */
export type BillingAttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingAttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  BillingAttachFeatureQuantity$Outbound,
  BillingAttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingAttachFeatureQuantityToJSON(
  billingAttachFeatureQuantity: BillingAttachFeatureQuantity,
): string {
  return JSON.stringify(
    BillingAttachFeatureQuantity$outboundSchema.parse(
      billingAttachFeatureQuantity,
    ),
  );
}

/** @internal */
export const BillingAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachDurationType
> = z.enum(BillingAttachDurationType);

/** @internal */
export type BillingAttachFreeTrial$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingAttachFreeTrial$outboundSchema: z.ZodMiniType<
  BillingAttachFreeTrial$Outbound,
  BillingAttachFreeTrial
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(BillingAttachDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingAttachFreeTrialToJSON(
  billingAttachFreeTrial: BillingAttachFreeTrial,
): string {
  return JSON.stringify(
    BillingAttachFreeTrial$outboundSchema.parse(billingAttachFreeTrial),
  );
}

/** @internal */
export const BillingAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachPriceInterval
> = z.enum(BillingAttachPriceInterval);

/** @internal */
export type BillingAttachPrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingAttachPrice$outboundSchema: z.ZodMiniType<
  BillingAttachPrice$Outbound,
  BillingAttachPrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingAttachPriceToJSON(
  billingAttachPrice: BillingAttachPrice,
): string {
  return JSON.stringify(
    BillingAttachPrice$outboundSchema.parse(billingAttachPrice),
  );
}

/** @internal */
export const BillingAttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachResetInterval
> = z.enum(BillingAttachResetInterval);

/** @internal */
export type BillingAttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingAttachReset$outboundSchema: z.ZodMiniType<
  BillingAttachReset$Outbound,
  BillingAttachReset
> = z.pipe(
  z.object({
    interval: BillingAttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingAttachResetToJSON(
  billingAttachReset: BillingAttachReset,
): string {
  return JSON.stringify(
    BillingAttachReset$outboundSchema.parse(billingAttachReset),
  );
}

/** @internal */
export type BillingAttachTo$Outbound = number | string;

/** @internal */
export const BillingAttachTo$outboundSchema: z.ZodMiniType<
  BillingAttachTo$Outbound,
  BillingAttachTo
> = smartUnion([z.number(), z.string()]);

export function billingAttachToToJSON(
  billingAttachTo: BillingAttachTo,
): string {
  return JSON.stringify(BillingAttachTo$outboundSchema.parse(billingAttachTo));
}

/** @internal */
export type BillingAttachTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingAttachTier$outboundSchema: z.ZodMiniType<
  BillingAttachTier$Outbound,
  BillingAttachTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingAttachTierToJSON(
  billingAttachTier: BillingAttachTier,
): string {
  return JSON.stringify(
    BillingAttachTier$outboundSchema.parse(billingAttachTier),
  );
}

/** @internal */
export const BillingAttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachItemPriceInterval
> = z.enum(BillingAttachItemPriceInterval);

/** @internal */
export const BillingAttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachBillingMethod
> = z.enum(BillingAttachBillingMethod);

/** @internal */
export type BillingAttachItemPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingAttachTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingAttachItemPrice$outboundSchema: z.ZodMiniType<
  BillingAttachItemPrice$Outbound,
  BillingAttachItemPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => BillingAttachTier$outboundSchema))),
    interval: BillingAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingAttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingAttachItemPriceToJSON(
  billingAttachItemPrice: BillingAttachItemPrice,
): string {
  return JSON.stringify(
    BillingAttachItemPrice$outboundSchema.parse(billingAttachItemPrice),
  );
}

/** @internal */
export const BillingAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachOnIncrease
> = z.enum(BillingAttachOnIncrease);

/** @internal */
export const BillingAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachOnDecrease
> = z.enum(BillingAttachOnDecrease);

/** @internal */
export type BillingAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingAttachProration$outboundSchema: z.ZodMiniType<
  BillingAttachProration$Outbound,
  BillingAttachProration
> = z.pipe(
  z.object({
    onIncrease: BillingAttachOnIncrease$outboundSchema,
    onDecrease: BillingAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingAttachProrationToJSON(
  billingAttachProration: BillingAttachProration,
): string {
  return JSON.stringify(
    BillingAttachProration$outboundSchema.parse(billingAttachProration),
  );
}

/** @internal */
export const BillingAttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachExpiryDurationType
> = z.enum(BillingAttachExpiryDurationType);

/** @internal */
export type BillingAttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingAttachRollover$outboundSchema: z.ZodMiniType<
  BillingAttachRollover$Outbound,
  BillingAttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingAttachRolloverToJSON(
  billingAttachRollover: BillingAttachRollover,
): string {
  return JSON.stringify(
    BillingAttachRollover$outboundSchema.parse(billingAttachRollover),
  );
}

/** @internal */
export type BillingAttachItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingAttachReset$Outbound | undefined;
  price?: BillingAttachItemPrice$Outbound | undefined;
  proration?: BillingAttachProration$Outbound | undefined;
  rollover?: BillingAttachRollover$Outbound | undefined;
};

/** @internal */
export const BillingAttachItem$outboundSchema: z.ZodMiniType<
  BillingAttachItem$Outbound,
  BillingAttachItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => BillingAttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => BillingAttachItemPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => BillingAttachProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => BillingAttachRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingAttachItemToJSON(
  billingAttachItem: BillingAttachItem,
): string {
  return JSON.stringify(
    BillingAttachItem$outboundSchema.parse(billingAttachItem),
  );
}

/** @internal */
export type BillingAttachCustomize$Outbound = {
  price?: BillingAttachPrice$Outbound | null | undefined;
  items?: Array<BillingAttachItem$Outbound> | undefined;
};

/** @internal */
export const BillingAttachCustomize$outboundSchema: z.ZodMiniType<
  BillingAttachCustomize$Outbound,
  BillingAttachCustomize
> = z.object({
  price: z.optional(
    z.nullable(z.lazy(() => BillingAttachPrice$outboundSchema)),
  ),
  items: z.optional(z.array(z.lazy(() => BillingAttachItem$outboundSchema))),
});

export function billingAttachCustomizeToJSON(
  billingAttachCustomize: BillingAttachCustomize,
): string {
  return JSON.stringify(
    BillingAttachCustomize$outboundSchema.parse(billingAttachCustomize),
  );
}

/** @internal */
export type BillingAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const BillingAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingAttachInvoiceMode$Outbound,
  BillingAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function billingAttachInvoiceModeToJSON(
  billingAttachInvoiceMode: BillingAttachInvoiceMode,
): string {
  return JSON.stringify(
    BillingAttachInvoiceMode$outboundSchema.parse(billingAttachInvoiceMode),
  );
}

/** @internal */
export const BillingAttachBillingBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachBillingBehavior
> = z.enum(BillingAttachBillingBehavior);

/** @internal */
export type BillingAttachDiscount2$Outbound = {
  promotion_code: string;
};

/** @internal */
export const BillingAttachDiscount2$outboundSchema: z.ZodMiniType<
  BillingAttachDiscount2$Outbound,
  BillingAttachDiscount2
> = z.pipe(
  z.object({
    promotionCode: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      promotionCode: "promotion_code",
    });
  }),
);

export function billingAttachDiscount2ToJSON(
  billingAttachDiscount2: BillingAttachDiscount2,
): string {
  return JSON.stringify(
    BillingAttachDiscount2$outboundSchema.parse(billingAttachDiscount2),
  );
}

/** @internal */
export type BillingAttachDiscount1$Outbound = {
  reward_id: string;
};

/** @internal */
export const BillingAttachDiscount1$outboundSchema: z.ZodMiniType<
  BillingAttachDiscount1$Outbound,
  BillingAttachDiscount1
> = z.pipe(
  z.object({
    rewardId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
    });
  }),
);

export function billingAttachDiscount1ToJSON(
  billingAttachDiscount1: BillingAttachDiscount1,
): string {
  return JSON.stringify(
    BillingAttachDiscount1$outboundSchema.parse(billingAttachDiscount1),
  );
}

/** @internal */
export type BillingAttachDiscountUnion$Outbound =
  | BillingAttachDiscount1$Outbound
  | BillingAttachDiscount2$Outbound;

/** @internal */
export const BillingAttachDiscountUnion$outboundSchema: z.ZodMiniType<
  BillingAttachDiscountUnion$Outbound,
  BillingAttachDiscountUnion
> = smartUnion([
  z.lazy(() => BillingAttachDiscount1$outboundSchema),
  z.lazy(() => BillingAttachDiscount2$outboundSchema),
]);

export function billingAttachDiscountUnionToJSON(
  billingAttachDiscountUnion: BillingAttachDiscountUnion,
): string {
  return JSON.stringify(
    BillingAttachDiscountUnion$outboundSchema.parse(billingAttachDiscountUnion),
  );
}

/** @internal */
export const BillingAttachPlanSchedule$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachPlanSchedule
> = z.enum(BillingAttachPlanSchedule);

/** @internal */
export type AttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<BillingAttachFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  free_trial?: BillingAttachFreeTrial$Outbound | null | undefined;
  customize?: BillingAttachCustomize$Outbound | undefined;
  invoice_mode?: BillingAttachInvoiceMode$Outbound | undefined;
  billing_behavior?: string | undefined;
  discounts?:
    | Array<BillingAttachDiscount1$Outbound | BillingAttachDiscount2$Outbound>
    | undefined;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
};

/** @internal */
export const AttachParams$outboundSchema: z.ZodMiniType<
  AttachParams$Outbound,
  AttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => BillingAttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => BillingAttachFreeTrial$outboundSchema)),
    ),
    customize: z.optional(z.lazy(() => BillingAttachCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => BillingAttachInvoiceMode$outboundSchema),
    ),
    billingBehavior: z.optional(BillingAttachBillingBehavior$outboundSchema),
    discounts: z.optional(z.array(smartUnion([
      z.lazy(() => BillingAttachDiscount1$outboundSchema),
      z.lazy(() =>
        BillingAttachDiscount2$outboundSchema
      ),
    ]))),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(BillingAttachPlanSchedule$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      freeTrial: "free_trial",
      invoiceMode: "invoice_mode",
      billingBehavior: "billing_behavior",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
    });
  }),
);

export function attachParamsToJSON(attachParams: AttachParams): string {
  return JSON.stringify(AttachParams$outboundSchema.parse(attachParams));
}

/** @internal */
export const BillingAttachInvoice$inboundSchema: z.ZodMiniType<
  BillingAttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function billingAttachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachInvoice' from JSON`,
  );
}

/** @internal */
export const BillingAttachCode$inboundSchema: z.ZodMiniType<
  BillingAttachCode,
  unknown
> = openEnums.inboundSchema(BillingAttachCode);

/** @internal */
export const BillingAttachRequiredAction$inboundSchema: z.ZodMiniType<
  BillingAttachRequiredAction,
  unknown
> = z.object({
  code: BillingAttachCode$inboundSchema,
  reason: types.string(),
});

export function billingAttachRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachRequiredAction' from JSON`,
  );
}

/** @internal */
export const BillingAttachResponse$inboundSchema: z.ZodMiniType<
  BillingAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => BillingAttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => BillingAttachRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function billingAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachResponse' from JSON`,
  );
}
