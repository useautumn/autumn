/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type BillingAttachGlobals = {
  xApiVersion?: string | undefined;
};

/**
 * Quantity configuration for a prepaid feature.
 */
export type BillingAttachFeatureQuantity = {
  /**
   * The ID of the feature to set quantity for.
   */
  featureId: string;
  /**
   * The quantity of the feature.
   */
  quantity?: number | undefined;
  /**
   * Whether the customer can adjust the quantity.
   */
  adjustable?: boolean | undefined;
};

/**
 * Billing interval (e.g. 'month', 'year').
 */
export const BillingAttachPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval (e.g. 'month', 'year').
 */
export type BillingAttachPriceInterval = ClosedEnum<
  typeof BillingAttachPriceInterval
>;

/**
 * Base price configuration for a plan.
 */
export type BillingAttachBasePrice = {
  /**
   * Base price amount for the plan.
   */
  amount: number;
  /**
   * Billing interval (e.g. 'month', 'year').
   */
  interval: BillingAttachPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export const BillingAttachResetInterval = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
 */
export type BillingAttachResetInterval = ClosedEnum<
  typeof BillingAttachResetInterval
>;

/**
 * Reset configuration for consumable features. Omit for non-consumable features like seats.
 */
export type BillingAttachReset = {
  /**
   * Interval at which balance resets (e.g. 'month', 'year'). For consumable features only.
   */
  interval: BillingAttachResetInterval;
  /**
   * Number of intervals between resets. Defaults to 1.
   */
  intervalCount?: number | undefined;
};

export type BillingAttachTo = number | string;

export type BillingAttachTier = {
  to: number | string;
  amount: number;
};

/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export const BillingAttachItemPriceInterval = {
  OneOff: "one_off",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
/**
 * Billing interval. For consumable features, should match reset.interval.
 */
export type BillingAttachItemPriceInterval = ClosedEnum<
  typeof BillingAttachItemPriceInterval
>;

/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export const BillingAttachBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
 */
export type BillingAttachBillingMethod = ClosedEnum<
  typeof BillingAttachBillingMethod
>;

/**
 * Pricing for usage beyond included units. Omit for free features.
 */
export type BillingAttachPrice = {
  /**
   * Price per billing_units after included usage. Either 'amount' or 'tiers' is required.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing. Each tier's 'to' does NOT include included amount. Either 'amount' or 'tiers' is required.
   */
  tiers?: Array<BillingAttachTier> | undefined;
  /**
   * Billing interval. For consumable features, should match reset.interval.
   */
  interval: BillingAttachItemPriceInterval;
  /**
   * Number of intervals per billing cycle. Defaults to 1.
   */
  intervalCount?: number | undefined;
  /**
   * Units per price increment. Usage is rounded UP when billed (e.g. billing_units=100 means 101 rounds to 200).
   */
  billingUnits?: number | undefined;
  /**
   * 'prepaid' for upfront payment (seats), 'usage_based' for pay-as-you-go.
   */
  billingMethod: BillingAttachBillingMethod;
  /**
   * Max units purchasable beyond included. E.g. included=100, max_purchase=300 allows 400 total.
   */
  maxPurchase?: number | undefined;
};

/**
 * Billing behavior when quantity increases mid-cycle.
 */
export const BillingAttachOnIncrease = {
  BillImmediately: "bill_immediately",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  BillNextCycle: "bill_next_cycle",
} as const;
/**
 * Billing behavior when quantity increases mid-cycle.
 */
export type BillingAttachOnIncrease = ClosedEnum<
  typeof BillingAttachOnIncrease
>;

/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export const BillingAttachOnDecrease = {
  Prorate: "prorate",
  ProrateImmediately: "prorate_immediately",
  ProrateNextCycle: "prorate_next_cycle",
  None: "none",
  NoProrations: "no_prorations",
} as const;
/**
 * Credit behavior when quantity decreases mid-cycle.
 */
export type BillingAttachOnDecrease = ClosedEnum<
  typeof BillingAttachOnDecrease
>;

/**
 * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
 */
export type BillingAttachProration = {
  /**
   * Billing behavior when quantity increases mid-cycle.
   */
  onIncrease: BillingAttachOnIncrease;
  /**
   * Credit behavior when quantity decreases mid-cycle.
   */
  onDecrease: BillingAttachOnDecrease;
};

/**
 * When rolled over units expire.
 */
export const BillingAttachExpiryDurationType = {
  Month: "month",
  Forever: "forever",
} as const;
/**
 * When rolled over units expire.
 */
export type BillingAttachExpiryDurationType = ClosedEnum<
  typeof BillingAttachExpiryDurationType
>;

/**
 * Rollover config for unused units. If set, unused included units carry over.
 */
export type BillingAttachRollover = {
  /**
   * Max rollover units. Omit for unlimited rollover.
   */
  max?: number | undefined;
  /**
   * When rolled over units expire.
   */
  expiryDurationType: BillingAttachExpiryDurationType;
  /**
   * Number of periods before expiry.
   */
  expiryDurationLength?: number | undefined;
};

/**
 * Configuration for a feature item in a plan, including usage limits, pricing, and rollover settings.
 */
export type BillingAttachPlanItem = {
  /**
   * The ID of the feature to configure.
   */
  featureId: string;
  /**
   * Number of free units included. Balance resets to this each interval for consumable features.
   */
  included?: number | undefined;
  /**
   * If true, customer has unlimited access to this feature.
   */
  unlimited?: boolean | undefined;
  /**
   * Reset configuration for consumable features. Omit for non-consumable features like seats.
   */
  reset?: BillingAttachReset | undefined;
  /**
   * Pricing for usage beyond included units. Omit for free features.
   */
  price?: BillingAttachPrice | undefined;
  /**
   * Proration settings for prepaid features. Controls mid-cycle quantity change billing.
   */
  proration?: BillingAttachProration | undefined;
  /**
   * Rollover config for unused units. If set, unused included units carry over.
   */
  rollover?: BillingAttachRollover | undefined;
};

/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export const BillingAttachDurationType = {
  Day: "day",
  Month: "month",
  Year: "year",
} as const;
/**
 * Unit of time for the trial ('day', 'month', 'year').
 */
export type BillingAttachDurationType = ClosedEnum<
  typeof BillingAttachDurationType
>;

/**
 * Free trial configuration for a plan.
 */
export type BillingAttachFreeTrialParams = {
  /**
   * Number of duration_type periods the trial lasts.
   */
  durationLength: number;
  /**
   * Unit of time for the trial ('day', 'month', 'year').
   */
  durationType?: BillingAttachDurationType | undefined;
  /**
   * If true, payment method required to start trial. Customer is charged after trial ends.
   */
  cardRequired?: boolean | undefined;
};

/**
 * Customize the plan to attach. Can override the price, items, free trial, or a combination.
 */
export type BillingAttachCustomize = {
  /**
   * Override the base price of the plan. Pass null to remove the base price.
   */
  price?: BillingAttachBasePrice | null | undefined;
  /**
   * Override the items in the plan.
   */
  items?: Array<BillingAttachPlanItem> | undefined;
  /**
   * Override the plan's default free trial. Pass an object to set a custom trial, or null to remove the trial entirely.
   */
  freeTrial?: BillingAttachFreeTrialParams | null | undefined;
};

/**
 * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
 */
export type BillingAttachInvoiceMode = {
  /**
   * When true, creates an invoice and sends it to the customer instead of charging their card immediately. Uses Stripe's send_invoice collection method.
   */
  enabled: boolean;
  /**
   * If true, enables the plan immediately even though the invoice is not paid yet.
   */
  enablePlanImmediately?: boolean | undefined;
  /**
   * If true, finalizes the invoice so it can be sent to the customer. If false, keeps it as a draft for manual review.
   */
  finalize?: boolean | undefined;
};

/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export const BillingAttachProrationBehavior = {
  ProrateImmediately: "prorate_immediately",
  None: "none",
} as const;
/**
 * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
 */
export type BillingAttachProrationBehavior = ClosedEnum<
  typeof BillingAttachProrationBehavior
>;

/**
 * A discount to apply. Can be either a reward ID or a promotion code.
 */
export type BillingAttachAttachDiscount = {
  /**
   * The ID of the reward to apply as a discount.
   */
  rewardId?: string | undefined;
  /**
   * The promotion code to apply as a discount.
   */
  promotionCode?: string | undefined;
};

/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export const BillingAttachPlanSchedule = {
  Immediate: "immediate",
  EndOfCycle: "end_of_cycle",
} as const;
/**
 * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
 */
export type BillingAttachPlanSchedule = ClosedEnum<
  typeof BillingAttachPlanSchedule
>;

export type AttachParams = {
  /**
   * The ID of the customer to attach the plan to.
   */
  customerId: string;
  /**
   * The ID of the entity to attach the plan to.
   */
  entityId?: string | undefined;
  /**
   * The ID of the plan.
   */
  planId: string;
  /**
   * If this plan contains prepaid features, use this field to specify the quantity of each prepaid feature. This quantity includes the included amount and billing units defined when setting up the plan.
   */
  featureQuantities?: Array<BillingAttachFeatureQuantity> | undefined;
  /**
   * The version of the plan to attach.
   */
  version?: number | undefined;
  /**
   * Customize the plan to attach. Can override the price, items, free trial, or a combination.
   */
  customize?: BillingAttachCustomize | undefined;
  /**
   * Invoice mode creates a draft or open invoice and sends it to the customer, instead of charging their card immediately. This uses Stripe's send_invoice collection method.
   */
  invoiceMode?: BillingAttachInvoiceMode | undefined;
  /**
   * How to handle proration when updating an existing subscription. 'prorate_immediately' charges/credits prorated amounts now, 'none' skips creating any charges.
   */
  prorationBehavior?: BillingAttachProrationBehavior | undefined;
  /**
   * List of discounts to apply. Each discount can be an Autumn reward ID, Stripe coupon ID, or Stripe promotion code.
   */
  discounts?: Array<BillingAttachAttachDiscount> | undefined;
  /**
   * URL to redirect to after successful checkout.
   */
  successUrl?: string | undefined;
  /**
   * Only applicable when the customer has an existing Stripe subscription. If true, creates a new separate subscription instead of merging into the existing one.
   */
  newBillingSubscription?: boolean | undefined;
  /**
   * When the plan change should take effect. 'immediate' applies now, 'end_of_cycle' schedules for the end of the current billing cycle. By default, upgrades are immediate and downgrades are scheduled.
   */
  planSchedule?: BillingAttachPlanSchedule | undefined;
};

/**
 * Invoice details if an invoice was created. Only present when a charge was made.
 */
export type BillingAttachInvoice = {
  /**
   * The status of the invoice (e.g., 'paid', 'open', 'draft').
   */
  status: string | null;
  /**
   * The Stripe invoice ID.
   */
  stripeId: string;
  /**
   * The total amount of the invoice in cents.
   */
  total: number;
  /**
   * The three-letter ISO currency code (e.g., 'usd').
   */
  currency: string;
  /**
   * URL to the hosted invoice page where the customer can view and pay the invoice.
   */
  hostedInvoiceUrl: string | null;
};

/**
 * The type of action required to complete the payment.
 */
export const BillingAttachCode = {
  ThreedsRequired: "3ds_required",
  PaymentMethodRequired: "payment_method_required",
  PaymentFailed: "payment_failed",
} as const;
/**
 * The type of action required to complete the payment.
 */
export type BillingAttachCode = OpenEnum<typeof BillingAttachCode>;

/**
 * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
 */
export type BillingAttachRequiredAction = {
  /**
   * The type of action required to complete the payment.
   */
  code: BillingAttachCode;
  /**
   * A human-readable explanation of why this action is required.
   */
  reason: string;
};

/**
 * OK
 */
export type BillingAttachResponse = {
  /**
   * The ID of the customer.
   */
  customerId: string;
  /**
   * The ID of the entity, if the plan was attached to an entity.
   */
  entityId?: string | undefined;
  /**
   * Invoice details if an invoice was created. Only present when a charge was made.
   */
  invoice?: BillingAttachInvoice | undefined;
  /**
   * URL to redirect the customer to complete payment. Null if no payment action is required.
   */
  paymentUrl: string | null;
  /**
   * Details about any action required to complete the payment. Present when the payment could not be processed automatically.
   */
  requiredAction?: BillingAttachRequiredAction | undefined;
};

/** @internal */
export type BillingAttachFeatureQuantity$Outbound = {
  feature_id: string;
  quantity?: number | undefined;
  adjustable?: boolean | undefined;
};

/** @internal */
export const BillingAttachFeatureQuantity$outboundSchema: z.ZodMiniType<
  BillingAttachFeatureQuantity$Outbound,
  BillingAttachFeatureQuantity
> = z.pipe(
  z.object({
    featureId: z.string(),
    quantity: z.optional(z.number()),
    adjustable: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingAttachFeatureQuantityToJSON(
  billingAttachFeatureQuantity: BillingAttachFeatureQuantity,
): string {
  return JSON.stringify(
    BillingAttachFeatureQuantity$outboundSchema.parse(
      billingAttachFeatureQuantity,
    ),
  );
}

/** @internal */
export const BillingAttachPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachPriceInterval
> = z.enum(BillingAttachPriceInterval);

/** @internal */
export type BillingAttachBasePrice$Outbound = {
  amount: number;
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingAttachBasePrice$outboundSchema: z.ZodMiniType<
  BillingAttachBasePrice$Outbound,
  BillingAttachBasePrice
> = z.pipe(
  z.object({
    amount: z.number(),
    interval: BillingAttachPriceInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingAttachBasePriceToJSON(
  billingAttachBasePrice: BillingAttachBasePrice,
): string {
  return JSON.stringify(
    BillingAttachBasePrice$outboundSchema.parse(billingAttachBasePrice),
  );
}

/** @internal */
export const BillingAttachResetInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachResetInterval
> = z.enum(BillingAttachResetInterval);

/** @internal */
export type BillingAttachReset$Outbound = {
  interval: string;
  interval_count?: number | undefined;
};

/** @internal */
export const BillingAttachReset$outboundSchema: z.ZodMiniType<
  BillingAttachReset$Outbound,
  BillingAttachReset
> = z.pipe(
  z.object({
    interval: BillingAttachResetInterval$outboundSchema,
    intervalCount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
    });
  }),
);

export function billingAttachResetToJSON(
  billingAttachReset: BillingAttachReset,
): string {
  return JSON.stringify(
    BillingAttachReset$outboundSchema.parse(billingAttachReset),
  );
}

/** @internal */
export type BillingAttachTo$Outbound = number | string;

/** @internal */
export const BillingAttachTo$outboundSchema: z.ZodMiniType<
  BillingAttachTo$Outbound,
  BillingAttachTo
> = smartUnion([z.number(), z.string()]);

export function billingAttachToToJSON(
  billingAttachTo: BillingAttachTo,
): string {
  return JSON.stringify(BillingAttachTo$outboundSchema.parse(billingAttachTo));
}

/** @internal */
export type BillingAttachTier$Outbound = {
  to: number | string;
  amount: number;
};

/** @internal */
export const BillingAttachTier$outboundSchema: z.ZodMiniType<
  BillingAttachTier$Outbound,
  BillingAttachTier
> = z.object({
  to: smartUnion([z.number(), z.string()]),
  amount: z.number(),
});

export function billingAttachTierToJSON(
  billingAttachTier: BillingAttachTier,
): string {
  return JSON.stringify(
    BillingAttachTier$outboundSchema.parse(billingAttachTier),
  );
}

/** @internal */
export const BillingAttachItemPriceInterval$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachItemPriceInterval
> = z.enum(BillingAttachItemPriceInterval);

/** @internal */
export const BillingAttachBillingMethod$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachBillingMethod
> = z.enum(BillingAttachBillingMethod);

/** @internal */
export type BillingAttachPrice$Outbound = {
  amount?: number | undefined;
  tiers?: Array<BillingAttachTier$Outbound> | undefined;
  interval: string;
  interval_count: number;
  billing_units: number;
  billing_method: string;
  max_purchase?: number | undefined;
};

/** @internal */
export const BillingAttachPrice$outboundSchema: z.ZodMiniType<
  BillingAttachPrice$Outbound,
  BillingAttachPrice
> = z.pipe(
  z.object({
    amount: z.optional(z.number()),
    tiers: z.optional(z.array(z.lazy(() => BillingAttachTier$outboundSchema))),
    interval: BillingAttachItemPriceInterval$outboundSchema,
    intervalCount: z._default(z.number(), 1),
    billingUnits: z._default(z.number(), 1),
    billingMethod: BillingAttachBillingMethod$outboundSchema,
    maxPurchase: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      intervalCount: "interval_count",
      billingUnits: "billing_units",
      billingMethod: "billing_method",
      maxPurchase: "max_purchase",
    });
  }),
);

export function billingAttachPriceToJSON(
  billingAttachPrice: BillingAttachPrice,
): string {
  return JSON.stringify(
    BillingAttachPrice$outboundSchema.parse(billingAttachPrice),
  );
}

/** @internal */
export const BillingAttachOnIncrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachOnIncrease
> = z.enum(BillingAttachOnIncrease);

/** @internal */
export const BillingAttachOnDecrease$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachOnDecrease
> = z.enum(BillingAttachOnDecrease);

/** @internal */
export type BillingAttachProration$Outbound = {
  on_increase: string;
  on_decrease: string;
};

/** @internal */
export const BillingAttachProration$outboundSchema: z.ZodMiniType<
  BillingAttachProration$Outbound,
  BillingAttachProration
> = z.pipe(
  z.object({
    onIncrease: BillingAttachOnIncrease$outboundSchema,
    onDecrease: BillingAttachOnDecrease$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      onIncrease: "on_increase",
      onDecrease: "on_decrease",
    });
  }),
);

export function billingAttachProrationToJSON(
  billingAttachProration: BillingAttachProration,
): string {
  return JSON.stringify(
    BillingAttachProration$outboundSchema.parse(billingAttachProration),
  );
}

/** @internal */
export const BillingAttachExpiryDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachExpiryDurationType
> = z.enum(BillingAttachExpiryDurationType);

/** @internal */
export type BillingAttachRollover$Outbound = {
  max?: number | undefined;
  expiry_duration_type: string;
  expiry_duration_length?: number | undefined;
};

/** @internal */
export const BillingAttachRollover$outboundSchema: z.ZodMiniType<
  BillingAttachRollover$Outbound,
  BillingAttachRollover
> = z.pipe(
  z.object({
    max: z.optional(z.number()),
    expiryDurationType: BillingAttachExpiryDurationType$outboundSchema,
    expiryDurationLength: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expiryDurationType: "expiry_duration_type",
      expiryDurationLength: "expiry_duration_length",
    });
  }),
);

export function billingAttachRolloverToJSON(
  billingAttachRollover: BillingAttachRollover,
): string {
  return JSON.stringify(
    BillingAttachRollover$outboundSchema.parse(billingAttachRollover),
  );
}

/** @internal */
export type BillingAttachPlanItem$Outbound = {
  feature_id: string;
  included?: number | undefined;
  unlimited?: boolean | undefined;
  reset?: BillingAttachReset$Outbound | undefined;
  price?: BillingAttachPrice$Outbound | undefined;
  proration?: BillingAttachProration$Outbound | undefined;
  rollover?: BillingAttachRollover$Outbound | undefined;
};

/** @internal */
export const BillingAttachPlanItem$outboundSchema: z.ZodMiniType<
  BillingAttachPlanItem$Outbound,
  BillingAttachPlanItem
> = z.pipe(
  z.object({
    featureId: z.string(),
    included: z.optional(z.number()),
    unlimited: z.optional(z.boolean()),
    reset: z.optional(z.lazy(() => BillingAttachReset$outboundSchema)),
    price: z.optional(z.lazy(() => BillingAttachPrice$outboundSchema)),
    proration: z.optional(z.lazy(() => BillingAttachProration$outboundSchema)),
    rollover: z.optional(z.lazy(() => BillingAttachRollover$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
    });
  }),
);

export function billingAttachPlanItemToJSON(
  billingAttachPlanItem: BillingAttachPlanItem,
): string {
  return JSON.stringify(
    BillingAttachPlanItem$outboundSchema.parse(billingAttachPlanItem),
  );
}

/** @internal */
export const BillingAttachDurationType$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachDurationType
> = z.enum(BillingAttachDurationType);

/** @internal */
export type BillingAttachFreeTrialParams$Outbound = {
  duration_length: number;
  duration_type: string;
  card_required: boolean;
};

/** @internal */
export const BillingAttachFreeTrialParams$outboundSchema: z.ZodMiniType<
  BillingAttachFreeTrialParams$Outbound,
  BillingAttachFreeTrialParams
> = z.pipe(
  z.object({
    durationLength: z.number(),
    durationType: z._default(BillingAttachDurationType$outboundSchema, "month"),
    cardRequired: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      durationLength: "duration_length",
      durationType: "duration_type",
      cardRequired: "card_required",
    });
  }),
);

export function billingAttachFreeTrialParamsToJSON(
  billingAttachFreeTrialParams: BillingAttachFreeTrialParams,
): string {
  return JSON.stringify(
    BillingAttachFreeTrialParams$outboundSchema.parse(
      billingAttachFreeTrialParams,
    ),
  );
}

/** @internal */
export type BillingAttachCustomize$Outbound = {
  price?: BillingAttachBasePrice$Outbound | null | undefined;
  items?: Array<BillingAttachPlanItem$Outbound> | undefined;
  free_trial?: BillingAttachFreeTrialParams$Outbound | null | undefined;
};

/** @internal */
export const BillingAttachCustomize$outboundSchema: z.ZodMiniType<
  BillingAttachCustomize$Outbound,
  BillingAttachCustomize
> = z.pipe(
  z.object({
    price: z.optional(
      z.nullable(z.lazy(() => BillingAttachBasePrice$outboundSchema)),
    ),
    items: z.optional(
      z.array(z.lazy(() => BillingAttachPlanItem$outboundSchema)),
    ),
    freeTrial: z.optional(
      z.nullable(z.lazy(() => BillingAttachFreeTrialParams$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      freeTrial: "free_trial",
    });
  }),
);

export function billingAttachCustomizeToJSON(
  billingAttachCustomize: BillingAttachCustomize,
): string {
  return JSON.stringify(
    BillingAttachCustomize$outboundSchema.parse(billingAttachCustomize),
  );
}

/** @internal */
export type BillingAttachInvoiceMode$Outbound = {
  enabled: boolean;
  enable_plan_immediately: boolean;
  finalize: boolean;
};

/** @internal */
export const BillingAttachInvoiceMode$outboundSchema: z.ZodMiniType<
  BillingAttachInvoiceMode$Outbound,
  BillingAttachInvoiceMode
> = z.pipe(
  z.object({
    enabled: z.boolean(),
    enablePlanImmediately: z._default(z.boolean(), false),
    finalize: z._default(z.boolean(), true),
  }),
  z.transform((v) => {
    return remap$(v, {
      enablePlanImmediately: "enable_plan_immediately",
    });
  }),
);

export function billingAttachInvoiceModeToJSON(
  billingAttachInvoiceMode: BillingAttachInvoiceMode,
): string {
  return JSON.stringify(
    BillingAttachInvoiceMode$outboundSchema.parse(billingAttachInvoiceMode),
  );
}

/** @internal */
export const BillingAttachProrationBehavior$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachProrationBehavior
> = z.enum(BillingAttachProrationBehavior);

/** @internal */
export type BillingAttachAttachDiscount$Outbound = {
  reward_id?: string | undefined;
  promotion_code?: string | undefined;
};

/** @internal */
export const BillingAttachAttachDiscount$outboundSchema: z.ZodMiniType<
  BillingAttachAttachDiscount$Outbound,
  BillingAttachAttachDiscount
> = z.pipe(
  z.object({
    rewardId: z.optional(z.string()),
    promotionCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      rewardId: "reward_id",
      promotionCode: "promotion_code",
    });
  }),
);

export function billingAttachAttachDiscountToJSON(
  billingAttachAttachDiscount: BillingAttachAttachDiscount,
): string {
  return JSON.stringify(
    BillingAttachAttachDiscount$outboundSchema.parse(
      billingAttachAttachDiscount,
    ),
  );
}

/** @internal */
export const BillingAttachPlanSchedule$outboundSchema: z.ZodMiniEnum<
  typeof BillingAttachPlanSchedule
> = z.enum(BillingAttachPlanSchedule);

/** @internal */
export type AttachParams$Outbound = {
  customer_id: string;
  entity_id?: string | undefined;
  plan_id: string;
  feature_quantities?: Array<BillingAttachFeatureQuantity$Outbound> | undefined;
  version?: number | undefined;
  customize?: BillingAttachCustomize$Outbound | undefined;
  invoice_mode?: BillingAttachInvoiceMode$Outbound | undefined;
  proration_behavior?: string | undefined;
  discounts?: Array<BillingAttachAttachDiscount$Outbound> | undefined;
  success_url?: string | undefined;
  new_billing_subscription?: boolean | undefined;
  plan_schedule?: string | undefined;
};

/** @internal */
export const AttachParams$outboundSchema: z.ZodMiniType<
  AttachParams$Outbound,
  AttachParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    entityId: z.optional(z.string()),
    planId: z.string(),
    featureQuantities: z.optional(
      z.array(z.lazy(() => BillingAttachFeatureQuantity$outboundSchema)),
    ),
    version: z.optional(z.number()),
    customize: z.optional(z.lazy(() => BillingAttachCustomize$outboundSchema)),
    invoiceMode: z.optional(
      z.lazy(() => BillingAttachInvoiceMode$outboundSchema),
    ),
    prorationBehavior: z.optional(
      BillingAttachProrationBehavior$outboundSchema,
    ),
    discounts: z.optional(
      z.array(z.lazy(() => BillingAttachAttachDiscount$outboundSchema)),
    ),
    successUrl: z.optional(z.string()),
    newBillingSubscription: z.optional(z.boolean()),
    planSchedule: z.optional(BillingAttachPlanSchedule$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      entityId: "entity_id",
      planId: "plan_id",
      featureQuantities: "feature_quantities",
      invoiceMode: "invoice_mode",
      prorationBehavior: "proration_behavior",
      successUrl: "success_url",
      newBillingSubscription: "new_billing_subscription",
      planSchedule: "plan_schedule",
    });
  }),
);

export function attachParamsToJSON(attachParams: AttachParams): string {
  return JSON.stringify(AttachParams$outboundSchema.parse(attachParams));
}

/** @internal */
export const BillingAttachInvoice$inboundSchema: z.ZodMiniType<
  BillingAttachInvoice,
  unknown
> = z.pipe(
  z.object({
    status: types.nullable(types.string()),
    stripe_id: types.string(),
    total: types.number(),
    currency: types.string(),
    hosted_invoice_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "stripe_id": "stripeId",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function billingAttachInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachInvoice' from JSON`,
  );
}

/** @internal */
export const BillingAttachCode$inboundSchema: z.ZodMiniType<
  BillingAttachCode,
  unknown
> = openEnums.inboundSchema(BillingAttachCode);

/** @internal */
export const BillingAttachRequiredAction$inboundSchema: z.ZodMiniType<
  BillingAttachRequiredAction,
  unknown
> = z.object({
  code: BillingAttachCode$inboundSchema,
  reason: types.string(),
});

export function billingAttachRequiredActionFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachRequiredAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachRequiredAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachRequiredAction' from JSON`,
  );
}

/** @internal */
export const BillingAttachResponse$inboundSchema: z.ZodMiniType<
  BillingAttachResponse,
  unknown
> = z.pipe(
  z.object({
    customer_id: types.string(),
    entity_id: types.optional(types.string()),
    invoice: types.optional(z.lazy(() => BillingAttachInvoice$inboundSchema)),
    payment_url: types.nullable(types.string()),
    required_action: types.optional(
      z.lazy(() => BillingAttachRequiredAction$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "entity_id": "entityId",
      "payment_url": "paymentUrl",
      "required_action": "requiredAction",
    });
  }),
);

export function billingAttachResponseFromJSON(
  jsonString: string,
): SafeParseResult<BillingAttachResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingAttachResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingAttachResponse' from JSON`,
  );
}
