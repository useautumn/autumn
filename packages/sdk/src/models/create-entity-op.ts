/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import {
  CustomerData,
  CustomerData$Outbound,
  CustomerData$outboundSchema,
} from "./customer-data.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type CreateEntityGlobals = {
  xApiVersion?: string | undefined;
};

export type CreateEntityParams = {
  /**
   * The name of the entity
   */
  name?: string | null | undefined;
  /**
   * The ID of the feature this entity is associated with
   */
  featureId: string;
  /**
   * Customer details to set when creating a customer
   */
  customerData?: CustomerData | undefined;
  /**
   * The ID of the customer to create the entity for.
   */
  customerId: string;
  /**
   * The ID of the entity.
   */
  entityId: string;
};

/**
 * The environment (sandbox/live)
 */
export const CreateEntityEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment (sandbox/live)
 */
export type CreateEntityEnv = OpenEnum<typeof CreateEntityEnv>;

/**
 * Current status of the subscription.
 */
export const CreateEntityStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Current status of the subscription.
 */
export type CreateEntityStatus = OpenEnum<typeof CreateEntityStatus>;

export type CreateEntitySubscription = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the subscribed plan.
   */
  planId: string;
  /**
   * Whether the plan was automatically enabled for the customer.
   */
  autoEnable: boolean;
  /**
   * Whether this is an add-on plan rather than a base subscription.
   */
  addOn: boolean;
  /**
   * Current status of the subscription.
   */
  status: CreateEntityStatus;
  /**
   * Whether the subscription has overdue payments.
   */
  pastDue: boolean;
  /**
   * Timestamp when the subscription was canceled, or null if not canceled.
   */
  canceledAt: number | null;
  /**
   * Timestamp when the subscription will expire, or null if no expiry set.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the trial period ends, or null if not on trial.
   */
  trialEndsAt: number | null;
  /**
   * Timestamp when the subscription started.
   */
  startedAt: number;
  /**
   * Start timestamp of the current billing period.
   */
  currentPeriodStart: number | null;
  /**
   * End timestamp of the current billing period.
   */
  currentPeriodEnd: number | null;
  /**
   * Number of units of this subscription (for per-seat plans).
   */
  quantity: number;
};

export type CreateEntityPurchase = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the purchased plan.
   */
  planId: string;
  /**
   * Timestamp when the purchase expires, or null for lifetime access.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the purchase was made.
   */
  startedAt: number;
  /**
   * Number of units purchased.
   */
  quantity: number;
};

export const CreateEntityType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type CreateEntityType = OpenEnum<typeof CreateEntityType>;

export type CreateEntityCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type CreateEntityDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

/**
 * The full feature object if expanded.
 */
export type CreateEntityFeature = {
  id: string;
  name: string;
  type: CreateEntityType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<CreateEntityCreditSchema> | undefined;
  display?: CreateEntityDisplay | undefined;
  archived: boolean;
};

export const CreateEntityIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type CreateEntityIntervalEnum = OpenEnum<
  typeof CreateEntityIntervalEnum
>;

/**
 * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
 */
export type CreateEntityIntervalUnion = CreateEntityIntervalEnum | string;

export type CreateEntityReset = {
  /**
   * The reset interval (hour, day, week, month, etc.) or 'multiple' if combined from different intervals.
   */
  interval: CreateEntityIntervalEnum | string;
  /**
   * Number of intervals between resets (eg. 2 for bi-monthly).
   */
  intervalCount?: number | undefined;
  /**
   * Timestamp when the balance will next reset.
   */
  resetsAt: number | null;
};

export type CreateEntityTo = number | string;

export type CreateEntityTier = {
  to: number | string;
  amount: number;
};

/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export const CreateEntityBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
/**
 * Whether usage is prepaid or billed pay-per-use.
 */
export type CreateEntityBillingMethod = OpenEnum<
  typeof CreateEntityBillingMethod
>;

export type CreateEntityPrice = {
  /**
   * The per-unit price amount.
   */
  amount?: number | undefined;
  /**
   * Tiered pricing configuration if applicable.
   */
  tiers?: Array<CreateEntityTier> | undefined;
  /**
   * The number of units per billing increment (eg. $9 / 250 units).
   */
  billingUnits: number;
  /**
   * Whether usage is prepaid or billed pay-per-use.
   */
  billingMethod: CreateEntityBillingMethod;
  /**
   * Maximum quantity that can be purchased, or null for unlimited.
   */
  maxPurchase: number | null;
};

export type CreateEntityBreakdown = {
  /**
   * The unique identifier for this balance breakdown.
   */
  id: string;
  /**
   * The plan ID this balance originates from, or null for standalone balances.
   */
  planId: string | null;
  /**
   * Amount granted from the plan's included usage.
   */
  includedGrant: number;
  /**
   * Amount granted from prepaid purchases or top-ups.
   */
  prepaidGrant: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Amount consumed in the current period.
   */
  usage: number;
  /**
   * Whether this balance has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Reset configuration for this balance, or null if no reset.
   */
  reset: CreateEntityReset | null;
  /**
   * Pricing configuration if this balance has usage-based pricing.
   */
  price: CreateEntityPrice | null;
  /**
   * Timestamp when this balance expires, or null for no expiration.
   */
  expiresAt: number | null;
};

export type CreateEntityRollover = {
  /**
   * Amount of balance rolled over from a previous period.
   */
  balance: number;
  /**
   * Timestamp when the rollover balance expires.
   */
  expiresAt: number;
};

export type CreateEntityBalances = {
  /**
   * The feature ID this balance is for.
   */
  featureId: string;
  /**
   * The full feature object if expanded.
   */
  feature?: CreateEntityFeature | undefined;
  /**
   * Total balance granted (included + prepaid).
   */
  granted: number;
  /**
   * Remaining balance available for use.
   */
  remaining: number;
  /**
   * Total usage consumed in the current period.
   */
  usage: number;
  /**
   * Whether this feature has unlimited usage.
   */
  unlimited: boolean;
  /**
   * Whether usage beyond the granted balance is allowed (with overage charges).
   */
  overageAllowed: boolean;
  /**
   * Maximum quantity that can be purchased as a top-up, or null for unlimited.
   */
  maxPurchase: number | null;
  /**
   * Timestamp when the balance will reset, or null for no reset.
   */
  nextResetAt: number | null;
  /**
   * Detailed breakdown of balance sources when stacking multiple plans or grants.
   */
  breakdown?: Array<CreateEntityBreakdown> | undefined;
  /**
   * Rollover balances carried over from previous periods.
   */
  rollovers?: Array<CreateEntityRollover> | undefined;
};

export type CreateEntityInvoice = {
  /**
   * Array of plan IDs included in this invoice
   */
  planIds: Array<string>;
  /**
   * The Stripe invoice ID
   */
  stripeId: string;
  /**
   * The status of the invoice
   */
  status: string;
  /**
   * The total amount of the invoice
   */
  total: number;
  /**
   * The currency code for the invoice
   */
  currency: string;
  /**
   * Timestamp when the invoice was created
   */
  createdAt: number;
  /**
   * URL to the Stripe-hosted invoice page
   */
  hostedInvoiceUrl?: string | null | undefined;
};

/**
 * OK
 */
export type CreateEntityResponse = {
  autumnId?: string | undefined;
  /**
   * The unique identifier of the entity
   */
  id: string | null;
  /**
   * The name of the entity
   */
  name: string | null;
  /**
   * The customer ID this entity belongs to
   */
  customerId?: string | null | undefined;
  /**
   * The feature ID this entity belongs to
   */
  featureId?: string | null | undefined;
  /**
   * Unix timestamp when the entity was created
   */
  createdAt: number;
  /**
   * The environment (sandbox/live)
   */
  env: CreateEntityEnv;
  subscriptions: Array<CreateEntitySubscription>;
  purchases: Array<CreateEntityPurchase>;
  balances: { [k: string]: CreateEntityBalances };
  /**
   * Invoices for this entity (only included when expand=invoices)
   */
  invoices?: Array<CreateEntityInvoice> | undefined;
};

/** @internal */
export type CreateEntityParams$Outbound = {
  name?: string | null | undefined;
  feature_id: string;
  customer_data?: CustomerData$Outbound | undefined;
  customer_id: string;
  entity_id: string;
};

/** @internal */
export const CreateEntityParams$outboundSchema: z.ZodMiniType<
  CreateEntityParams$Outbound,
  CreateEntityParams
> = z.pipe(
  z.object({
    name: z.optional(z.nullable(z.string())),
    featureId: z.string(),
    customerData: z.optional(CustomerData$outboundSchema),
    customerId: z.string(),
    entityId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      featureId: "feature_id",
      customerData: "customer_data",
      customerId: "customer_id",
      entityId: "entity_id",
    });
  }),
);

export function createEntityParamsToJSON(
  createEntityParams: CreateEntityParams,
): string {
  return JSON.stringify(
    CreateEntityParams$outboundSchema.parse(createEntityParams),
  );
}

/** @internal */
export const CreateEntityEnv$inboundSchema: z.ZodMiniType<
  CreateEntityEnv,
  unknown
> = openEnums.inboundSchema(CreateEntityEnv);

/** @internal */
export const CreateEntityStatus$inboundSchema: z.ZodMiniType<
  CreateEntityStatus,
  unknown
> = openEnums.inboundSchema(CreateEntityStatus);

/** @internal */
export const CreateEntitySubscription$inboundSchema: z.ZodMiniType<
  CreateEntitySubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: CreateEntityStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function createEntitySubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntitySubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntitySubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntitySubscription' from JSON`,
  );
}

/** @internal */
export const CreateEntityPurchase$inboundSchema: z.ZodMiniType<
  CreateEntityPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function createEntityPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityPurchase' from JSON`,
  );
}

/** @internal */
export const CreateEntityType$inboundSchema: z.ZodMiniType<
  CreateEntityType,
  unknown
> = openEnums.inboundSchema(CreateEntityType);

/** @internal */
export const CreateEntityCreditSchema$inboundSchema: z.ZodMiniType<
  CreateEntityCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function createEntityCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityCreditSchema' from JSON`,
  );
}

/** @internal */
export const CreateEntityDisplay$inboundSchema: z.ZodMiniType<
  CreateEntityDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function createEntityDisplayFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityDisplay' from JSON`,
  );
}

/** @internal */
export const CreateEntityFeature$inboundSchema: z.ZodMiniType<
  CreateEntityFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: CreateEntityType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => CreateEntityCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => CreateEntityDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function createEntityFeatureFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityFeature' from JSON`,
  );
}

/** @internal */
export const CreateEntityIntervalEnum$inboundSchema: z.ZodMiniType<
  CreateEntityIntervalEnum,
  unknown
> = openEnums.inboundSchema(CreateEntityIntervalEnum);

/** @internal */
export const CreateEntityIntervalUnion$inboundSchema: z.ZodMiniType<
  CreateEntityIntervalUnion,
  unknown
> = smartUnion([CreateEntityIntervalEnum$inboundSchema, types.string()]);

export function createEntityIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityIntervalUnion' from JSON`,
  );
}

/** @internal */
export const CreateEntityReset$inboundSchema: z.ZodMiniType<
  CreateEntityReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      CreateEntityIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function createEntityResetFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityReset' from JSON`,
  );
}

/** @internal */
export const CreateEntityTo$inboundSchema: z.ZodMiniType<
  CreateEntityTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function createEntityToFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityTo' from JSON`,
  );
}

/** @internal */
export const CreateEntityTier$inboundSchema: z.ZodMiniType<
  CreateEntityTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function createEntityTierFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityTier' from JSON`,
  );
}

/** @internal */
export const CreateEntityBillingMethod$inboundSchema: z.ZodMiniType<
  CreateEntityBillingMethod,
  unknown
> = openEnums.inboundSchema(CreateEntityBillingMethod);

/** @internal */
export const CreateEntityPrice$inboundSchema: z.ZodMiniType<
  CreateEntityPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => CreateEntityTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: CreateEntityBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function createEntityPriceFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityPrice' from JSON`,
  );
}

/** @internal */
export const CreateEntityBreakdown$inboundSchema: z.ZodMiniType<
  CreateEntityBreakdown,
  unknown
> = z.pipe(
  z.object({
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => CreateEntityReset$inboundSchema)),
    price: types.nullable(z.lazy(() => CreateEntityPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function createEntityBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityBreakdown' from JSON`,
  );
}

/** @internal */
export const CreateEntityRollover$inboundSchema: z.ZodMiniType<
  CreateEntityRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function createEntityRolloverFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityRollover' from JSON`,
  );
}

/** @internal */
export const CreateEntityBalances$inboundSchema: z.ZodMiniType<
  CreateEntityBalances,
  unknown
> = z.pipe(
  z.object({
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => CreateEntityFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => CreateEntityBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => CreateEntityRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function createEntityBalancesFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityBalances' from JSON`,
  );
}

/** @internal */
export const CreateEntityInvoice$inboundSchema: z.ZodMiniType<
  CreateEntityInvoice,
  unknown
> = z.pipe(
  z.object({
    plan_ids: z.array(types.string()),
    stripe_id: types.string(),
    status: types.string(),
    total: types.number(),
    currency: types.string(),
    created_at: types.number(),
    hosted_invoice_url: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_ids": "planIds",
      "stripe_id": "stripeId",
      "created_at": "createdAt",
      "hosted_invoice_url": "hostedInvoiceUrl",
    });
  }),
);

export function createEntityInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityInvoice' from JSON`,
  );
}

/** @internal */
export const CreateEntityResponse$inboundSchema: z.ZodMiniType<
  CreateEntityResponse,
  unknown
> = z.pipe(
  z.object({
    autumn_id: types.optional(types.string()),
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    customer_id: z.optional(z.nullable(types.string())),
    feature_id: z.optional(z.nullable(types.string())),
    created_at: types.number(),
    env: CreateEntityEnv$inboundSchema,
    subscriptions: z.array(
      z.lazy(() => CreateEntitySubscription$inboundSchema),
    ),
    purchases: z.array(z.lazy(() => CreateEntityPurchase$inboundSchema)),
    balances: z.record(
      z.string(),
      z.lazy(() => CreateEntityBalances$inboundSchema),
    ),
    invoices: types.optional(
      z.array(z.lazy(() => CreateEntityInvoice$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "autumn_id": "autumnId",
      "customer_id": "customerId",
      "feature_id": "featureId",
      "created_at": "createdAt",
    });
  }),
);

export function createEntityResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateEntityResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEntityResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEntityResponse' from JSON`,
  );
}
