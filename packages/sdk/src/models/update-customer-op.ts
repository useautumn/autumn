/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type UpdateCustomerGlobals = {
  xApiVersion?: string | undefined;
};

export type UpdateCustomerParams = {
  /**
   * ID of the customer to update
   */
  customerId: string;
  /**
   * Customer's name
   */
  name?: string | null | undefined;
  /**
   * Customer's email address
   */
  email?: string | null | undefined;
  /**
   * Unique identifier (eg, serial number) to detect duplicate customers and prevent free trial abuse
   */
  fingerprint?: string | null | undefined;
  /**
   * Additional metadata for the customer
   */
  metadata?: { [k: string]: any } | null | undefined;
  /**
   * Stripe customer ID if you already have one
   */
  stripeId?: string | null | undefined;
  /**
   * Whether to send email receipts to this customer
   */
  sendEmailReceipts?: boolean | undefined;
  /**
   * Your unique identifier for the customer
   */
  newCustomerId?: string | undefined;
};

/**
 * The environment this customer was created in.
 */
export const UpdateCustomerEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment this customer was created in.
 */
export type UpdateCustomerEnv = OpenEnum<typeof UpdateCustomerEnv>;

export const UpdateCustomerStatus = {
  Active: "active",
  Scheduled: "scheduled",
  Expired: "expired",
} as const;
export type UpdateCustomerStatus = OpenEnum<typeof UpdateCustomerStatus>;

export type UpdateCustomerSubscription = {
  plan?: Plan | undefined;
  planId: string;
  autoEnable: boolean;
  addOn: boolean;
  status: UpdateCustomerStatus;
  pastDue: boolean;
  canceledAt: number | null;
  expiresAt: number | null;
  trialEndsAt: number | null;
  startedAt: number;
  currentPeriodStart: number | null;
  currentPeriodEnd: number | null;
  quantity: number;
};

export type UpdateCustomerPurchase = {
  plan?: Plan | undefined;
  planId: string;
  expiresAt: number | null;
  startedAt: number;
  quantity: number;
};

export const UpdateCustomerType = {
  Boolean: "boolean",
  Metered: "metered",
  CreditSystem: "credit_system",
} as const;
export type UpdateCustomerType = OpenEnum<typeof UpdateCustomerType>;

export type UpdateCustomerCreditSchema = {
  meteredFeatureId: string;
  creditCost: number;
};

export type UpdateCustomerDisplay = {
  singular?: string | null | undefined;
  plural?: string | null | undefined;
};

export type UpdateCustomerFeature = {
  id: string;
  name: string;
  type: UpdateCustomerType;
  consumable: boolean;
  eventNames?: Array<string> | undefined;
  creditSchema?: Array<UpdateCustomerCreditSchema> | undefined;
  display?: UpdateCustomerDisplay | undefined;
  archived: boolean;
};

export const UpdateCustomerIntervalEnum = {
  OneOff: "one_off",
  Minute: "minute",
  Hour: "hour",
  Day: "day",
  Week: "week",
  Month: "month",
  Quarter: "quarter",
  SemiAnnual: "semi_annual",
  Year: "year",
} as const;
export type UpdateCustomerIntervalEnum = OpenEnum<
  typeof UpdateCustomerIntervalEnum
>;

export type UpdateCustomerIntervalUnion = UpdateCustomerIntervalEnum | string;

export type UpdateCustomerReset = {
  interval: UpdateCustomerIntervalEnum | string;
  intervalCount?: number | undefined;
  resetsAt: number | null;
};

export type UpdateCustomerTo = number | string;

export type UpdateCustomerTier = {
  to: number | string;
  amount: number;
};

export const UpdateCustomerBillingMethod = {
  Prepaid: "prepaid",
  UsageBased: "usage_based",
} as const;
export type UpdateCustomerBillingMethod = OpenEnum<
  typeof UpdateCustomerBillingMethod
>;

export type UpdateCustomerPrice = {
  amount?: number | undefined;
  tiers?: Array<UpdateCustomerTier> | undefined;
  billingUnits: number;
  billingMethod: UpdateCustomerBillingMethod;
  maxPurchase: number | null;
};

export type UpdateCustomerBreakdown = {
  object: "balance_breakdown";
  id: string;
  planId: string | null;
  includedGrant: number;
  prepaidGrant: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  reset: UpdateCustomerReset | null;
  price: UpdateCustomerPrice | null;
  expiresAt: number | null;
};

export type UpdateCustomerRollover = {
  balance: number;
  expiresAt: number;
};

export type UpdateCustomerBalances = {
  object: "balance";
  featureId: string;
  feature?: UpdateCustomerFeature | undefined;
  granted: number;
  remaining: number;
  usage: number;
  unlimited: boolean;
  overageAllowed: boolean;
  maxPurchase: number | null;
  nextResetAt: number | null;
  breakdown?: Array<UpdateCustomerBreakdown> | undefined;
  rollovers?: Array<UpdateCustomerRollover> | undefined;
};

/**
 * OK
 */
export type UpdateCustomerResponse = {
  /**
   * Your unique identifier for the customer.
   */
  id: string | null;
  /**
   * The name of the customer.
   */
  name: string | null;
  /**
   * The email address of the customer.
   */
  email: string | null;
  /**
   * Timestamp of customer creation in milliseconds since epoch.
   */
  createdAt: number;
  /**
   * A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID.
   */
  fingerprint: string | null;
  /**
   * Stripe customer ID.
   */
  stripeId: string | null;
  /**
   * The environment this customer was created in.
   */
  env: UpdateCustomerEnv;
  /**
   * The metadata for the customer.
   */
  metadata: { [k: string]: any };
  /**
   * Whether to send email receipts to the customer.
   */
  sendEmailReceipts: boolean;
  subscriptions: Array<UpdateCustomerSubscription>;
  purchases: Array<UpdateCustomerPurchase>;
  balances: { [k: string]: UpdateCustomerBalances };
};

/** @internal */
export type UpdateCustomerParams$Outbound = {
  customer_id: string;
  name?: string | null | undefined;
  email?: string | null | undefined;
  fingerprint?: string | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  stripe_id?: string | null | undefined;
  send_email_receipts?: boolean | undefined;
  new_customer_id?: string | undefined;
};

/** @internal */
export const UpdateCustomerParams$outboundSchema: z.ZodMiniType<
  UpdateCustomerParams$Outbound,
  UpdateCustomerParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    name: z.optional(z.nullable(z.string())),
    email: z.optional(z.nullable(z.string())),
    fingerprint: z.optional(z.nullable(z.string())),
    metadata: z.optional(z.nullable(z.record(z.string(), z.any()))),
    stripeId: z.optional(z.nullable(z.string())),
    sendEmailReceipts: z.optional(z.boolean()),
    newCustomerId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      stripeId: "stripe_id",
      sendEmailReceipts: "send_email_receipts",
      newCustomerId: "new_customer_id",
    });
  }),
);

export function updateCustomerParamsToJSON(
  updateCustomerParams: UpdateCustomerParams,
): string {
  return JSON.stringify(
    UpdateCustomerParams$outboundSchema.parse(updateCustomerParams),
  );
}

/** @internal */
export const UpdateCustomerEnv$inboundSchema: z.ZodMiniType<
  UpdateCustomerEnv,
  unknown
> = openEnums.inboundSchema(UpdateCustomerEnv);

/** @internal */
export const UpdateCustomerStatus$inboundSchema: z.ZodMiniType<
  UpdateCustomerStatus,
  unknown
> = openEnums.inboundSchema(UpdateCustomerStatus);

/** @internal */
export const UpdateCustomerSubscription$inboundSchema: z.ZodMiniType<
  UpdateCustomerSubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: UpdateCustomerStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function updateCustomerSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerSubscription' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerPurchase$inboundSchema: z.ZodMiniType<
  UpdateCustomerPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function updateCustomerPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerPurchase' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerType$inboundSchema: z.ZodMiniType<
  UpdateCustomerType,
  unknown
> = openEnums.inboundSchema(UpdateCustomerType);

/** @internal */
export const UpdateCustomerCreditSchema$inboundSchema: z.ZodMiniType<
  UpdateCustomerCreditSchema,
  unknown
> = z.pipe(
  z.object({
    metered_feature_id: types.string(),
    credit_cost: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "metered_feature_id": "meteredFeatureId",
      "credit_cost": "creditCost",
    });
  }),
);

export function updateCustomerCreditSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerCreditSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerCreditSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerCreditSchema' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerDisplay$inboundSchema: z.ZodMiniType<
  UpdateCustomerDisplay,
  unknown
> = z.object({
  singular: z.optional(z.nullable(types.string())),
  plural: z.optional(z.nullable(types.string())),
});

export function updateCustomerDisplayFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerDisplay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerDisplay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerDisplay' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerFeature$inboundSchema: z.ZodMiniType<
  UpdateCustomerFeature,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    type: UpdateCustomerType$inboundSchema,
    consumable: types.boolean(),
    event_names: types.optional(z.array(types.string())),
    credit_schema: types.optional(
      z.array(z.lazy(() => UpdateCustomerCreditSchema$inboundSchema)),
    ),
    display: types.optional(z.lazy(() => UpdateCustomerDisplay$inboundSchema)),
    archived: types.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_names": "eventNames",
      "credit_schema": "creditSchema",
    });
  }),
);

export function updateCustomerFeatureFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerFeature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerFeature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerFeature' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerIntervalEnum$inboundSchema: z.ZodMiniType<
  UpdateCustomerIntervalEnum,
  unknown
> = openEnums.inboundSchema(UpdateCustomerIntervalEnum);

/** @internal */
export const UpdateCustomerIntervalUnion$inboundSchema: z.ZodMiniType<
  UpdateCustomerIntervalUnion,
  unknown
> = smartUnion([UpdateCustomerIntervalEnum$inboundSchema, types.string()]);

export function updateCustomerIntervalUnionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerIntervalUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerIntervalUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerIntervalUnion' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerReset$inboundSchema: z.ZodMiniType<
  UpdateCustomerReset,
  unknown
> = z.pipe(
  z.object({
    interval: smartUnion([
      UpdateCustomerIntervalEnum$inboundSchema,
      types.string(),
    ]),
    interval_count: types.optional(types.number()),
    resets_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "interval_count": "intervalCount",
      "resets_at": "resetsAt",
    });
  }),
);

export function updateCustomerResetFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerReset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerReset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerReset' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerTo$inboundSchema: z.ZodMiniType<
  UpdateCustomerTo,
  unknown
> = smartUnion([types.number(), types.string()]);

export function updateCustomerToFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerTo' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerTier$inboundSchema: z.ZodMiniType<
  UpdateCustomerTier,
  unknown
> = z.object({
  to: smartUnion([types.number(), types.string()]),
  amount: types.number(),
});

export function updateCustomerTierFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerTier' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerBillingMethod$inboundSchema: z.ZodMiniType<
  UpdateCustomerBillingMethod,
  unknown
> = openEnums.inboundSchema(UpdateCustomerBillingMethod);

/** @internal */
export const UpdateCustomerPrice$inboundSchema: z.ZodMiniType<
  UpdateCustomerPrice,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    tiers: types.optional(
      z.array(z.lazy(() => UpdateCustomerTier$inboundSchema)),
    ),
    billing_units: types.number(),
    billing_method: UpdateCustomerBillingMethod$inboundSchema,
    max_purchase: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billing_units": "billingUnits",
      "billing_method": "billingMethod",
      "max_purchase": "maxPurchase",
    });
  }),
);

export function updateCustomerPriceFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerPrice' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerBreakdown$inboundSchema: z.ZodMiniType<
  UpdateCustomerBreakdown,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance_breakdown"),
    id: z._default(types.string(), ""),
    plan_id: types.nullable(types.string()),
    included_grant: types.number(),
    prepaid_grant: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    reset: types.nullable(z.lazy(() => UpdateCustomerReset$inboundSchema)),
    price: types.nullable(z.lazy(() => UpdateCustomerPrice$inboundSchema)),
    expires_at: types.nullable(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "included_grant": "includedGrant",
      "prepaid_grant": "prepaidGrant",
      "expires_at": "expiresAt",
    });
  }),
);

export function updateCustomerBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerBreakdown' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerRollover$inboundSchema: z.ZodMiniType<
  UpdateCustomerRollover,
  unknown
> = z.pipe(
  z.object({
    balance: types.number(),
    expires_at: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  }),
);

export function updateCustomerRolloverFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerRollover, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerRollover$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerRollover' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerBalances$inboundSchema: z.ZodMiniType<
  UpdateCustomerBalances,
  unknown
> = z.pipe(
  z.object({
    object: types.literal("balance"),
    feature_id: types.string(),
    feature: types.optional(z.lazy(() => UpdateCustomerFeature$inboundSchema)),
    granted: types.number(),
    remaining: types.number(),
    usage: types.number(),
    unlimited: types.boolean(),
    overage_allowed: types.boolean(),
    max_purchase: types.nullable(types.number()),
    next_reset_at: types.nullable(types.number()),
    breakdown: types.optional(
      z.array(z.lazy(() => UpdateCustomerBreakdown$inboundSchema)),
    ),
    rollovers: types.optional(
      z.array(z.lazy(() => UpdateCustomerRollover$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "feature_id": "featureId",
      "overage_allowed": "overageAllowed",
      "max_purchase": "maxPurchase",
      "next_reset_at": "nextResetAt",
    });
  }),
);

export function updateCustomerBalancesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerBalances' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerResponse$inboundSchema: z.ZodMiniType<
  UpdateCustomerResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    email: types.nullable(types.string()),
    created_at: types.number(),
    fingerprint: types.nullable(types.string()),
    stripe_id: types.nullable(types.string()),
    env: UpdateCustomerEnv$inboundSchema,
    metadata: z.record(z.string(), z.any()),
    send_email_receipts: types.boolean(),
    subscriptions: z.array(
      z.lazy(() => UpdateCustomerSubscription$inboundSchema),
    ),
    purchases: z.array(z.lazy(() => UpdateCustomerPurchase$inboundSchema)),
    balances: z.record(
      z.string(),
      z.lazy(() => UpdateCustomerBalances$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "stripe_id": "stripeId",
      "send_email_receipts": "sendEmailReceipts",
    });
  }),
);

export function updateCustomerResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerResponse' from JSON`,
  );
}
