/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { Balance, Balance$inboundSchema } from "./balance.js";
import { Plan, Plan$inboundSchema } from "./plan.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type UpdateCustomerGlobals = {
  xApiVersion?: string | undefined;
};

export type UpdateCustomerParams = {
  /**
   * ID of the customer to update
   */
  customerId: string;
  /**
   * Customer's name
   */
  name?: string | null | undefined;
  /**
   * Customer's email address
   */
  email?: string | null | undefined;
  /**
   * Unique identifier (eg, serial number) to detect duplicate customers and prevent free trial abuse
   */
  fingerprint?: string | null | undefined;
  /**
   * Additional metadata for the customer
   */
  metadata?: { [k: string]: any } | null | undefined;
  /**
   * Stripe customer ID if you already have one
   */
  stripeId?: string | null | undefined;
  /**
   * Whether to send email receipts to this customer
   */
  sendEmailReceipts?: boolean | undefined;
  /**
   * Your unique identifier for the customer
   */
  newCustomerId?: string | undefined;
};

/**
 * The environment this customer was created in.
 */
export const UpdateCustomerEnv = {
  Sandbox: "sandbox",
  Live: "live",
} as const;
/**
 * The environment this customer was created in.
 */
export type UpdateCustomerEnv = OpenEnum<typeof UpdateCustomerEnv>;

/**
 * Current status of the subscription.
 */
export const UpdateCustomerStatus = {
  Active: "active",
  Scheduled: "scheduled",
} as const;
/**
 * Current status of the subscription.
 */
export type UpdateCustomerStatus = OpenEnum<typeof UpdateCustomerStatus>;

export type UpdateCustomerSubscription = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the subscribed plan.
   */
  planId: string;
  /**
   * Whether the plan was automatically enabled for the customer.
   */
  autoEnable: boolean;
  /**
   * Whether this is an add-on plan rather than a base subscription.
   */
  addOn: boolean;
  /**
   * Current status of the subscription.
   */
  status: UpdateCustomerStatus;
  /**
   * Whether the subscription has overdue payments.
   */
  pastDue: boolean;
  /**
   * Timestamp when the subscription was canceled, or null if not canceled.
   */
  canceledAt: number | null;
  /**
   * Timestamp when the subscription will expire, or null if no expiry set.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the trial period ends, or null if not on trial.
   */
  trialEndsAt: number | null;
  /**
   * Timestamp when the subscription started.
   */
  startedAt: number;
  /**
   * Start timestamp of the current billing period.
   */
  currentPeriodStart: number | null;
  /**
   * End timestamp of the current billing period.
   */
  currentPeriodEnd: number | null;
  /**
   * Number of units of this subscription (for per-seat plans).
   */
  quantity: number;
};

export type UpdateCustomerPurchase = {
  plan?: Plan | undefined;
  /**
   * The unique identifier of the purchased plan.
   */
  planId: string;
  /**
   * Timestamp when the purchase expires, or null for lifetime access.
   */
  expiresAt: number | null;
  /**
   * Timestamp when the purchase was made.
   */
  startedAt: number;
  /**
   * Number of units purchased.
   */
  quantity: number;
};

/**
 * OK
 */
export type UpdateCustomerResponse = {
  /**
   * Your unique identifier for the customer.
   */
  id: string | null;
  /**
   * The name of the customer.
   */
  name: string | null;
  /**
   * The email address of the customer.
   */
  email: string | null;
  /**
   * Timestamp of customer creation in milliseconds since epoch.
   */
  createdAt: number;
  /**
   * A unique identifier (eg. serial number) to de-duplicate customers across devices or browsers. For example: apple device ID.
   */
  fingerprint: string | null;
  /**
   * Stripe customer ID.
   */
  stripeId: string | null;
  /**
   * The environment this customer was created in.
   */
  env: UpdateCustomerEnv;
  /**
   * The metadata for the customer.
   */
  metadata: { [k: string]: any };
  /**
   * Whether to send email receipts to the customer.
   */
  sendEmailReceipts: boolean;
  /**
   * Active and scheduled recurring plans that this customer has attached.
   */
  subscriptions: Array<UpdateCustomerSubscription>;
  /**
   * One-time purchases made by the customer.
   */
  purchases: Array<UpdateCustomerPurchase>;
  /**
   * Feature balances keyed by feature ID, showing usage limits and remaining amounts.
   */
  balances: { [k: string]: Balance };
};

/** @internal */
export type UpdateCustomerParams$Outbound = {
  customer_id: string;
  name?: string | null | undefined;
  email?: string | null | undefined;
  fingerprint?: string | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  stripe_id?: string | null | undefined;
  send_email_receipts?: boolean | undefined;
  new_customer_id?: string | undefined;
};

/** @internal */
export const UpdateCustomerParams$outboundSchema: z.ZodMiniType<
  UpdateCustomerParams$Outbound,
  UpdateCustomerParams
> = z.pipe(
  z.object({
    customerId: z.string(),
    name: z.optional(z.nullable(z.string())),
    email: z.optional(z.nullable(z.string())),
    fingerprint: z.optional(z.nullable(z.string())),
    metadata: z.optional(z.nullable(z.record(z.string(), z.any()))),
    stripeId: z.optional(z.nullable(z.string())),
    sendEmailReceipts: z.optional(z.boolean()),
    newCustomerId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      customerId: "customer_id",
      stripeId: "stripe_id",
      sendEmailReceipts: "send_email_receipts",
      newCustomerId: "new_customer_id",
    });
  }),
);

export function updateCustomerParamsToJSON(
  updateCustomerParams: UpdateCustomerParams,
): string {
  return JSON.stringify(
    UpdateCustomerParams$outboundSchema.parse(updateCustomerParams),
  );
}

/** @internal */
export const UpdateCustomerEnv$inboundSchema: z.ZodMiniType<
  UpdateCustomerEnv,
  unknown
> = openEnums.inboundSchema(UpdateCustomerEnv);

/** @internal */
export const UpdateCustomerStatus$inboundSchema: z.ZodMiniType<
  UpdateCustomerStatus,
  unknown
> = openEnums.inboundSchema(UpdateCustomerStatus);

/** @internal */
export const UpdateCustomerSubscription$inboundSchema: z.ZodMiniType<
  UpdateCustomerSubscription,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    auto_enable: types.boolean(),
    add_on: types.boolean(),
    status: UpdateCustomerStatus$inboundSchema,
    past_due: types.boolean(),
    canceled_at: types.nullable(types.number()),
    expires_at: types.nullable(types.number()),
    trial_ends_at: types.nullable(types.number()),
    started_at: types.number(),
    current_period_start: types.nullable(types.number()),
    current_period_end: types.nullable(types.number()),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "auto_enable": "autoEnable",
      "add_on": "addOn",
      "past_due": "pastDue",
      "canceled_at": "canceledAt",
      "expires_at": "expiresAt",
      "trial_ends_at": "trialEndsAt",
      "started_at": "startedAt",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
    });
  }),
);

export function updateCustomerSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerSubscription' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerPurchase$inboundSchema: z.ZodMiniType<
  UpdateCustomerPurchase,
  unknown
> = z.pipe(
  z.object({
    plan: types.optional(Plan$inboundSchema),
    plan_id: types.string(),
    expires_at: types.nullable(types.number()),
    started_at: types.number(),
    quantity: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "plan_id": "planId",
      "expires_at": "expiresAt",
      "started_at": "startedAt",
    });
  }),
);

export function updateCustomerPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerPurchase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerPurchase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerPurchase' from JSON`,
  );
}

/** @internal */
export const UpdateCustomerResponse$inboundSchema: z.ZodMiniType<
  UpdateCustomerResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.nullable(types.string()),
    name: types.nullable(types.string()),
    email: types.nullable(types.string()),
    created_at: types.number(),
    fingerprint: types.nullable(types.string()),
    stripe_id: types.nullable(types.string()),
    env: UpdateCustomerEnv$inboundSchema,
    metadata: z.record(z.string(), z.any()),
    send_email_receipts: types.boolean(),
    subscriptions: z.array(
      z.lazy(() => UpdateCustomerSubscription$inboundSchema),
    ),
    purchases: z.array(z.lazy(() => UpdateCustomerPurchase$inboundSchema)),
    balances: z.record(z.string(), Balance$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "stripe_id": "stripeId",
      "send_email_receipts": "sendEmailReceipts",
    });
  }),
);

export function updateCustomerResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCustomerResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCustomerResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCustomerResponse' from JSON`,
  );
}
