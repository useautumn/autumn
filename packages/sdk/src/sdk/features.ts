/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { featuresCreate } from "../funcs/features-create.js";
import { featuresDelete } from "../funcs/features-delete.js";
import { featuresGet } from "../funcs/features-get.js";
import { featuresList } from "../funcs/features-list.js";
import { featuresUpdate } from "../funcs/features-update.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Features extends ClientSDK {
  /**
   * Creates a new feature.
   *
   * Use this to programmatically create features for metering usage, managing access, or building credit systems.
   *
   * @example
   * ```typescript
   * // Create a metered feature for API calls
   * const response = await client.features.create({
   *
   *   featureId: "api-calls",
   *   name: "API Calls",
   *   type: "metered",
   *   consumable: true,
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Create a boolean feature for a premium feature flag
   * const response = await client.features.create({ featureId: "advanced-analytics", name: "Advanced Analytics", type: "boolean" });
   * ```
   *
   * @param name - The name of the feature.
   * @param type - The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system.
   * @param consumable - Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features. (optional)
   * @param display - Singular and plural display names for the feature in your user interface. (optional)
   * @param creditSchema - A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features. (optional)
   * @param featureId - The ID of the feature to create.
   *
   * @returns The created feature object.
   */
  async create(
    request: models.CreateFeatureParams,
    options?: RequestOptions,
  ): Promise<models.CreateFeatureResponse> {
    return unwrapAsync(featuresCreate(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieves a single feature by its ID.
   *
   * Use this when you need to fetch the details of a specific feature.
   *
   * @example
   * ```typescript
   * // Get a feature by ID
   * const response = await client.features.get({ featureId: "api-calls" });
   * ```
   *
   * @param featureId - The ID of the feature.
   *
   * @returns The feature object with its full configuration.
   */
  async get(
    request: models.GetFeatureParams,
    options?: RequestOptions,
  ): Promise<models.GetFeatureResponse> {
    return unwrapAsync(featuresGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Lists all features in the current environment.
   *
   * Use this to retrieve all features configured for your organization to display in dashboards or for feature management.
   *
   * @returns A list of all features with their configuration and metadata.
   */
  async list(
    request?: models.ListFeaturesRequest | undefined,
    options?: RequestOptions,
  ): Promise<models.ListFeaturesResponse> {
    return unwrapAsync(featuresList(
      this,
      request,
      options,
    ));
  }

  /**
   * Updates an existing feature.
   *
   * Use this to modify feature properties like name, display settings, or to archive a feature.
   *
   * @example
   * ```typescript
   * // Update a feature's display name
   * const response = await client.features.update({ featureId: "api-calls", name: "API Requests", display: {"singular":"API request","plural":"API requests"} });
   * ```
   *
   * @example
   * ```typescript
   * // Archive a feature
   * const response = await client.features.update({ featureId: "deprecated-feature", archived: true });
   * ```
   *
   * @param name - The name of the feature. (optional)
   * @param type - The type of the feature. 'single_use' features are consumed, like API calls, tokens, or messages. 'continuous_use' features are allocated, like seats, workspaces, or projects. 'credit_system' features are schemas that unify multiple 'single_use' features into a single credit system. (optional)
   * @param consumable - Whether this feature is consumable. A consumable feature is one that periodically resets and is consumed rather than allocated (like credits, API requests, etc.). Applicable only for 'metered' features. (optional)
   * @param display - Singular and plural display names for the feature in your user interface. (optional)
   * @param creditSchema - A schema that maps 'single_use' feature IDs to credit costs. Applicable only for 'credit_system' features. (optional)
   * @param archived - Whether the feature is archived. Archived features are hidden from the dashboard. (optional)
   * @param featureId - The ID of the feature to update.
   * @param newFeatureId - The new ID of the feature. Feature ID can only be updated if it's not being used by any customers. (optional)
   *
   * @returns The updated feature object.
   */
  async update(
    request: models.UpdateFeatureParams,
    options?: RequestOptions,
  ): Promise<models.UpdateFeatureResponse> {
    return unwrapAsync(featuresUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Deletes a feature by its ID.
   *
   * Use this to permanently remove a feature. Note: features that are used in products cannot be deleted - archive them instead.
   *
   * @example
   * ```typescript
   * // Delete an unused feature
   * const response = await client.features.delete({ featureId: "old-feature" });
   * ```
   *
   * @param featureId - The ID of the feature to delete.
   *
   * @returns A success flag indicating the feature was deleted.
   */
  async delete(
    request: models.DeleteFeatureParams,
    options?: RequestOptions,
  ): Promise<models.DeleteFeatureResponse> {
    return unwrapAsync(featuresDelete(
      this,
      request,
      options,
    ));
  }
}
